
FreeRTOS-Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000c8  00800100  00001fc6  0000205a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001fc6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000004a3  008001c8  008001c8  00002122  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002122  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002154  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000468  00000000  00000000  00002194  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005691  00000000  00000000  000025fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000015d0  00000000  00000000  00007c8d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002e53  00000000  00000000  0000925d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000e60  00000000  00000000  0000c0b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001baf  00000000  00000000  0000cf10  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005405  00000000  00000000  0000eabf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004c8  00000000  00000000  00013ec4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 75 00 	jmp	0xea	; 0xea <__ctors_end>
       4:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
       8:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
       c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      10:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      14:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      18:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      1c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      20:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      24:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      28:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      2c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      30:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      34:	0c 94 8a 04 	jmp	0x914	; 0x914 <__vector_13>
      38:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      3c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      40:	0c 94 d7 01 	jmp	0x3ae	; 0x3ae <__vector_16>
      44:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      48:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      4c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      50:	0c 94 80 05 	jmp	0xb00	; 0xb00 <__vector_20>
      54:	0c 94 be 05 	jmp	0xb7c	; 0xb7c <__vector_21>
      58:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      5c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      60:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      64:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      68:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      6c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      70:	0c 94 06 06 	jmp	0xc0c	; 0xc0c <__vector_28>
      74:	0c 94 44 06 	jmp	0xc88	; 0xc88 <__vector_29>
      78:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      7c:	ae 00       	.word	0x00ae	; ????
      7e:	ac 00       	.word	0x00ac	; ????
      80:	ac 00       	.word	0x00ac	; ????
      82:	ae 00       	.word	0x00ae	; ????
      84:	ac 00       	.word	0x00ac	; ????
      86:	ac 00       	.word	0x00ac	; ????
      88:	ac 00       	.word	0x00ac	; ????
      8a:	ac 00       	.word	0x00ac	; ????
      8c:	ac 00       	.word	0x00ac	; ????
      8e:	ac 00       	.word	0x00ac	; ????
      90:	ac 00       	.word	0x00ac	; ????
      92:	ac 00       	.word	0x00ac	; ????
      94:	ac 00       	.word	0x00ac	; ????
      96:	ac 00       	.word	0x00ac	; ????
      98:	ac 00       	.word	0x00ac	; ????
      9a:	ac 00       	.word	0x00ac	; ????
      9c:	ac 00       	.word	0x00ac	; ????
      9e:	ac 00       	.word	0x00ac	; ????
      a0:	ae 00       	.word	0x00ae	; ????
      a2:	ac 00       	.word	0x00ac	; ????
      a4:	ac 00       	.word	0x00ac	; ????
      a6:	ac 00       	.word	0x00ac	; ????
      a8:	ae 00       	.word	0x00ae	; ????
      aa:	ac 00       	.word	0x00ac	; ????
      ac:	ac 00       	.word	0x00ac	; ????
      ae:	ac 00       	.word	0x00ac	; ????
      b0:	ac 00       	.word	0x00ac	; ????
      b2:	ac 00       	.word	0x00ac	; ????
      b4:	ac 00       	.word	0x00ac	; ????
      b6:	ac 00       	.word	0x00ac	; ????
      b8:	ac 00       	.word	0x00ac	; ????
      ba:	ac 00       	.word	0x00ac	; ????
      bc:	ae 00       	.word	0x00ae	; ????
      be:	ac 00       	.word	0x00ac	; ????
      c0:	ac 00       	.word	0x00ac	; ????
      c2:	ae 00       	.word	0x00ae	; ????
      c4:	ac 00       	.word	0x00ac	; ????
      c6:	ac 00       	.word	0x00ac	; ????
      c8:	ac 00       	.word	0x00ac	; ????
      ca:	ac 00       	.word	0x00ac	; ????
      cc:	ac 00       	.word	0x00ac	; ????
      ce:	ac 00       	.word	0x00ac	; ????
      d0:	ac 00       	.word	0x00ac	; ????
      d2:	ac 00       	.word	0x00ac	; ????
      d4:	ac 00       	.word	0x00ac	; ????
      d6:	ac 00       	.word	0x00ac	; ????
      d8:	ac 00       	.word	0x00ac	; ????
      da:	ac 00       	.word	0x00ac	; ????
      dc:	ac 00       	.word	0x00ac	; ????
      de:	ac 00       	.word	0x00ac	; ????
      e0:	ae 00       	.word	0x00ae	; ????
      e2:	ac 00       	.word	0x00ac	; ????
      e4:	ac 00       	.word	0x00ac	; ????
      e6:	ac 00       	.word	0x00ac	; ????
      e8:	ae 00       	.word	0x00ae	; ????

000000ea <__ctors_end>:
      ea:	11 24       	eor	r1, r1
      ec:	1f be       	out	0x3f, r1	; 63
      ee:	cf ef       	ldi	r28, 0xFF	; 255
      f0:	d8 e0       	ldi	r29, 0x08	; 8
      f2:	de bf       	out	0x3e, r29	; 62
      f4:	cd bf       	out	0x3d, r28	; 61

000000f6 <__do_copy_data>:
      f6:	11 e0       	ldi	r17, 0x01	; 1
      f8:	a0 e0       	ldi	r26, 0x00	; 0
      fa:	b1 e0       	ldi	r27, 0x01	; 1
      fc:	e6 ec       	ldi	r30, 0xC6	; 198
      fe:	ff e1       	ldi	r31, 0x1F	; 31
     100:	02 c0       	rjmp	.+4      	; 0x106 <__do_copy_data+0x10>
     102:	05 90       	lpm	r0, Z+
     104:	0d 92       	st	X+, r0
     106:	a8 3c       	cpi	r26, 0xC8	; 200
     108:	b1 07       	cpc	r27, r17
     10a:	d9 f7       	brne	.-10     	; 0x102 <__do_copy_data+0xc>

0000010c <__do_clear_bss>:
     10c:	26 e0       	ldi	r18, 0x06	; 6
     10e:	a8 ec       	ldi	r26, 0xC8	; 200
     110:	b1 e0       	ldi	r27, 0x01	; 1
     112:	01 c0       	rjmp	.+2      	; 0x116 <.do_clear_bss_start>

00000114 <.do_clear_bss_loop>:
     114:	1d 92       	st	X+, r1

00000116 <.do_clear_bss_start>:
     116:	ab 36       	cpi	r26, 0x6B	; 107
     118:	b2 07       	cpc	r27, r18
     11a:	e1 f7       	brne	.-8      	; 0x114 <.do_clear_bss_loop>
     11c:	0e 94 7f 01 	call	0x2fe	; 0x2fe <main>
     120:	0c 94 e1 0f 	jmp	0x1fc2	; 0x1fc2 <_exit>

00000124 <__bad_interrupt>:
     124:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000128 <processMatrix>:
void processMatrix(void* pvParameters) {
	
	//The parameters are not used
	( void ) pvParameters;
	
	if (run_process_matrix == 1) {
     128:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <run_process_matrix>
     12c:	88 23       	and	r24, r24
     12e:	29 f0       	breq	.+10     	; 0x13a <processMatrix+0x12>
		com_send_bytes((uint8_t *)"Processing matrix...!\n", 22);
     130:	66 e1       	ldi	r22, 0x16	; 22
     132:	8a e0       	ldi	r24, 0x0A	; 10
     134:	91 e0       	ldi	r25, 0x01	; 1
     136:	0e 94 00 02 	call	0x400	; 0x400 <com_send_bytes>
     13a:	08 95       	ret

0000013c <correctArrowKey>:
}*/


bool correctArrowKey(char data_received[])
{
	switch (data_received[0])
     13c:	dc 01       	movw	r26, r24
     13e:	ec 91       	ld	r30, X
     140:	8e 2f       	mov	r24, r30
     142:	90 e0       	ldi	r25, 0x00	; 0
     144:	fc 01       	movw	r30, r24
     146:	e1 54       	subi	r30, 0x41	; 65
     148:	f1 09       	sbc	r31, r1
     14a:	e7 33       	cpi	r30, 0x37	; 55
     14c:	f1 05       	cpc	r31, r1
     14e:	20 f4       	brcc	.+8      	; 0x158 <correctArrowKey+0x1c>
     150:	e2 5c       	subi	r30, 0xC2	; 194
     152:	ff 4f       	sbci	r31, 0xFF	; 255
     154:	0c 94 aa 0e 	jmp	0x1d54	; 0x1d54 <__tablejump2__>
		case 119 : return true;		//w
		case 68 : return true;		//D
		case 100 : return true;		//d
		case 83 : return true;		//S
		case 115 : return true;		//s
		default  : return false;
     158:	80 e0       	ldi	r24, 0x00	; 0
     15a:	08 95       	ret

bool correctArrowKey(char data_received[])
{
	switch (data_received[0])
	{
		case 65  : return true;		//A
     15c:	81 e0       	ldi	r24, 0x01	; 1
		case 115 : return true;		//s
		default  : return false;

	}
	
}
     15e:	08 95       	ret

00000160 <waitForHello>:

/************************************************************************/
/* CNC 20172505                                                         */
/************************************************************************/

void waitForHello(void *pvParameters){
     160:	cf 93       	push	r28
     162:	df 93       	push	r29
     164:	1f 92       	push	r1
     166:	cd b7       	in	r28, 0x3d	; 61
     168:	de b7       	in	r29, 0x3e	; 62
	//The parameters are not used
	( void ) pvParameters;

	#if (configUSE_APPLICATION_TASK_TAG == 1)
	// Set task no to be used for tracing with R2R-Network
	vTaskSetApplicationTaskTag( NULL, ( void * ) 1 );
     16a:	61 e0       	ldi	r22, 0x01	; 1
     16c:	70 e0       	ldi	r23, 0x00	; 0
     16e:	80 e0       	ldi	r24, 0x00	; 0
     170:	90 e0       	ldi	r25, 0x00	; 0
     172:	0e 94 b6 0c 	call	0x196c	; 0x196c <vTaskSetApplicationTaskTag>
	

	//Variables
	//BaseType_t received_data = 0;
	
	uint8_t data[] = "";
     176:	19 82       	std	Y+1, r1	; 0x01
	uint8_t response[] = { 0x4f, 0x4b };	//OK

	_received_chars_queue = xQueueCreate(_COM_RX_QUEUE_LENGTH, (unsigned portBASE_TYPE) sizeof (uint8_t));
     178:	40 e0       	ldi	r20, 0x00	; 0
     17a:	61 e0       	ldi	r22, 0x01	; 1
     17c:	8e e1       	ldi	r24, 0x1E	; 30
     17e:	0e 94 8f 07 	call	0xf1e	; 0xf1e <xQueueGenericCreate>
     182:	90 93 cd 01 	sts	0x01CD, r25	; 0x8001cd <_received_chars_queue+0x1>
     186:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <_received_chars_queue>
	init_com(_received_chars_queue);	//Initialize comPort at the board
     18a:	0e 94 c0 01 	call	0x380	; 0x380 <init_com>

	vTaskDelay(500);
     18e:	84 ef       	ldi	r24, 0xF4	; 244
     190:	91 e0       	ldi	r25, 0x01	; 1
     192:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <vTaskDelay>
	while (1) {

		vTaskDelay(500);
     196:	84 ef       	ldi	r24, 0xF4	; 244
     198:	91 e0       	ldi	r25, 0x01	; 1
     19a:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <vTaskDelay>
		//Check until we receive something - Waiting for a number 1.
		if (xQueueReceive(_received_chars_queue, &data, ( TickType_t ) 10)) {
     19e:	20 e0       	ldi	r18, 0x00	; 0
     1a0:	4a e0       	ldi	r20, 0x0A	; 10
     1a2:	50 e0       	ldi	r21, 0x00	; 0
     1a4:	be 01       	movw	r22, r28
     1a6:	6f 5f       	subi	r22, 0xFF	; 255
     1a8:	7f 4f       	sbci	r23, 0xFF	; 255
     1aa:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <_received_chars_queue>
     1ae:	90 91 cd 01 	lds	r25, 0x01CD	; 0x8001cd <_received_chars_queue+0x1>
     1b2:	0e 94 b5 08 	call	0x116a	; 0x116a <xQueueGenericReceive>
     1b6:	88 23       	and	r24, r24
     1b8:	71 f3       	breq	.-36     	; 0x196 <waitForHello+0x36>
			
			com_send_bytes(data, 1);
     1ba:	61 e0       	ldi	r22, 0x01	; 1
     1bc:	ce 01       	movw	r24, r28
     1be:	01 96       	adiw	r24, 0x01	; 1
     1c0:	0e 94 00 02 	call	0x400	; 0x400 <com_send_bytes>

			if (data[0] == 49){		//If it's equal as 1
     1c4:	89 81       	ldd	r24, Y+1	; 0x01
     1c6:	81 33       	cpi	r24, 0x31	; 49
     1c8:	09 f0       	breq	.+2      	; 0x1cc <waitForHello+0x6c>
     1ca:	54 c0       	rjmp	.+168    	; 0x274 <waitForHello+0x114>
				//Send first confirmation message to the console.
				
				com_send_bytes((uint8_t *)" Ready to receive - Reading...\n", 32);
     1cc:	60 e2       	ldi	r22, 0x20	; 32
     1ce:	81 e2       	ldi	r24, 0x21	; 33
     1d0:	91 e0       	ldi	r25, 0x01	; 1
     1d2:	0e 94 00 02 	call	0x400	; 0x400 <com_send_bytes>
				
				vTaskDelay(500);
     1d6:	84 ef       	ldi	r24, 0xF4	; 244
     1d8:	91 e0       	ldi	r25, 0x01	; 1
     1da:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <vTaskDelay>

				while (1) {
					if (xQueueReceive(_received_chars_queue, &data,  ( TickType_t ) 10)){
     1de:	20 e0       	ldi	r18, 0x00	; 0
     1e0:	4a e0       	ldi	r20, 0x0A	; 10
     1e2:	50 e0       	ldi	r21, 0x00	; 0
     1e4:	be 01       	movw	r22, r28
     1e6:	6f 5f       	subi	r22, 0xFF	; 255
     1e8:	7f 4f       	sbci	r23, 0xFF	; 255
     1ea:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <_received_chars_queue>
     1ee:	90 91 cd 01 	lds	r25, 0x01CD	; 0x8001cd <_received_chars_queue+0x1>
     1f2:	0e 94 b5 08 	call	0x116a	; 0x116a <xQueueGenericReceive>
     1f6:	88 23       	and	r24, r24
     1f8:	91 f3       	breq	.-28     	; 0x1de <waitForHello+0x7e>
						if (correctArrowKey(&data) == true) {
     1fa:	ce 01       	movw	r24, r28
     1fc:	01 96       	adiw	r24, 0x01	; 1
     1fe:	0e 94 9e 00 	call	0x13c	; 0x13c <correctArrowKey>
     202:	88 23       	and	r24, r24
     204:	61 f3       	breq	.-40     	; 0x1de <waitForHello+0x7e>
							com_send_bytes((uint8_t *)" Key: ", 6);
     206:	66 e0       	ldi	r22, 0x06	; 6
     208:	81 e4       	ldi	r24, 0x41	; 65
     20a:	91 e0       	ldi	r25, 0x01	; 1
     20c:	0e 94 00 02 	call	0x400	; 0x400 <com_send_bytes>
							com_send_bytes((uint8_t *)data, 1);
     210:	61 e0       	ldi	r22, 0x01	; 1
     212:	ce 01       	movw	r24, r28
     214:	01 96       	adiw	r24, 0x01	; 1
     216:	0e 94 00 02 	call	0x400	; 0x400 <com_send_bytes>
							
							xMutexReceivedData = xSemaphoreCreateMutex();
     21a:	81 e0       	ldi	r24, 0x01	; 1
     21c:	0e 94 61 08 	call	0x10c2	; 0x10c2 <xQueueCreateMutex>
     220:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <xMutexReceivedData+0x1>
     224:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <xMutexReceivedData>
							if (xSemaphoreTake(xMutexReceivedData, (TickType_t) 10 ) == pdTRUE) {
     228:	20 e0       	ldi	r18, 0x00	; 0
     22a:	4a e0       	ldi	r20, 0x0A	; 10
     22c:	50 e0       	ldi	r21, 0x00	; 0
     22e:	60 e0       	ldi	r22, 0x00	; 0
     230:	70 e0       	ldi	r23, 0x00	; 0
     232:	0e 94 b5 08 	call	0x116a	; 0x116a <xQueueGenericReceive>
     236:	81 30       	cpi	r24, 0x01	; 1
     238:	71 f4       	brne	.+28     	; 0x256 <waitForHello+0xf6>
								run_process_matrix = 1;
     23a:	80 93 c9 01 	sts	0x01C9, r24	; 0x8001c9 <run_process_matrix>
								xSemaphoreGive(xMutexReceivedData);
     23e:	20 e0       	ldi	r18, 0x00	; 0
     240:	40 e0       	ldi	r20, 0x00	; 0
     242:	50 e0       	ldi	r21, 0x00	; 0
     244:	60 e0       	ldi	r22, 0x00	; 0
     246:	70 e0       	ldi	r23, 0x00	; 0
     248:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <xMutexReceivedData>
     24c:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <xMutexReceivedData+0x1>
     250:	0e 94 c0 07 	call	0xf80	; 0xf80 <xQueueGenericSend>
     254:	c4 cf       	rjmp	.-120    	; 0x1de <waitForHello+0x7e>
							} else if (data[0] == 32) {
     256:	89 81       	ldd	r24, Y+1	; 0x01
     258:	80 32       	cpi	r24, 0x20	; 32
     25a:	31 f4       	brne	.+12     	; 0x268 <waitForHello+0x108>
							com_send_bytes((uint8_t *)"Pause mode\n", 12);
     25c:	6c e0       	ldi	r22, 0x0C	; 12
     25e:	88 e4       	ldi	r24, 0x48	; 72
     260:	91 e0       	ldi	r25, 0x01	; 1
     262:	0e 94 00 02 	call	0x400	; 0x400 <com_send_bytes>
     266:	bb cf       	rjmp	.-138    	; 0x1de <waitForHello+0x7e>
							} else {
							com_send_bytes((uint8_t *)"Not a valid key\n", 16);
     268:	60 e1       	ldi	r22, 0x10	; 16
     26a:	84 e5       	ldi	r24, 0x54	; 84
     26c:	91 e0       	ldi	r25, 0x01	; 1
     26e:	0e 94 00 02 	call	0x400	; 0x400 <com_send_bytes>
     272:	b5 cf       	rjmp	.-150    	; 0x1de <waitForHello+0x7e>
							}
						}
					}
				}
			} else {
			com_send_bytes((uint8_t *)"Not a valid key - Press 1 to play\n", 35);
     274:	63 e2       	ldi	r22, 0x23	; 35
     276:	85 e6       	ldi	r24, 0x65	; 101
     278:	91 e0       	ldi	r25, 0x01	; 1
     27a:	0e 94 00 02 	call	0x400	; 0x400 <com_send_bytes>
			vTaskDelay(500);
     27e:	84 ef       	ldi	r24, 0xF4	; 244
     280:	91 e0       	ldi	r25, 0x01	; 1
     282:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <vTaskDelay>
     286:	87 cf       	rjmp	.-242    	; 0x196 <waitForHello+0x36>

00000288 <prepare_shiftregister>:

// Prepare shift register setting SER = 1
void prepare_shiftregister()
{
	// Set SER to 1
	PORTD |= _BV(PORTD2);
     288:	5a 9a       	sbi	0x0b, 2	; 11
     28a:	08 95       	ret

0000028c <clock_shift_register_and_prepare_for_next_col>:

// clock shift-register
void clock_shift_register_and_prepare_for_next_col()
{
	// one SCK pulse
	PORTD |= _BV(PORTD5);
     28c:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD &= ~_BV(PORTD5);
     28e:	5d 98       	cbi	0x0b, 5	; 11
	
	// one RCK pulse
	PORTD |= _BV(PORTD4);
     290:	5c 9a       	sbi	0x0b, 4	; 11
	PORTD &= ~_BV(PORTD4);
     292:	5c 98       	cbi	0x0b, 4	; 11
	
	// Set SER to 0 - for next column
	PORTD &= ~_BV(PORTD2);
     294:	5a 98       	cbi	0x0b, 2	; 11
     296:	08 95       	ret

00000298 <load_col_value>:
}

// Load column value for column to show
void load_col_value(uint16_t col_value)
{
	PORTA = ~(col_value & 0xFF);
     298:	80 95       	com	r24
     29a:	82 b9       	out	0x02, r24	; 2
	
	// Manipulate only with PB0 and PB1
	PORTB |= 0x03;
     29c:	85 b1       	in	r24, 0x05	; 5
     29e:	83 60       	ori	r24, 0x03	; 3
     2a0:	85 b9       	out	0x05, r24	; 5
	PORTB &= ~((col_value >> 8) & 0x03);
     2a2:	85 b1       	in	r24, 0x05	; 5
     2a4:	93 70       	andi	r25, 0x03	; 3
     2a6:	90 95       	com	r25
     2a8:	89 23       	and	r24, r25
     2aa:	85 b9       	out	0x05, r24	; 5
     2ac:	08 95       	ret

000002ae <handle_display>:
}

//-----------------------------------------
void handle_display(void)
{
     2ae:	cf 93       	push	r28
	static uint8_t col = 0;
	
	if (col == 0)
     2b0:	c0 91 c8 01 	lds	r28, 0x01C8	; 0x8001c8 <__data_end>
     2b4:	c1 11       	cpse	r28, r1
     2b6:	0c c0       	rjmp	.+24     	; 0x2d0 <handle_display+0x22>
	{
		prepare_shiftregister();
     2b8:	0e 94 44 01 	call	0x288	; 0x288 <prepare_shiftregister>
	}
	
	load_col_value(frame_buf[col]);
     2bc:	80 e0       	ldi	r24, 0x00	; 0
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	0e 94 4c 01 	call	0x298	; 0x298 <load_col_value>
	
	clock_shift_register_and_prepare_for_next_col();
     2c4:	0e 94 46 01 	call	0x28c	; 0x28c <clock_shift_register_and_prepare_for_next_col>
	
	// count column up - prepare for next
	col++;
     2c8:	81 e0       	ldi	r24, 0x01	; 1
     2ca:	80 93 c8 01 	sts	0x01C8, r24	; 0x8001c8 <__data_end>
     2ce:	14 c0       	rjmp	.+40     	; 0x2f8 <handle_display+0x4a>
	if (col == 0)
	{
		prepare_shiftregister();
	}
	
	load_col_value(frame_buf[col]);
     2d0:	ec 2f       	mov	r30, r28
     2d2:	f0 e0       	ldi	r31, 0x00	; 0
     2d4:	ee 0f       	add	r30, r30
     2d6:	ff 1f       	adc	r31, r31
     2d8:	ea 55       	subi	r30, 0x5A	; 90
     2da:	fe 4f       	sbci	r31, 0xFE	; 254
     2dc:	80 81       	ld	r24, Z
     2de:	91 81       	ldd	r25, Z+1	; 0x01
     2e0:	0e 94 4c 01 	call	0x298	; 0x298 <load_col_value>
	
	clock_shift_register_and_prepare_for_next_col();
     2e4:	0e 94 46 01 	call	0x28c	; 0x28c <clock_shift_register_and_prepare_for_next_col>
	
	// count column up - prepare for next
	col++;
     2e8:	cf 5f       	subi	r28, 0xFF	; 255
	if (col > 13)
     2ea:	ce 30       	cpi	r28, 0x0E	; 14
     2ec:	18 f4       	brcc	.+6      	; 0x2f4 <handle_display+0x46>
	load_col_value(frame_buf[col]);
	
	clock_shift_register_and_prepare_for_next_col();
	
	// count column up - prepare for next
	col++;
     2ee:	c0 93 c8 01 	sts	0x01C8, r28	; 0x8001c8 <__data_end>
     2f2:	02 c0       	rjmp	.+4      	; 0x2f8 <handle_display+0x4a>
	if (col > 13)
	{
		col = 0;
     2f4:	10 92 c8 01 	sts	0x01C8, r1	; 0x8001c8 <__data_end>
	}
}
     2f8:	cf 91       	pop	r28
     2fa:	08 95       	ret

000002fc <vApplicationIdleHook>:

//-----------------------------------------
void vApplicationIdleHook( void )
{
     2fc:	08 95       	ret

000002fe <main>:

//-----------------------------------------
int main(void)
{
	
	init_board();
     2fe:	0e 94 09 02 	call	0x412	; 0x412 <init_board>
	
	// Shift register Enable output (G=0)
	PORTD &= ~_BV(PORTD6);
     302:	5e 98       	cbi	0x0b, 6	; 11
	
	//Create task to blink gpio
	BaseType_t taskWaitForHello = xTaskCreate(waitForHello, (const char *)"Wait for hello", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY, NULL);
     304:	e1 2c       	mov	r14, r1
     306:	f1 2c       	mov	r15, r1
     308:	00 e0       	ldi	r16, 0x00	; 0
     30a:	20 e0       	ldi	r18, 0x00	; 0
     30c:	30 e0       	ldi	r19, 0x00	; 0
     30e:	45 e5       	ldi	r20, 0x55	; 85
     310:	50 e0       	ldi	r21, 0x00	; 0
     312:	68 e8       	ldi	r22, 0x88	; 136
     314:	71 e0       	ldi	r23, 0x01	; 1
     316:	80 eb       	ldi	r24, 0xB0	; 176
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <xTaskCreate>

	BaseType_t taskProcessMatrix = xTaskCreate(processMatrix, (const char *)"Process Matrix", configMINIMAL_STACK_SIZE, (void *) NULL, tskIDLE_PRIORITY, NULL);
     31e:	20 e0       	ldi	r18, 0x00	; 0
     320:	30 e0       	ldi	r19, 0x00	; 0
     322:	45 e5       	ldi	r20, 0x55	; 85
     324:	50 e0       	ldi	r21, 0x00	; 0
     326:	67 e9       	ldi	r22, 0x97	; 151
     328:	71 e0       	ldi	r23, 0x01	; 1
     32a:	84 e9       	ldi	r24, 0x94	; 148
     32c:	90 e0       	ldi	r25, 0x00	; 0
     32e:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <xTaskCreate>

	// Start the display handler timer
	init_display_timer(handle_display);
     332:	87 e5       	ldi	r24, 0x57	; 87
     334:	91 e0       	ldi	r25, 0x01	; 1
     336:	0e 94 c5 01 	call	0x38a	; 0x38a <init_display_timer>
	
	sei();
     33a:	78 94       	sei
	
	//Start the scheduler
	vTaskStartScheduler();
     33c:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <vTaskStartScheduler>
     340:	ff cf       	rjmp	.-2      	; 0x340 <main+0x42>

00000342 <_com_call_back>:

// Pointer to application display handler
static display_callback_ptr_t cb_ptr = NULL;

// ----------------------------------------------------------------------------------------------------------------------
static void _com_call_back(serial_p _com_serial_instance, uint8_t serial_last_received_byte) {
     342:	cf 93       	push	r28
     344:	df 93       	push	r29
     346:	00 d0       	rcall	.+0      	; 0x348 <_com_call_back+0x6>
     348:	cd b7       	in	r28, 0x3d	; 61
     34a:	de b7       	in	r29, 0x3e	; 62
     34c:	6a 83       	std	Y+2, r22	; 0x02
	if (_x_rx_com_queue) {
     34e:	80 91 16 02 	lds	r24, 0x0216	; 0x800216 <_x_rx_com_queue>
     352:	90 91 17 02 	lds	r25, 0x0217	; 0x800217 <_x_rx_com_queue+0x1>
     356:	00 97       	sbiw	r24, 0x00	; 0
     358:	71 f0       	breq	.+28     	; 0x376 <_com_call_back+0x34>
		signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     35a:	19 82       	std	Y+1, r1	; 0x01

		xQueueSendFromISR( _x_rx_com_queue, &serial_last_received_byte, &xHigherPriorityTaskWoken );
     35c:	20 e0       	ldi	r18, 0x00	; 0
     35e:	ae 01       	movw	r20, r28
     360:	4f 5f       	subi	r20, 0xFF	; 255
     362:	5f 4f       	sbci	r21, 0xFF	; 255
     364:	be 01       	movw	r22, r28
     366:	6e 5f       	subi	r22, 0xFE	; 254
     368:	7f 4f       	sbci	r23, 0xFF	; 255
     36a:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <xQueueGenericSendFromISR>

		if( xHigherPriorityTaskWoken != pdFALSE )
     36e:	89 81       	ldd	r24, Y+1	; 0x01
     370:	81 11       	cpse	r24, r1
		{
			taskYIELD();
     372:	0e 94 d5 03 	call	0x7aa	; 0x7aa <vPortYield>
		}
	}
}
     376:	0f 90       	pop	r0
     378:	0f 90       	pop	r0
     37a:	df 91       	pop	r29
     37c:	cf 91       	pop	r28
     37e:	08 95       	ret

00000380 <init_com>:

// ----------------------------------------------------------------------------------------------------------------------
void init_com(QueueHandle_t x_rx_queue) {
	_x_rx_com_queue = x_rx_queue;
     380:	90 93 17 02 	sts	0x0217, r25	; 0x800217 <_x_rx_com_queue+0x1>
     384:	80 93 16 02 	sts	0x0216, r24	; 0x800216 <_x_rx_com_queue>
     388:	08 95       	ret

0000038a <init_display_timer>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_display_timer(display_callback_ptr_t cb)
{
	cb_ptr = cb;
     38a:	90 93 15 02 	sts	0x0215, r25	; 0x800215 <cb_ptr+0x1>
     38e:	80 93 14 02 	sts	0x0214, r24	; 0x800214 <cb_ptr>
	
	// Setup timer T0 to CTC, ~1309 Hz
	OCR0A = 10;
     392:	8a e0       	ldi	r24, 0x0A	; 10
     394:	87 bd       	out	0x27, r24	; 39
	TCCR0A |= _BV(WGM01); // Mode 2
     396:	84 b5       	in	r24, 0x24	; 36
     398:	82 60       	ori	r24, 0x02	; 2
     39a:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= _BV(OCIE0A); // Enable interrupt
     39c:	ee e6       	ldi	r30, 0x6E	; 110
     39e:	f0 e0       	ldi	r31, 0x00	; 0
     3a0:	80 81       	ld	r24, Z
     3a2:	82 60       	ori	r24, 0x02	; 2
     3a4:	80 83       	st	Z, r24
	TCCR0B |= _BV(CS00) | _BV(CS02); // Prescaler 1024 - and start timer
     3a6:	85 b5       	in	r24, 0x25	; 37
     3a8:	85 60       	ori	r24, 0x05	; 5
     3aa:	85 bd       	out	0x25, r24	; 37
     3ac:	08 95       	ret

000003ae <__vector_16>:
}

// ----------------------------------------------------------------------------------------------------------------------
//ISR for display timer
ISR(TIMER0_COMPA_vect)
{
     3ae:	1f 92       	push	r1
     3b0:	0f 92       	push	r0
     3b2:	0f b6       	in	r0, 0x3f	; 63
     3b4:	0f 92       	push	r0
     3b6:	11 24       	eor	r1, r1
     3b8:	2f 93       	push	r18
     3ba:	3f 93       	push	r19
     3bc:	4f 93       	push	r20
     3be:	5f 93       	push	r21
     3c0:	6f 93       	push	r22
     3c2:	7f 93       	push	r23
     3c4:	8f 93       	push	r24
     3c6:	9f 93       	push	r25
     3c8:	af 93       	push	r26
     3ca:	bf 93       	push	r27
     3cc:	ef 93       	push	r30
     3ce:	ff 93       	push	r31
	if (cb_ptr)
     3d0:	e0 91 14 02 	lds	r30, 0x0214	; 0x800214 <cb_ptr>
     3d4:	f0 91 15 02 	lds	r31, 0x0215	; 0x800215 <cb_ptr+0x1>
     3d8:	30 97       	sbiw	r30, 0x00	; 0
     3da:	09 f0       	breq	.+2      	; 0x3de <__vector_16+0x30>
	{
		cb_ptr();
     3dc:	09 95       	icall
	}
}
     3de:	ff 91       	pop	r31
     3e0:	ef 91       	pop	r30
     3e2:	bf 91       	pop	r27
     3e4:	af 91       	pop	r26
     3e6:	9f 91       	pop	r25
     3e8:	8f 91       	pop	r24
     3ea:	7f 91       	pop	r23
     3ec:	6f 91       	pop	r22
     3ee:	5f 91       	pop	r21
     3f0:	4f 91       	pop	r20
     3f2:	3f 91       	pop	r19
     3f4:	2f 91       	pop	r18
     3f6:	0f 90       	pop	r0
     3f8:	0f be       	out	0x3f, r0	; 63
     3fa:	0f 90       	pop	r0
     3fc:	1f 90       	pop	r1
     3fe:	18 95       	reti

00000400 <com_send_bytes>:

// ----------------------------------------------------------------------------------------------------------------------
void com_send_bytes(uint8_t *bytes, uint8_t len) {
     400:	46 2f       	mov	r20, r22
	serial_send_bytes(_com_serial_instance, bytes, len);
     402:	bc 01       	movw	r22, r24
     404:	80 91 18 02 	lds	r24, 0x0218	; 0x800218 <_com_serial_instance>
     408:	90 91 19 02 	lds	r25, 0x0219	; 0x800219 <_com_serial_instance+0x1>
     40c:	0e 94 3d 05 	call	0xa7a	; 0xa7a <serial_send_bytes>
     410:	08 95       	ret

00000412 <init_board>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_board(void) {
     412:	8f 92       	push	r8
     414:	9f 92       	push	r9
     416:	af 92       	push	r10
     418:	bf 92       	push	r11
     41a:	cf 92       	push	r12
     41c:	df 92       	push	r13
     41e:	ef 92       	push	r14
     420:	0f 93       	push	r16
	static buffer_struct_t _com_rx_buffer;
	static buffer_struct_t _com_tx_buffer;
	buffer_init(&_com_rx_buffer);
     422:	81 ef       	ldi	r24, 0xF1	; 241
     424:	91 e0       	ldi	r25, 0x01	; 1
     426:	0e 94 62 02 	call	0x4c4	; 0x4c4 <buffer_init>
	buffer_init(&_com_tx_buffer);
     42a:	8e ec       	ldi	r24, 0xCE	; 206
     42c:	91 e0       	ldi	r25, 0x01	; 1
     42e:	0e 94 62 02 	call	0x4c4	; 0x4c4 <buffer_init>
	_com_serial_instance = serial_new_instance(ser_USART0, 115200UL, ser_BITS_8, ser_STOP_1, ser_NO_PARITY, &_com_rx_buffer, &_com_tx_buffer, _com_call_back);
     432:	0f 2e       	mov	r0, r31
     434:	f1 ea       	ldi	r31, 0xA1	; 161
     436:	8f 2e       	mov	r8, r31
     438:	f1 e0       	ldi	r31, 0x01	; 1
     43a:	9f 2e       	mov	r9, r31
     43c:	f0 2d       	mov	r31, r0
     43e:	0f 2e       	mov	r0, r31
     440:	fe ec       	ldi	r31, 0xCE	; 206
     442:	af 2e       	mov	r10, r31
     444:	f1 e0       	ldi	r31, 0x01	; 1
     446:	bf 2e       	mov	r11, r31
     448:	f0 2d       	mov	r31, r0
     44a:	0f 2e       	mov	r0, r31
     44c:	f1 ef       	ldi	r31, 0xF1	; 241
     44e:	cf 2e       	mov	r12, r31
     450:	f1 e0       	ldi	r31, 0x01	; 1
     452:	df 2e       	mov	r13, r31
     454:	f0 2d       	mov	r31, r0
     456:	e1 2c       	mov	r14, r1
     458:	00 e0       	ldi	r16, 0x00	; 0
     45a:	23 e0       	ldi	r18, 0x03	; 3
     45c:	40 e0       	ldi	r20, 0x00	; 0
     45e:	52 ec       	ldi	r21, 0xC2	; 194
     460:	61 e0       	ldi	r22, 0x01	; 1
     462:	70 e0       	ldi	r23, 0x00	; 0
     464:	80 e0       	ldi	r24, 0x00	; 0
     466:	0e 94 c3 04 	call	0x986	; 0x986 <serial_new_instance>
     46a:	90 93 19 02 	sts	0x0219, r25	; 0x800219 <_com_serial_instance+0x1>
     46e:	80 93 18 02 	sts	0x0218, r24	; 0x800218 <_com_serial_instance>
	
	// Pull up on Joystick inputs
	PORTC |= _BV(PORTC0) | _BV(PORTC1) | _BV(PORTC6) | _BV(PORTC7);
     472:	88 b1       	in	r24, 0x08	; 8
     474:	83 6c       	ori	r24, 0xC3	; 195
     476:	88 b9       	out	0x08, r24	; 8
	PORTD |= _BV(PORTD3);
     478:	5b 9a       	sbi	0x0b, 3	; 11
	
	// Shift register control pins to output
	// SER, RCK, SCK, G (enable output)
	DDRD |= _BV(DDD2) | _BV(DDD4) | _BV(DDD5) | _BV(DDD6);
     47a:	8a b1       	in	r24, 0x0a	; 10
     47c:	84 67       	ori	r24, 0x74	; 116
     47e:	8a b9       	out	0x0a, r24	; 10
	// G (enable output) high
	PORTD |= _BV(PORTD6);
     480:	5e 9a       	sbi	0x0b, 6	; 11
	
	// Column pins to output
	DDRA |= 0xFF;
     482:	81 b1       	in	r24, 0x01	; 1
     484:	8f ef       	ldi	r24, 0xFF	; 255
     486:	81 b9       	out	0x01, r24	; 1
	DDRB |= _BV(DDB0) | _BV(DDB1);
     488:	84 b1       	in	r24, 0x04	; 4
     48a:	83 60       	ori	r24, 0x03	; 3
     48c:	84 b9       	out	0x04, r24	; 4
	
	// Trace pins Task Monitor (R2R)
	DDRB |= _BV(DDB2) | _BV(DDB3) | _BV(DDB4) | _BV(DDB5);
     48e:	84 b1       	in	r24, 0x04	; 4
     490:	8c 63       	ori	r24, 0x3C	; 60
     492:	84 b9       	out	0x04, r24	; 4
}
     494:	0f 91       	pop	r16
     496:	ef 90       	pop	r14
     498:	df 90       	pop	r13
     49a:	cf 90       	pop	r12
     49c:	bf 90       	pop	r11
     49e:	af 90       	pop	r10
     4a0:	9f 90       	pop	r9
     4a2:	8f 90       	pop	r8
     4a4:	08 95       	ret

000004a6 <switch_in>:
	
	 Called by the the traceTASK_SWITCHED_IN() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_in(uint8_t task_no) {
		PORTB &= 0b11000011;
     4a6:	95 b1       	in	r25, 0x05	; 5
     4a8:	93 7c       	andi	r25, 0xC3	; 195
     4aa:	95 b9       	out	0x05, r25	; 5
		PORTB |= task_no << 2;
     4ac:	25 b1       	in	r18, 0x05	; 5
     4ae:	34 e0       	ldi	r19, 0x04	; 4
     4b0:	83 9f       	mul	r24, r19
     4b2:	c0 01       	movw	r24, r0
     4b4:	11 24       	eor	r1, r1
     4b6:	82 2b       	or	r24, r18
     4b8:	85 b9       	out	0x05, r24	; 5
     4ba:	08 95       	ret

000004bc <switch_out>:
	
	 Called by the the traceTASK_SWITCHED_OUT() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_out(uint8_t task_no) {
		PORTB &= 0b11000011;
     4bc:	85 b1       	in	r24, 0x05	; 5
     4be:	83 7c       	andi	r24, 0xC3	; 195
     4c0:	85 b9       	out	0x05, r24	; 5
     4c2:	08 95       	ret

000004c4 <buffer_init>:
  @endcode

 @note The buffer structure must be initialized before any of the buffer functions must be called.
 @param *buffer Pointer to the buffer structure to be used.
 ***********************************************/
void buffer_init(buffer_struct_t *buffer) {
     4c4:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     4c6:	10 a2       	std	Z+32, r1	; 0x20
	buffer->out_i = 0;
     4c8:	11 a2       	std	Z+33, r1	; 0x21
	buffer->no_in_buffer = 0;
     4ca:	12 a2       	std	Z+34, r1	; 0x22
     4cc:	08 95       	ret

000004ce <buffer_get_item>:
 @return BUFFER_OK: item removed from buffer and returned in item.\n
    BUFFER_EMPTY: The buffer is empty, item is not updated.
 @param *buffer pointer to the buffer structure.
 @param *item pointer to the variable where the value of the item is returned.
 ***********************************************/
uint8_t buffer_get_item(buffer_struct_t *buffer, uint8_t *item) {
     4ce:	fc 01       	movw	r30, r24
	if (buffer->no_in_buffer > 0) {
     4d0:	82 a1       	ldd	r24, Z+34	; 0x22
     4d2:	88 23       	and	r24, r24
     4d4:	d9 f0       	breq	.+54     	; 0x50c <buffer_get_item+0x3e>
		*item = buffer->storage[buffer->out_i];
     4d6:	81 a1       	ldd	r24, Z+33	; 0x21
     4d8:	df 01       	movw	r26, r30
     4da:	a8 0f       	add	r26, r24
     4dc:	b1 1d       	adc	r27, r1
     4de:	8c 91       	ld	r24, X
     4e0:	db 01       	movw	r26, r22
     4e2:	8c 93       	st	X, r24
		buffer->out_i = INCREMENT(buffer->out_i);
     4e4:	21 a1       	ldd	r18, Z+33	; 0x21
     4e6:	30 e0       	ldi	r19, 0x00	; 0
     4e8:	2f 5f       	subi	r18, 0xFF	; 255
     4ea:	3f 4f       	sbci	r19, 0xFF	; 255
     4ec:	2f 71       	andi	r18, 0x1F	; 31
     4ee:	30 78       	andi	r19, 0x80	; 128
     4f0:	33 23       	and	r19, r19
     4f2:	34 f4       	brge	.+12     	; 0x500 <buffer_get_item+0x32>
     4f4:	21 50       	subi	r18, 0x01	; 1
     4f6:	31 09       	sbc	r19, r1
     4f8:	20 6e       	ori	r18, 0xE0	; 224
     4fa:	3f 6f       	ori	r19, 0xFF	; 255
     4fc:	2f 5f       	subi	r18, 0xFF	; 255
     4fe:	3f 4f       	sbci	r19, 0xFF	; 255
     500:	21 a3       	std	Z+33, r18	; 0x21
		buffer->no_in_buffer--;
     502:	82 a1       	ldd	r24, Z+34	; 0x22
     504:	81 50       	subi	r24, 0x01	; 1
     506:	82 a3       	std	Z+34, r24	; 0x22
		return BUFFER_OK;
     508:	80 e0       	ldi	r24, 0x00	; 0
     50a:	08 95       	ret
	}
	return BUFFER_EMPTY;
     50c:	81 e0       	ldi	r24, 0x01	; 1
}
     50e:	08 95       	ret

00000510 <buffer_put_item>:
    BUFFER_FULL: The buffer is full, item is not stored.
 @param *buffer pointer to the buffer structure.
 @param item to be stored in the buffer.
 ***********************************************/
uint8_t buffer_put_item(buffer_struct_t *buffer, uint8_t item) {
	if (buffer->no_in_buffer<BUFFER_SIZE) {
     510:	fc 01       	movw	r30, r24
     512:	42 a1       	ldd	r20, Z+34	; 0x22
     514:	40 32       	cpi	r20, 0x20	; 32
     516:	b8 f4       	brcc	.+46     	; 0x546 <buffer_put_item+0x36>
		buffer->storage[buffer->in_i] = item;
     518:	20 a1       	ldd	r18, Z+32	; 0x20
     51a:	30 e0       	ldi	r19, 0x00	; 0
     51c:	e2 0f       	add	r30, r18
     51e:	f3 1f       	adc	r31, r19
     520:	60 83       	st	Z, r22
		buffer->in_i = INCREMENT(buffer->in_i);
     522:	2f 5f       	subi	r18, 0xFF	; 255
     524:	3f 4f       	sbci	r19, 0xFF	; 255
     526:	2f 71       	andi	r18, 0x1F	; 31
     528:	30 78       	andi	r19, 0x80	; 128
     52a:	33 23       	and	r19, r19
     52c:	34 f4       	brge	.+12     	; 0x53a <buffer_put_item+0x2a>
     52e:	21 50       	subi	r18, 0x01	; 1
     530:	31 09       	sbc	r19, r1
     532:	20 6e       	ori	r18, 0xE0	; 224
     534:	3f 6f       	ori	r19, 0xFF	; 255
     536:	2f 5f       	subi	r18, 0xFF	; 255
     538:	3f 4f       	sbci	r19, 0xFF	; 255
     53a:	fc 01       	movw	r30, r24
     53c:	20 a3       	std	Z+32, r18	; 0x20
		buffer->no_in_buffer++;
     53e:	4f 5f       	subi	r20, 0xFF	; 255
     540:	42 a3       	std	Z+34, r20	; 0x22
		return BUFFER_OK;
     542:	80 e0       	ldi	r24, 0x00	; 0
     544:	08 95       	ret
	}
	return BUFFER_FULL;
     546:	82 e0       	ldi	r24, 0x02	; 2
}
     548:	08 95       	ret

0000054a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     54a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     54c:	03 96       	adiw	r24, 0x03	; 3
     54e:	92 83       	std	Z+2, r25	; 0x02
     550:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     552:	2f ef       	ldi	r18, 0xFF	; 255
     554:	3f ef       	ldi	r19, 0xFF	; 255
     556:	34 83       	std	Z+4, r19	; 0x04
     558:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     55a:	96 83       	std	Z+6, r25	; 0x06
     55c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     55e:	90 87       	std	Z+8, r25	; 0x08
     560:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     562:	10 82       	st	Z, r1
     564:	08 95       	ret

00000566 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     566:	fc 01       	movw	r30, r24
     568:	11 86       	std	Z+9, r1	; 0x09
     56a:	10 86       	std	Z+8, r1	; 0x08
     56c:	08 95       	ret

0000056e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     56e:	cf 93       	push	r28
     570:	df 93       	push	r29
     572:	9c 01       	movw	r18, r24
     574:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     576:	dc 01       	movw	r26, r24
     578:	11 96       	adiw	r26, 0x01	; 1
     57a:	cd 91       	ld	r28, X+
     57c:	dc 91       	ld	r29, X
     57e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     580:	d3 83       	std	Z+3, r29	; 0x03
     582:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     584:	8c 81       	ldd	r24, Y+4	; 0x04
     586:	9d 81       	ldd	r25, Y+5	; 0x05
     588:	95 83       	std	Z+5, r25	; 0x05
     58a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     58c:	8c 81       	ldd	r24, Y+4	; 0x04
     58e:	9d 81       	ldd	r25, Y+5	; 0x05
     590:	dc 01       	movw	r26, r24
     592:	13 96       	adiw	r26, 0x03	; 3
     594:	7c 93       	st	X, r23
     596:	6e 93       	st	-X, r22
     598:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     59a:	7d 83       	std	Y+5, r23	; 0x05
     59c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     59e:	31 87       	std	Z+9, r19	; 0x09
     5a0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     5a2:	f9 01       	movw	r30, r18
     5a4:	80 81       	ld	r24, Z
     5a6:	8f 5f       	subi	r24, 0xFF	; 255
     5a8:	80 83       	st	Z, r24
}
     5aa:	df 91       	pop	r29
     5ac:	cf 91       	pop	r28
     5ae:	08 95       	ret

000005b0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5b0:	cf 93       	push	r28
     5b2:	df 93       	push	r29
     5b4:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     5b6:	48 81       	ld	r20, Y
     5b8:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     5ba:	4f 3f       	cpi	r20, 0xFF	; 255
     5bc:	2f ef       	ldi	r18, 0xFF	; 255
     5be:	52 07       	cpc	r21, r18
     5c0:	21 f4       	brne	.+8      	; 0x5ca <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     5c2:	fc 01       	movw	r30, r24
     5c4:	a7 81       	ldd	r26, Z+7	; 0x07
     5c6:	b0 85       	ldd	r27, Z+8	; 0x08
     5c8:	0d c0       	rjmp	.+26     	; 0x5e4 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ca:	dc 01       	movw	r26, r24
     5cc:	13 96       	adiw	r26, 0x03	; 3
     5ce:	01 c0       	rjmp	.+2      	; 0x5d2 <vListInsert+0x22>
     5d0:	df 01       	movw	r26, r30
     5d2:	12 96       	adiw	r26, 0x02	; 2
     5d4:	ed 91       	ld	r30, X+
     5d6:	fc 91       	ld	r31, X
     5d8:	13 97       	sbiw	r26, 0x03	; 3
     5da:	20 81       	ld	r18, Z
     5dc:	31 81       	ldd	r19, Z+1	; 0x01
     5de:	42 17       	cp	r20, r18
     5e0:	53 07       	cpc	r21, r19
     5e2:	b0 f7       	brcc	.-20     	; 0x5d0 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     5e4:	12 96       	adiw	r26, 0x02	; 2
     5e6:	ed 91       	ld	r30, X+
     5e8:	fc 91       	ld	r31, X
     5ea:	13 97       	sbiw	r26, 0x03	; 3
     5ec:	fb 83       	std	Y+3, r31	; 0x03
     5ee:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     5f0:	d5 83       	std	Z+5, r29	; 0x05
     5f2:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     5f4:	bd 83       	std	Y+5, r27	; 0x05
     5f6:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     5f8:	13 96       	adiw	r26, 0x03	; 3
     5fa:	dc 93       	st	X, r29
     5fc:	ce 93       	st	-X, r28
     5fe:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     600:	99 87       	std	Y+9, r25	; 0x09
     602:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     604:	fc 01       	movw	r30, r24
     606:	20 81       	ld	r18, Z
     608:	2f 5f       	subi	r18, 0xFF	; 255
     60a:	20 83       	st	Z, r18
}
     60c:	df 91       	pop	r29
     60e:	cf 91       	pop	r28
     610:	08 95       	ret

00000612 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     612:	cf 93       	push	r28
     614:	df 93       	push	r29
     616:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     618:	a0 85       	ldd	r26, Z+8	; 0x08
     61a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     61c:	c2 81       	ldd	r28, Z+2	; 0x02
     61e:	d3 81       	ldd	r29, Z+3	; 0x03
     620:	84 81       	ldd	r24, Z+4	; 0x04
     622:	95 81       	ldd	r25, Z+5	; 0x05
     624:	9d 83       	std	Y+5, r25	; 0x05
     626:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     628:	c4 81       	ldd	r28, Z+4	; 0x04
     62a:	d5 81       	ldd	r29, Z+5	; 0x05
     62c:	82 81       	ldd	r24, Z+2	; 0x02
     62e:	93 81       	ldd	r25, Z+3	; 0x03
     630:	9b 83       	std	Y+3, r25	; 0x03
     632:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     634:	11 96       	adiw	r26, 0x01	; 1
     636:	8d 91       	ld	r24, X+
     638:	9c 91       	ld	r25, X
     63a:	12 97       	sbiw	r26, 0x02	; 2
     63c:	e8 17       	cp	r30, r24
     63e:	f9 07       	cpc	r31, r25
     640:	31 f4       	brne	.+12     	; 0x64e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     642:	84 81       	ldd	r24, Z+4	; 0x04
     644:	95 81       	ldd	r25, Z+5	; 0x05
     646:	12 96       	adiw	r26, 0x02	; 2
     648:	9c 93       	st	X, r25
     64a:	8e 93       	st	-X, r24
     64c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     64e:	11 86       	std	Z+9, r1	; 0x09
     650:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     652:	8c 91       	ld	r24, X
     654:	81 50       	subi	r24, 0x01	; 1
     656:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     658:	df 91       	pop	r29
     65a:	cf 91       	pop	r28
     65c:	08 95       	ret

0000065e <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     65e:	31 e1       	ldi	r19, 0x11	; 17
     660:	fc 01       	movw	r30, r24
     662:	30 83       	st	Z, r19
     664:	31 97       	sbiw	r30, 0x01	; 1
     666:	22 e2       	ldi	r18, 0x22	; 34
     668:	20 83       	st	Z, r18
     66a:	31 97       	sbiw	r30, 0x01	; 1
     66c:	a3 e3       	ldi	r26, 0x33	; 51
     66e:	a0 83       	st	Z, r26
     670:	31 97       	sbiw	r30, 0x01	; 1
     672:	60 83       	st	Z, r22
     674:	31 97       	sbiw	r30, 0x01	; 1
     676:	70 83       	st	Z, r23
     678:	31 97       	sbiw	r30, 0x01	; 1
     67a:	10 82       	st	Z, r1
     67c:	31 97       	sbiw	r30, 0x01	; 1
     67e:	60 e8       	ldi	r22, 0x80	; 128
     680:	60 83       	st	Z, r22
     682:	31 97       	sbiw	r30, 0x01	; 1
     684:	10 82       	st	Z, r1
     686:	31 97       	sbiw	r30, 0x01	; 1
     688:	62 e0       	ldi	r22, 0x02	; 2
     68a:	60 83       	st	Z, r22
     68c:	31 97       	sbiw	r30, 0x01	; 1
     68e:	63 e0       	ldi	r22, 0x03	; 3
     690:	60 83       	st	Z, r22
     692:	31 97       	sbiw	r30, 0x01	; 1
     694:	64 e0       	ldi	r22, 0x04	; 4
     696:	60 83       	st	Z, r22
     698:	31 97       	sbiw	r30, 0x01	; 1
     69a:	65 e0       	ldi	r22, 0x05	; 5
     69c:	60 83       	st	Z, r22
     69e:	31 97       	sbiw	r30, 0x01	; 1
     6a0:	66 e0       	ldi	r22, 0x06	; 6
     6a2:	60 83       	st	Z, r22
     6a4:	31 97       	sbiw	r30, 0x01	; 1
     6a6:	67 e0       	ldi	r22, 0x07	; 7
     6a8:	60 83       	st	Z, r22
     6aa:	31 97       	sbiw	r30, 0x01	; 1
     6ac:	68 e0       	ldi	r22, 0x08	; 8
     6ae:	60 83       	st	Z, r22
     6b0:	31 97       	sbiw	r30, 0x01	; 1
     6b2:	69 e0       	ldi	r22, 0x09	; 9
     6b4:	60 83       	st	Z, r22
     6b6:	31 97       	sbiw	r30, 0x01	; 1
     6b8:	60 e1       	ldi	r22, 0x10	; 16
     6ba:	60 83       	st	Z, r22
     6bc:	31 97       	sbiw	r30, 0x01	; 1
     6be:	30 83       	st	Z, r19
     6c0:	31 97       	sbiw	r30, 0x01	; 1
     6c2:	32 e1       	ldi	r19, 0x12	; 18
     6c4:	30 83       	st	Z, r19
     6c6:	31 97       	sbiw	r30, 0x01	; 1
     6c8:	33 e1       	ldi	r19, 0x13	; 19
     6ca:	30 83       	st	Z, r19
     6cc:	31 97       	sbiw	r30, 0x01	; 1
     6ce:	34 e1       	ldi	r19, 0x14	; 20
     6d0:	30 83       	st	Z, r19
     6d2:	31 97       	sbiw	r30, 0x01	; 1
     6d4:	35 e1       	ldi	r19, 0x15	; 21
     6d6:	30 83       	st	Z, r19
     6d8:	31 97       	sbiw	r30, 0x01	; 1
     6da:	36 e1       	ldi	r19, 0x16	; 22
     6dc:	30 83       	st	Z, r19
     6de:	31 97       	sbiw	r30, 0x01	; 1
     6e0:	37 e1       	ldi	r19, 0x17	; 23
     6e2:	30 83       	st	Z, r19
     6e4:	31 97       	sbiw	r30, 0x01	; 1
     6e6:	38 e1       	ldi	r19, 0x18	; 24
     6e8:	30 83       	st	Z, r19
     6ea:	31 97       	sbiw	r30, 0x01	; 1
     6ec:	39 e1       	ldi	r19, 0x19	; 25
     6ee:	30 83       	st	Z, r19
     6f0:	31 97       	sbiw	r30, 0x01	; 1
     6f2:	30 e2       	ldi	r19, 0x20	; 32
     6f4:	30 83       	st	Z, r19
     6f6:	31 97       	sbiw	r30, 0x01	; 1
     6f8:	31 e2       	ldi	r19, 0x21	; 33
     6fa:	30 83       	st	Z, r19
     6fc:	31 97       	sbiw	r30, 0x01	; 1
     6fe:	20 83       	st	Z, r18
     700:	31 97       	sbiw	r30, 0x01	; 1
     702:	23 e2       	ldi	r18, 0x23	; 35
     704:	20 83       	st	Z, r18
     706:	31 97       	sbiw	r30, 0x01	; 1
     708:	40 83       	st	Z, r20
     70a:	31 97       	sbiw	r30, 0x01	; 1
     70c:	50 83       	st	Z, r21
     70e:	31 97       	sbiw	r30, 0x01	; 1
     710:	26 e2       	ldi	r18, 0x26	; 38
     712:	20 83       	st	Z, r18
     714:	31 97       	sbiw	r30, 0x01	; 1
     716:	27 e2       	ldi	r18, 0x27	; 39
     718:	20 83       	st	Z, r18
     71a:	31 97       	sbiw	r30, 0x01	; 1
     71c:	28 e2       	ldi	r18, 0x28	; 40
     71e:	20 83       	st	Z, r18
     720:	31 97       	sbiw	r30, 0x01	; 1
     722:	29 e2       	ldi	r18, 0x29	; 41
     724:	20 83       	st	Z, r18
     726:	31 97       	sbiw	r30, 0x01	; 1
     728:	20 e3       	ldi	r18, 0x30	; 48
     72a:	20 83       	st	Z, r18
     72c:	31 97       	sbiw	r30, 0x01	; 1
     72e:	21 e3       	ldi	r18, 0x31	; 49
     730:	20 83       	st	Z, r18
     732:	86 97       	sbiw	r24, 0x26	; 38
     734:	08 95       	ret

00000736 <xPortStartScheduler>:
     736:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     73a:	85 ee       	ldi	r24, 0xE5	; 229
     73c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     740:	8b e0       	ldi	r24, 0x0B	; 11
     742:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     746:	ef e6       	ldi	r30, 0x6F	; 111
     748:	f0 e0       	ldi	r31, 0x00	; 0
     74a:	80 81       	ld	r24, Z
     74c:	82 60       	ori	r24, 0x02	; 2
     74e:	80 83       	st	Z, r24
     750:	a0 91 65 06 	lds	r26, 0x0665	; 0x800665 <pxCurrentTCB>
     754:	b0 91 66 06 	lds	r27, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
     758:	cd 91       	ld	r28, X+
     75a:	cd bf       	out	0x3d, r28	; 61
     75c:	dd 91       	ld	r29, X+
     75e:	de bf       	out	0x3e, r29	; 62
     760:	ff 91       	pop	r31
     762:	ef 91       	pop	r30
     764:	df 91       	pop	r29
     766:	cf 91       	pop	r28
     768:	bf 91       	pop	r27
     76a:	af 91       	pop	r26
     76c:	9f 91       	pop	r25
     76e:	8f 91       	pop	r24
     770:	7f 91       	pop	r23
     772:	6f 91       	pop	r22
     774:	5f 91       	pop	r21
     776:	4f 91       	pop	r20
     778:	3f 91       	pop	r19
     77a:	2f 91       	pop	r18
     77c:	1f 91       	pop	r17
     77e:	0f 91       	pop	r16
     780:	ff 90       	pop	r15
     782:	ef 90       	pop	r14
     784:	df 90       	pop	r13
     786:	cf 90       	pop	r12
     788:	bf 90       	pop	r11
     78a:	af 90       	pop	r10
     78c:	9f 90       	pop	r9
     78e:	8f 90       	pop	r8
     790:	7f 90       	pop	r7
     792:	6f 90       	pop	r6
     794:	5f 90       	pop	r5
     796:	4f 90       	pop	r4
     798:	3f 90       	pop	r3
     79a:	2f 90       	pop	r2
     79c:	1f 90       	pop	r1
     79e:	0f 90       	pop	r0
     7a0:	0f be       	out	0x3f, r0	; 63
     7a2:	0f 90       	pop	r0
     7a4:	08 95       	ret
     7a6:	81 e0       	ldi	r24, 0x01	; 1
     7a8:	08 95       	ret

000007aa <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     7aa:	0f 92       	push	r0
     7ac:	0f b6       	in	r0, 0x3f	; 63
     7ae:	f8 94       	cli
     7b0:	0f 92       	push	r0
     7b2:	1f 92       	push	r1
     7b4:	11 24       	eor	r1, r1
     7b6:	2f 92       	push	r2
     7b8:	3f 92       	push	r3
     7ba:	4f 92       	push	r4
     7bc:	5f 92       	push	r5
     7be:	6f 92       	push	r6
     7c0:	7f 92       	push	r7
     7c2:	8f 92       	push	r8
     7c4:	9f 92       	push	r9
     7c6:	af 92       	push	r10
     7c8:	bf 92       	push	r11
     7ca:	cf 92       	push	r12
     7cc:	df 92       	push	r13
     7ce:	ef 92       	push	r14
     7d0:	ff 92       	push	r15
     7d2:	0f 93       	push	r16
     7d4:	1f 93       	push	r17
     7d6:	2f 93       	push	r18
     7d8:	3f 93       	push	r19
     7da:	4f 93       	push	r20
     7dc:	5f 93       	push	r21
     7de:	6f 93       	push	r22
     7e0:	7f 93       	push	r23
     7e2:	8f 93       	push	r24
     7e4:	9f 93       	push	r25
     7e6:	af 93       	push	r26
     7e8:	bf 93       	push	r27
     7ea:	cf 93       	push	r28
     7ec:	df 93       	push	r29
     7ee:	ef 93       	push	r30
     7f0:	ff 93       	push	r31
     7f2:	a0 91 65 06 	lds	r26, 0x0665	; 0x800665 <pxCurrentTCB>
     7f6:	b0 91 66 06 	lds	r27, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
     7fa:	0d b6       	in	r0, 0x3d	; 61
     7fc:	0d 92       	st	X+, r0
     7fe:	0e b6       	in	r0, 0x3e	; 62
     800:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     802:	0e 94 c5 0c 	call	0x198a	; 0x198a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     806:	a0 91 65 06 	lds	r26, 0x0665	; 0x800665 <pxCurrentTCB>
     80a:	b0 91 66 06 	lds	r27, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
     80e:	cd 91       	ld	r28, X+
     810:	cd bf       	out	0x3d, r28	; 61
     812:	dd 91       	ld	r29, X+
     814:	de bf       	out	0x3e, r29	; 62
     816:	ff 91       	pop	r31
     818:	ef 91       	pop	r30
     81a:	df 91       	pop	r29
     81c:	cf 91       	pop	r28
     81e:	bf 91       	pop	r27
     820:	af 91       	pop	r26
     822:	9f 91       	pop	r25
     824:	8f 91       	pop	r24
     826:	7f 91       	pop	r23
     828:	6f 91       	pop	r22
     82a:	5f 91       	pop	r21
     82c:	4f 91       	pop	r20
     82e:	3f 91       	pop	r19
     830:	2f 91       	pop	r18
     832:	1f 91       	pop	r17
     834:	0f 91       	pop	r16
     836:	ff 90       	pop	r15
     838:	ef 90       	pop	r14
     83a:	df 90       	pop	r13
     83c:	cf 90       	pop	r12
     83e:	bf 90       	pop	r11
     840:	af 90       	pop	r10
     842:	9f 90       	pop	r9
     844:	8f 90       	pop	r8
     846:	7f 90       	pop	r7
     848:	6f 90       	pop	r6
     84a:	5f 90       	pop	r5
     84c:	4f 90       	pop	r4
     84e:	3f 90       	pop	r3
     850:	2f 90       	pop	r2
     852:	1f 90       	pop	r1
     854:	0f 90       	pop	r0
     856:	0f be       	out	0x3f, r0	; 63
     858:	0f 90       	pop	r0

	asm volatile ( "ret" );
     85a:	08 95       	ret

0000085c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     85c:	0f 92       	push	r0
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	0f 92       	push	r0
     864:	1f 92       	push	r1
     866:	11 24       	eor	r1, r1
     868:	2f 92       	push	r2
     86a:	3f 92       	push	r3
     86c:	4f 92       	push	r4
     86e:	5f 92       	push	r5
     870:	6f 92       	push	r6
     872:	7f 92       	push	r7
     874:	8f 92       	push	r8
     876:	9f 92       	push	r9
     878:	af 92       	push	r10
     87a:	bf 92       	push	r11
     87c:	cf 92       	push	r12
     87e:	df 92       	push	r13
     880:	ef 92       	push	r14
     882:	ff 92       	push	r15
     884:	0f 93       	push	r16
     886:	1f 93       	push	r17
     888:	2f 93       	push	r18
     88a:	3f 93       	push	r19
     88c:	4f 93       	push	r20
     88e:	5f 93       	push	r21
     890:	6f 93       	push	r22
     892:	7f 93       	push	r23
     894:	8f 93       	push	r24
     896:	9f 93       	push	r25
     898:	af 93       	push	r26
     89a:	bf 93       	push	r27
     89c:	cf 93       	push	r28
     89e:	df 93       	push	r29
     8a0:	ef 93       	push	r30
     8a2:	ff 93       	push	r31
     8a4:	a0 91 65 06 	lds	r26, 0x0665	; 0x800665 <pxCurrentTCB>
     8a8:	b0 91 66 06 	lds	r27, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
     8ac:	0d b6       	in	r0, 0x3d	; 61
     8ae:	0d 92       	st	X+, r0
     8b0:	0e b6       	in	r0, 0x3e	; 62
     8b2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     8b4:	0e 94 29 0b 	call	0x1652	; 0x1652 <xTaskIncrementTick>
     8b8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     8ba:	0e 94 c5 0c 	call	0x198a	; 0x198a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     8be:	a0 91 65 06 	lds	r26, 0x0665	; 0x800665 <pxCurrentTCB>
     8c2:	b0 91 66 06 	lds	r27, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
     8c6:	cd 91       	ld	r28, X+
     8c8:	cd bf       	out	0x3d, r28	; 61
     8ca:	dd 91       	ld	r29, X+
     8cc:	de bf       	out	0x3e, r29	; 62
     8ce:	ff 91       	pop	r31
     8d0:	ef 91       	pop	r30
     8d2:	df 91       	pop	r29
     8d4:	cf 91       	pop	r28
     8d6:	bf 91       	pop	r27
     8d8:	af 91       	pop	r26
     8da:	9f 91       	pop	r25
     8dc:	8f 91       	pop	r24
     8de:	7f 91       	pop	r23
     8e0:	6f 91       	pop	r22
     8e2:	5f 91       	pop	r21
     8e4:	4f 91       	pop	r20
     8e6:	3f 91       	pop	r19
     8e8:	2f 91       	pop	r18
     8ea:	1f 91       	pop	r17
     8ec:	0f 91       	pop	r16
     8ee:	ff 90       	pop	r15
     8f0:	ef 90       	pop	r14
     8f2:	df 90       	pop	r13
     8f4:	cf 90       	pop	r12
     8f6:	bf 90       	pop	r11
     8f8:	af 90       	pop	r10
     8fa:	9f 90       	pop	r9
     8fc:	8f 90       	pop	r8
     8fe:	7f 90       	pop	r7
     900:	6f 90       	pop	r6
     902:	5f 90       	pop	r5
     904:	4f 90       	pop	r4
     906:	3f 90       	pop	r3
     908:	2f 90       	pop	r2
     90a:	1f 90       	pop	r1
     90c:	0f 90       	pop	r0
     90e:	0f be       	out	0x3f, r0	; 63
     910:	0f 90       	pop	r0

	asm volatile ( "ret" );
     912:	08 95       	ret

00000914 <__vector_13>:
	 */
// 	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
// 	void SIG_OUTPUT_COMPARE1A( void )
ISR(TIMER1_COMPA_vect, ISR_NAKED)  // IHA
	{
		vPortYieldFromTick();
     914:	0e 94 2e 04 	call	0x85c	; 0x85c <vPortYieldFromTick>
		asm volatile ( "reti" );
     918:	18 95       	reti

0000091a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     91a:	cf 93       	push	r28
     91c:	df 93       	push	r29
     91e:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     920:	0e 94 23 0b 	call	0x1646	; 0x1646 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     924:	80 91 1a 02 	lds	r24, 0x021A	; 0x80021a <pucAlignedHeap.2084>
     928:	90 91 1b 02 	lds	r25, 0x021B	; 0x80021b <pucAlignedHeap.2084+0x1>
     92c:	89 2b       	or	r24, r25
     92e:	31 f4       	brne	.+12     	; 0x93c <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     930:	8f e1       	ldi	r24, 0x1F	; 31
     932:	92 e0       	ldi	r25, 0x02	; 2
     934:	90 93 1b 02 	sts	0x021B, r25	; 0x80021b <pucAlignedHeap.2084+0x1>
     938:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <pucAlignedHeap.2084>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     93c:	20 91 1c 02 	lds	r18, 0x021C	; 0x80021c <xNextFreeByte>
     940:	30 91 1d 02 	lds	r19, 0x021D	; 0x80021d <xNextFreeByte+0x1>
     944:	c9 01       	movw	r24, r18
     946:	8c 0f       	add	r24, r28
     948:	9d 1f       	adc	r25, r29
     94a:	87 3e       	cpi	r24, 0xE7	; 231
     94c:	43 e0       	ldi	r20, 0x03	; 3
     94e:	94 07       	cpc	r25, r20
     950:	70 f4       	brcc	.+28     	; 0x96e <pvPortMalloc+0x54>
     952:	28 17       	cp	r18, r24
     954:	39 07       	cpc	r19, r25
     956:	70 f4       	brcc	.+28     	; 0x974 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     958:	c0 91 1a 02 	lds	r28, 0x021A	; 0x80021a <pucAlignedHeap.2084>
     95c:	d0 91 1b 02 	lds	r29, 0x021B	; 0x80021b <pucAlignedHeap.2084+0x1>
     960:	c2 0f       	add	r28, r18
     962:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     964:	90 93 1d 02 	sts	0x021D, r25	; 0x80021d <xNextFreeByte+0x1>
     968:	80 93 1c 02 	sts	0x021C, r24	; 0x80021c <xNextFreeByte>
     96c:	05 c0       	rjmp	.+10     	; 0x978 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     96e:	c0 e0       	ldi	r28, 0x00	; 0
     970:	d0 e0       	ldi	r29, 0x00	; 0
     972:	02 c0       	rjmp	.+4      	; 0x978 <pvPortMalloc+0x5e>
     974:	c0 e0       	ldi	r28, 0x00	; 0
     976:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     978:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     97c:	ce 01       	movw	r24, r28
     97e:	df 91       	pop	r29
     980:	cf 91       	pop	r28
     982:	08 95       	ret

00000984 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     984:	08 95       	ret

00000986 <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
     986:	4f 92       	push	r4
     988:	5f 92       	push	r5
     98a:	6f 92       	push	r6
     98c:	7f 92       	push	r7
     98e:	8f 92       	push	r8
     990:	9f 92       	push	r9
     992:	af 92       	push	r10
     994:	bf 92       	push	r11
     996:	cf 92       	push	r12
     998:	df 92       	push	r13
     99a:	ff 92       	push	r15
     99c:	0f 93       	push	r16
     99e:	1f 93       	push	r17
     9a0:	cf 93       	push	r28
     9a2:	df 93       	push	r29
     9a4:	cd b7       	in	r28, 0x3d	; 61
     9a6:	de b7       	in	r29, 0x3e	; 62
     9a8:	f8 2e       	mov	r15, r24
     9aa:	2a 01       	movw	r4, r20
     9ac:	3b 01       	movw	r6, r22
     9ae:	88 e0       	ldi	r24, 0x08	; 8
     9b0:	90 e0       	ldi	r25, 0x00	; 0
     9b2:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <malloc>
     9b6:	8c 01       	movw	r16, r24
     9b8:	8f 2d       	mov	r24, r15
     9ba:	90 e0       	ldi	r25, 0x00	; 0
     9bc:	88 0f       	add	r24, r24
     9be:	99 1f       	adc	r25, r25
     9c0:	fc 01       	movw	r30, r24
     9c2:	ea 5f       	subi	r30, 0xFA	; 250
     9c4:	f9 4f       	sbci	r31, 0xF9	; 249
     9c6:	11 83       	std	Z+1, r17	; 0x01
     9c8:	00 83       	st	Z, r16
     9ca:	fc 01       	movw	r30, r24
     9cc:	ea 5f       	subi	r30, 0xFA	; 250
     9ce:	fe 4f       	sbci	r31, 0xFE	; 254
     9d0:	80 81       	ld	r24, Z
     9d2:	91 81       	ldd	r25, Z+1	; 0x01
     9d4:	d8 01       	movw	r26, r16
     9d6:	11 96       	adiw	r26, 0x01	; 1
     9d8:	9c 93       	st	X, r25
     9da:	8e 93       	st	-X, r24
     9dc:	13 96       	adiw	r26, 0x03	; 3
     9de:	bc 92       	st	X, r11
     9e0:	ae 92       	st	-X, r10
     9e2:	12 97       	sbiw	r26, 0x02	; 2
     9e4:	15 96       	adiw	r26, 0x05	; 5
     9e6:	dc 92       	st	X, r13
     9e8:	ce 92       	st	-X, r12
     9ea:	14 97       	sbiw	r26, 0x04	; 4
     9ec:	17 96       	adiw	r26, 0x07	; 7
     9ee:	9c 92       	st	X, r9
     9f0:	8e 92       	st	-X, r8
     9f2:	16 97       	sbiw	r26, 0x06	; 6
     9f4:	ff b6       	in	r15, 0x3f	; 63
     9f6:	f8 94       	cli
     9f8:	ed 91       	ld	r30, X+
     9fa:	fc 91       	ld	r31, X
     9fc:	11 97       	sbiw	r26, 0x01	; 1
     9fe:	36 97       	sbiw	r30, 0x06	; 6
     a00:	80 81       	ld	r24, Z
     a02:	82 60       	ori	r24, 0x02	; 2
     a04:	80 83       	st	Z, r24
     a06:	cd 90       	ld	r12, X+
     a08:	dc 90       	ld	r13, X
     a0a:	d3 01       	movw	r26, r6
     a0c:	c2 01       	movw	r24, r4
     a0e:	88 0f       	add	r24, r24
     a10:	99 1f       	adc	r25, r25
     a12:	aa 1f       	adc	r26, r26
     a14:	bb 1f       	adc	r27, r27
     a16:	88 0f       	add	r24, r24
     a18:	99 1f       	adc	r25, r25
     a1a:	aa 1f       	adc	r26, r26
     a1c:	bb 1f       	adc	r27, r27
     a1e:	9c 01       	movw	r18, r24
     a20:	ad 01       	movw	r20, r26
     a22:	22 0f       	add	r18, r18
     a24:	33 1f       	adc	r19, r19
     a26:	44 1f       	adc	r20, r20
     a28:	55 1f       	adc	r21, r21
     a2a:	60 e0       	ldi	r22, 0x00	; 0
     a2c:	70 e0       	ldi	r23, 0x00	; 0
     a2e:	81 ee       	ldi	r24, 0xE1	; 225
     a30:	90 e0       	ldi	r25, 0x00	; 0
     a32:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <__udivmodsi4>
     a36:	21 50       	subi	r18, 0x01	; 1
     a38:	f6 01       	movw	r30, r12
     a3a:	32 97       	sbiw	r30, 0x02	; 2
     a3c:	20 83       	st	Z, r18
     a3e:	d8 01       	movw	r26, r16
     a40:	ed 91       	ld	r30, X+
     a42:	fc 91       	ld	r31, X
     a44:	11 97       	sbiw	r26, 0x01	; 1
     a46:	35 97       	sbiw	r30, 0x05	; 5
     a48:	88 e9       	ldi	r24, 0x98	; 152
     a4a:	80 83       	st	Z, r24
     a4c:	ed 91       	ld	r30, X+
     a4e:	fc 91       	ld	r31, X
     a50:	34 97       	sbiw	r30, 0x04	; 4
     a52:	86 e0       	ldi	r24, 0x06	; 6
     a54:	80 83       	st	Z, r24
     a56:	ff be       	out	0x3f, r15	; 63
     a58:	c8 01       	movw	r24, r16
     a5a:	df 91       	pop	r29
     a5c:	cf 91       	pop	r28
     a5e:	1f 91       	pop	r17
     a60:	0f 91       	pop	r16
     a62:	ff 90       	pop	r15
     a64:	df 90       	pop	r13
     a66:	cf 90       	pop	r12
     a68:	bf 90       	pop	r11
     a6a:	af 90       	pop	r10
     a6c:	9f 90       	pop	r9
     a6e:	8f 90       	pop	r8
     a70:	7f 90       	pop	r7
     a72:	6f 90       	pop	r6
     a74:	5f 90       	pop	r5
     a76:	4f 90       	pop	r4
     a78:	08 95       	ret

00000a7a <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
     a7a:	ef 92       	push	r14
     a7c:	ff 92       	push	r15
     a7e:	0f 93       	push	r16
     a80:	1f 93       	push	r17
     a82:	cf 93       	push	r28
     a84:	df 93       	push	r29
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     a86:	fc 01       	movw	r30, r24
     a88:	a2 81       	ldd	r26, Z+2	; 0x02
     a8a:	b3 81       	ldd	r27, Z+3	; 0x03
     a8c:	10 97       	sbiw	r26, 0x00	; 0
     a8e:	79 f0       	breq	.+30     	; 0xaae <serial_send_bytes+0x34>
     a90:	e4 2f       	mov	r30, r20
     a92:	f0 e0       	ldi	r31, 0x00	; 0
     a94:	92 96       	adiw	r26, 0x22	; 34
     a96:	5c 91       	ld	r21, X
     a98:	20 e2       	ldi	r18, 0x20	; 32
     a9a:	30 e0       	ldi	r19, 0x00	; 0
     a9c:	25 1b       	sub	r18, r21
     a9e:	31 09       	sbc	r19, r1
     aa0:	2e 17       	cp	r18, r30
     aa2:	3f 07       	cpc	r19, r31
     aa4:	1c f1       	brlt	.+70     	; 0xaec <serial_send_bytes+0x72>
     aa6:	7c 01       	movw	r14, r24
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     aa8:	41 11       	cpse	r20, r1
     aaa:	04 c0       	rjmp	.+8      	; 0xab4 <serial_send_bytes+0x3a>
     aac:	16 c0       	rjmp	.+44     	; 0xada <serial_send_bytes+0x60>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     aae:	42 30       	cpi	r20, 0x02	; 2
     ab0:	f8 f4       	brcc	.+62     	; 0xaf0 <serial_send_bytes+0x76>
     ab2:	f9 cf       	rjmp	.-14     	; 0xaa6 <serial_send_bytes+0x2c>
     ab4:	eb 01       	movw	r28, r22
     ab6:	41 50       	subi	r20, 0x01	; 1
     ab8:	04 2f       	mov	r16, r20
     aba:	10 e0       	ldi	r17, 0x00	; 0
     abc:	0f 5f       	subi	r16, 0xFF	; 255
     abe:	1f 4f       	sbci	r17, 0xFF	; 255
     ac0:	06 0f       	add	r16, r22
     ac2:	17 1f       	adc	r17, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
     ac4:	69 91       	ld	r22, Y+
     ac6:	d7 01       	movw	r26, r14
     ac8:	12 96       	adiw	r26, 0x02	; 2
     aca:	8d 91       	ld	r24, X+
     acc:	9c 91       	ld	r25, X
     ace:	13 97       	sbiw	r26, 0x03	; 3
     ad0:	0e 94 88 02 	call	0x510	; 0x510 <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     ad4:	c0 17       	cp	r28, r16
     ad6:	d1 07       	cpc	r29, r17
     ad8:	a9 f7       	brne	.-22     	; 0xac4 <serial_send_bytes+0x4a>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
     ada:	d7 01       	movw	r26, r14
     adc:	ed 91       	ld	r30, X+
     ade:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
     ae0:	35 97       	sbiw	r30, 0x05	; 5
     ae2:	80 81       	ld	r24, Z
     ae4:	80 62       	ori	r24, 0x20	; 32
     ae6:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
     ae8:	80 e0       	ldi	r24, 0x00	; 0
     aea:	03 c0       	rjmp	.+6      	; 0xaf2 <serial_send_bytes+0x78>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
     aec:	82 e0       	ldi	r24, 0x02	; 2
     aee:	01 c0       	rjmp	.+2      	; 0xaf2 <serial_send_bytes+0x78>
     af0:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
     af2:	df 91       	pop	r29
     af4:	cf 91       	pop	r28
     af6:	1f 91       	pop	r17
     af8:	0f 91       	pop	r16
     afa:	ff 90       	pop	r15
     afc:	ef 90       	pop	r14
     afe:	08 95       	ret

00000b00 <__vector_20>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
     b00:	1f 92       	push	r1
     b02:	0f 92       	push	r0
     b04:	0f b6       	in	r0, 0x3f	; 63
     b06:	0f 92       	push	r0
     b08:	11 24       	eor	r1, r1
     b0a:	2f 93       	push	r18
     b0c:	3f 93       	push	r19
     b0e:	4f 93       	push	r20
     b10:	5f 93       	push	r21
     b12:	6f 93       	push	r22
     b14:	7f 93       	push	r23
     b16:	8f 93       	push	r24
     b18:	9f 93       	push	r25
     b1a:	af 93       	push	r26
     b1c:	bf 93       	push	r27
     b1e:	cf 93       	push	r28
     b20:	ef 93       	push	r30
     b22:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     b24:	e0 91 06 06 	lds	r30, 0x0606	; 0x800606 <_ser_handle>
     b28:	f0 91 07 06 	lds	r31, 0x0607	; 0x800607 <_ser_handle+0x1>
     b2c:	30 97       	sbiw	r30, 0x00	; 0
     b2e:	a1 f0       	breq	.+40     	; 0xb58 <__vector_20+0x58>
		item = UDR0;
     b30:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
     b34:	6c 2f       	mov	r22, r28
     b36:	84 81       	ldd	r24, Z+4	; 0x04
     b38:	95 81       	ldd	r25, Z+5	; 0x05
     b3a:	0e 94 88 02 	call	0x510	; 0x510 <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
     b3e:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <_ser_handle>
     b42:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <_ser_handle+0x1>
     b46:	dc 01       	movw	r26, r24
     b48:	16 96       	adiw	r26, 0x06	; 6
     b4a:	ed 91       	ld	r30, X+
     b4c:	fc 91       	ld	r31, X
     b4e:	17 97       	sbiw	r26, 0x07	; 7
     b50:	30 97       	sbiw	r30, 0x00	; 0
     b52:	11 f0       	breq	.+4      	; 0xb58 <__vector_20+0x58>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
     b54:	6c 2f       	mov	r22, r28
     b56:	09 95       	icall
		}
	}
}
     b58:	ff 91       	pop	r31
     b5a:	ef 91       	pop	r30
     b5c:	cf 91       	pop	r28
     b5e:	bf 91       	pop	r27
     b60:	af 91       	pop	r26
     b62:	9f 91       	pop	r25
     b64:	8f 91       	pop	r24
     b66:	7f 91       	pop	r23
     b68:	6f 91       	pop	r22
     b6a:	5f 91       	pop	r21
     b6c:	4f 91       	pop	r20
     b6e:	3f 91       	pop	r19
     b70:	2f 91       	pop	r18
     b72:	0f 90       	pop	r0
     b74:	0f be       	out	0x3f, r0	; 63
     b76:	0f 90       	pop	r0
     b78:	1f 90       	pop	r1
     b7a:	18 95       	reti

00000b7c <__vector_21>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
     b7c:	1f 92       	push	r1
     b7e:	0f 92       	push	r0
     b80:	0f b6       	in	r0, 0x3f	; 63
     b82:	0f 92       	push	r0
     b84:	11 24       	eor	r1, r1
     b86:	2f 93       	push	r18
     b88:	3f 93       	push	r19
     b8a:	4f 93       	push	r20
     b8c:	5f 93       	push	r21
     b8e:	6f 93       	push	r22
     b90:	7f 93       	push	r23
     b92:	8f 93       	push	r24
     b94:	9f 93       	push	r25
     b96:	af 93       	push	r26
     b98:	bf 93       	push	r27
     b9a:	ef 93       	push	r30
     b9c:	ff 93       	push	r31
     b9e:	cf 93       	push	r28
     ba0:	df 93       	push	r29
     ba2:	1f 92       	push	r1
     ba4:	cd b7       	in	r28, 0x3d	; 61
     ba6:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     ba8:	e0 91 06 06 	lds	r30, 0x0606	; 0x800606 <_ser_handle>
     bac:	f0 91 07 06 	lds	r31, 0x0607	; 0x800607 <_ser_handle+0x1>
     bb0:	30 97       	sbiw	r30, 0x00	; 0
     bb2:	99 f0       	breq	.+38     	; 0xbda <__vector_21+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
     bb4:	be 01       	movw	r22, r28
     bb6:	6f 5f       	subi	r22, 0xFF	; 255
     bb8:	7f 4f       	sbci	r23, 0xFF	; 255
     bba:	82 81       	ldd	r24, Z+2	; 0x02
     bbc:	93 81       	ldd	r25, Z+3	; 0x03
     bbe:	0e 94 67 02 	call	0x4ce	; 0x4ce <buffer_get_item>
     bc2:	81 11       	cpse	r24, r1
     bc4:	04 c0       	rjmp	.+8      	; 0xbce <__vector_21+0x52>
			UDR0 = item;
     bc6:	89 81       	ldd	r24, Y+1	; 0x01
     bc8:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     bcc:	0b c0       	rjmp	.+22     	; 0xbe4 <__vector_21+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
     bce:	e1 ec       	ldi	r30, 0xC1	; 193
     bd0:	f0 e0       	ldi	r31, 0x00	; 0
     bd2:	80 81       	ld	r24, Z
     bd4:	8f 7d       	andi	r24, 0xDF	; 223
     bd6:	80 83       	st	Z, r24
     bd8:	05 c0       	rjmp	.+10     	; 0xbe4 <__vector_21+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
     bda:	e1 ec       	ldi	r30, 0xC1	; 193
     bdc:	f0 e0       	ldi	r31, 0x00	; 0
     bde:	80 81       	ld	r24, Z
     be0:	8f 7d       	andi	r24, 0xDF	; 223
     be2:	80 83       	st	Z, r24
	}
}
     be4:	0f 90       	pop	r0
     be6:	df 91       	pop	r29
     be8:	cf 91       	pop	r28
     bea:	ff 91       	pop	r31
     bec:	ef 91       	pop	r30
     bee:	bf 91       	pop	r27
     bf0:	af 91       	pop	r26
     bf2:	9f 91       	pop	r25
     bf4:	8f 91       	pop	r24
     bf6:	7f 91       	pop	r23
     bf8:	6f 91       	pop	r22
     bfa:	5f 91       	pop	r21
     bfc:	4f 91       	pop	r20
     bfe:	3f 91       	pop	r19
     c00:	2f 91       	pop	r18
     c02:	0f 90       	pop	r0
     c04:	0f be       	out	0x3f, r0	; 63
     c06:	0f 90       	pop	r0
     c08:	1f 90       	pop	r1
     c0a:	18 95       	reti

00000c0c <__vector_28>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
     c0c:	1f 92       	push	r1
     c0e:	0f 92       	push	r0
     c10:	0f b6       	in	r0, 0x3f	; 63
     c12:	0f 92       	push	r0
     c14:	11 24       	eor	r1, r1
     c16:	2f 93       	push	r18
     c18:	3f 93       	push	r19
     c1a:	4f 93       	push	r20
     c1c:	5f 93       	push	r21
     c1e:	6f 93       	push	r22
     c20:	7f 93       	push	r23
     c22:	8f 93       	push	r24
     c24:	9f 93       	push	r25
     c26:	af 93       	push	r26
     c28:	bf 93       	push	r27
     c2a:	cf 93       	push	r28
     c2c:	ef 93       	push	r30
     c2e:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
     c30:	e0 91 08 06 	lds	r30, 0x0608	; 0x800608 <_ser_handle+0x2>
     c34:	f0 91 09 06 	lds	r31, 0x0609	; 0x800609 <_ser_handle+0x3>
     c38:	30 97       	sbiw	r30, 0x00	; 0
     c3a:	a1 f0       	breq	.+40     	; 0xc64 <__vector_28+0x58>
		item = UDR1;
     c3c:	c0 91 ce 00 	lds	r28, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
     c40:	6c 2f       	mov	r22, r28
     c42:	84 81       	ldd	r24, Z+4	; 0x04
     c44:	95 81       	ldd	r25, Z+5	; 0x05
     c46:	0e 94 88 02 	call	0x510	; 0x510 <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
     c4a:	80 91 08 06 	lds	r24, 0x0608	; 0x800608 <_ser_handle+0x2>
     c4e:	90 91 09 06 	lds	r25, 0x0609	; 0x800609 <_ser_handle+0x3>
     c52:	dc 01       	movw	r26, r24
     c54:	16 96       	adiw	r26, 0x06	; 6
     c56:	ed 91       	ld	r30, X+
     c58:	fc 91       	ld	r31, X
     c5a:	17 97       	sbiw	r26, 0x07	; 7
     c5c:	30 97       	sbiw	r30, 0x00	; 0
     c5e:	11 f0       	breq	.+4      	; 0xc64 <__vector_28+0x58>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
     c60:	6c 2f       	mov	r22, r28
     c62:	09 95       	icall
		}
	}
}
     c64:	ff 91       	pop	r31
     c66:	ef 91       	pop	r30
     c68:	cf 91       	pop	r28
     c6a:	bf 91       	pop	r27
     c6c:	af 91       	pop	r26
     c6e:	9f 91       	pop	r25
     c70:	8f 91       	pop	r24
     c72:	7f 91       	pop	r23
     c74:	6f 91       	pop	r22
     c76:	5f 91       	pop	r21
     c78:	4f 91       	pop	r20
     c7a:	3f 91       	pop	r19
     c7c:	2f 91       	pop	r18
     c7e:	0f 90       	pop	r0
     c80:	0f be       	out	0x3f, r0	; 63
     c82:	0f 90       	pop	r0
     c84:	1f 90       	pop	r1
     c86:	18 95       	reti

00000c88 <__vector_29>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
     c88:	1f 92       	push	r1
     c8a:	0f 92       	push	r0
     c8c:	0f b6       	in	r0, 0x3f	; 63
     c8e:	0f 92       	push	r0
     c90:	11 24       	eor	r1, r1
     c92:	2f 93       	push	r18
     c94:	3f 93       	push	r19
     c96:	4f 93       	push	r20
     c98:	5f 93       	push	r21
     c9a:	6f 93       	push	r22
     c9c:	7f 93       	push	r23
     c9e:	8f 93       	push	r24
     ca0:	9f 93       	push	r25
     ca2:	af 93       	push	r26
     ca4:	bf 93       	push	r27
     ca6:	ef 93       	push	r30
     ca8:	ff 93       	push	r31
     caa:	cf 93       	push	r28
     cac:	df 93       	push	r29
     cae:	1f 92       	push	r1
     cb0:	cd b7       	in	r28, 0x3d	; 61
     cb2:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
     cb4:	e0 91 08 06 	lds	r30, 0x0608	; 0x800608 <_ser_handle+0x2>
     cb8:	f0 91 09 06 	lds	r31, 0x0609	; 0x800609 <_ser_handle+0x3>
     cbc:	30 97       	sbiw	r30, 0x00	; 0
     cbe:	99 f0       	breq	.+38     	; 0xce6 <__vector_29+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
     cc0:	be 01       	movw	r22, r28
     cc2:	6f 5f       	subi	r22, 0xFF	; 255
     cc4:	7f 4f       	sbci	r23, 0xFF	; 255
     cc6:	82 81       	ldd	r24, Z+2	; 0x02
     cc8:	93 81       	ldd	r25, Z+3	; 0x03
     cca:	0e 94 67 02 	call	0x4ce	; 0x4ce <buffer_get_item>
     cce:	81 11       	cpse	r24, r1
     cd0:	04 c0       	rjmp	.+8      	; 0xcda <__vector_29+0x52>
			UDR1 = item;
     cd2:	89 81       	ldd	r24, Y+1	; 0x01
     cd4:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
     cd8:	0b c0       	rjmp	.+22     	; 0xcf0 <__vector_29+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
     cda:	e9 ec       	ldi	r30, 0xC9	; 201
     cdc:	f0 e0       	ldi	r31, 0x00	; 0
     cde:	80 81       	ld	r24, Z
     ce0:	8f 7d       	andi	r24, 0xDF	; 223
     ce2:	80 83       	st	Z, r24
     ce4:	05 c0       	rjmp	.+10     	; 0xcf0 <__vector_29+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
     ce6:	e9 ec       	ldi	r30, 0xC9	; 201
     ce8:	f0 e0       	ldi	r31, 0x00	; 0
     cea:	80 81       	ld	r24, Z
     cec:	8f 7d       	andi	r24, 0xDF	; 223
     cee:	80 83       	st	Z, r24
	}
}
     cf0:	0f 90       	pop	r0
     cf2:	df 91       	pop	r29
     cf4:	cf 91       	pop	r28
     cf6:	ff 91       	pop	r31
     cf8:	ef 91       	pop	r30
     cfa:	bf 91       	pop	r27
     cfc:	af 91       	pop	r26
     cfe:	9f 91       	pop	r25
     d00:	8f 91       	pop	r24
     d02:	7f 91       	pop	r23
     d04:	6f 91       	pop	r22
     d06:	5f 91       	pop	r21
     d08:	4f 91       	pop	r20
     d0a:	3f 91       	pop	r19
     d0c:	2f 91       	pop	r18
     d0e:	0f 90       	pop	r0
     d10:	0f be       	out	0x3f, r0	; 63
     d12:	0f 90       	pop	r0
     d14:	1f 90       	pop	r1
     d16:	18 95       	reti

00000d18 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     d18:	0f 93       	push	r16
     d1a:	1f 93       	push	r17
     d1c:	cf 93       	push	r28
     d1e:	df 93       	push	r29
     d20:	ec 01       	movw	r28, r24
     d22:	04 2f       	mov	r16, r20
     d24:	1a 8d       	ldd	r17, Y+26	; 0x1a
     d26:	4c 8d       	ldd	r20, Y+28	; 0x1c
     d28:	41 11       	cpse	r20, r1
     d2a:	0c c0       	rjmp	.+24     	; 0xd44 <prvCopyDataToQueue+0x2c>
     d2c:	88 81       	ld	r24, Y
     d2e:	99 81       	ldd	r25, Y+1	; 0x01
     d30:	89 2b       	or	r24, r25
     d32:	09 f0       	breq	.+2      	; 0xd36 <prvCopyDataToQueue+0x1e>
     d34:	42 c0       	rjmp	.+132    	; 0xdba <prvCopyDataToQueue+0xa2>
     d36:	8a 81       	ldd	r24, Y+2	; 0x02
     d38:	9b 81       	ldd	r25, Y+3	; 0x03
     d3a:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <xTaskPriorityDisinherit>
     d3e:	1b 82       	std	Y+3, r1	; 0x03
     d40:	1a 82       	std	Y+2, r1	; 0x02
     d42:	42 c0       	rjmp	.+132    	; 0xdc8 <prvCopyDataToQueue+0xb0>
     d44:	01 11       	cpse	r16, r1
     d46:	17 c0       	rjmp	.+46     	; 0xd76 <prvCopyDataToQueue+0x5e>
     d48:	50 e0       	ldi	r21, 0x00	; 0
     d4a:	8c 81       	ldd	r24, Y+4	; 0x04
     d4c:	9d 81       	ldd	r25, Y+5	; 0x05
     d4e:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <memcpy>
     d52:	2c 8d       	ldd	r18, Y+28	; 0x1c
     d54:	8c 81       	ldd	r24, Y+4	; 0x04
     d56:	9d 81       	ldd	r25, Y+5	; 0x05
     d58:	82 0f       	add	r24, r18
     d5a:	91 1d       	adc	r25, r1
     d5c:	9d 83       	std	Y+5, r25	; 0x05
     d5e:	8c 83       	std	Y+4, r24	; 0x04
     d60:	2a 81       	ldd	r18, Y+2	; 0x02
     d62:	3b 81       	ldd	r19, Y+3	; 0x03
     d64:	82 17       	cp	r24, r18
     d66:	93 07       	cpc	r25, r19
     d68:	50 f1       	brcs	.+84     	; 0xdbe <prvCopyDataToQueue+0xa6>
     d6a:	88 81       	ld	r24, Y
     d6c:	99 81       	ldd	r25, Y+1	; 0x01
     d6e:	9d 83       	std	Y+5, r25	; 0x05
     d70:	8c 83       	std	Y+4, r24	; 0x04
     d72:	80 e0       	ldi	r24, 0x00	; 0
     d74:	29 c0       	rjmp	.+82     	; 0xdc8 <prvCopyDataToQueue+0xb0>
     d76:	50 e0       	ldi	r21, 0x00	; 0
     d78:	8e 81       	ldd	r24, Y+6	; 0x06
     d7a:	9f 81       	ldd	r25, Y+7	; 0x07
     d7c:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <memcpy>
     d80:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d82:	90 e0       	ldi	r25, 0x00	; 0
     d84:	91 95       	neg	r25
     d86:	81 95       	neg	r24
     d88:	91 09       	sbc	r25, r1
     d8a:	2e 81       	ldd	r18, Y+6	; 0x06
     d8c:	3f 81       	ldd	r19, Y+7	; 0x07
     d8e:	28 0f       	add	r18, r24
     d90:	39 1f       	adc	r19, r25
     d92:	3f 83       	std	Y+7, r19	; 0x07
     d94:	2e 83       	std	Y+6, r18	; 0x06
     d96:	48 81       	ld	r20, Y
     d98:	59 81       	ldd	r21, Y+1	; 0x01
     d9a:	24 17       	cp	r18, r20
     d9c:	35 07       	cpc	r19, r21
     d9e:	30 f4       	brcc	.+12     	; 0xdac <prvCopyDataToQueue+0x94>
     da0:	2a 81       	ldd	r18, Y+2	; 0x02
     da2:	3b 81       	ldd	r19, Y+3	; 0x03
     da4:	82 0f       	add	r24, r18
     da6:	93 1f       	adc	r25, r19
     da8:	9f 83       	std	Y+7, r25	; 0x07
     daa:	8e 83       	std	Y+6, r24	; 0x06
     dac:	02 30       	cpi	r16, 0x02	; 2
     dae:	49 f4       	brne	.+18     	; 0xdc2 <prvCopyDataToQueue+0xaa>
     db0:	11 23       	and	r17, r17
     db2:	49 f0       	breq	.+18     	; 0xdc6 <prvCopyDataToQueue+0xae>
     db4:	11 50       	subi	r17, 0x01	; 1
     db6:	80 e0       	ldi	r24, 0x00	; 0
     db8:	07 c0       	rjmp	.+14     	; 0xdc8 <prvCopyDataToQueue+0xb0>
     dba:	80 e0       	ldi	r24, 0x00	; 0
     dbc:	05 c0       	rjmp	.+10     	; 0xdc8 <prvCopyDataToQueue+0xb0>
     dbe:	80 e0       	ldi	r24, 0x00	; 0
     dc0:	03 c0       	rjmp	.+6      	; 0xdc8 <prvCopyDataToQueue+0xb0>
     dc2:	80 e0       	ldi	r24, 0x00	; 0
     dc4:	01 c0       	rjmp	.+2      	; 0xdc8 <prvCopyDataToQueue+0xb0>
     dc6:	80 e0       	ldi	r24, 0x00	; 0
     dc8:	1f 5f       	subi	r17, 0xFF	; 255
     dca:	1a 8f       	std	Y+26, r17	; 0x1a
     dcc:	df 91       	pop	r29
     dce:	cf 91       	pop	r28
     dd0:	1f 91       	pop	r17
     dd2:	0f 91       	pop	r16
     dd4:	08 95       	ret

00000dd6 <prvCopyDataFromQueue>:
     dd6:	fc 01       	movw	r30, r24
     dd8:	44 8d       	ldd	r20, Z+28	; 0x1c
     dda:	44 23       	and	r20, r20
     ddc:	a9 f0       	breq	.+42     	; 0xe08 <prvCopyDataFromQueue+0x32>
     dde:	50 e0       	ldi	r21, 0x00	; 0
     de0:	26 81       	ldd	r18, Z+6	; 0x06
     de2:	37 81       	ldd	r19, Z+7	; 0x07
     de4:	24 0f       	add	r18, r20
     de6:	35 1f       	adc	r19, r21
     de8:	37 83       	std	Z+7, r19	; 0x07
     dea:	26 83       	std	Z+6, r18	; 0x06
     dec:	82 81       	ldd	r24, Z+2	; 0x02
     dee:	93 81       	ldd	r25, Z+3	; 0x03
     df0:	28 17       	cp	r18, r24
     df2:	39 07       	cpc	r19, r25
     df4:	20 f0       	brcs	.+8      	; 0xdfe <prvCopyDataFromQueue+0x28>
     df6:	80 81       	ld	r24, Z
     df8:	91 81       	ldd	r25, Z+1	; 0x01
     dfa:	97 83       	std	Z+7, r25	; 0x07
     dfc:	86 83       	std	Z+6, r24	; 0x06
     dfe:	cb 01       	movw	r24, r22
     e00:	66 81       	ldd	r22, Z+6	; 0x06
     e02:	77 81       	ldd	r23, Z+7	; 0x07
     e04:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <memcpy>
     e08:	08 95       	ret

00000e0a <prvUnlockQueue>:
     e0a:	ef 92       	push	r14
     e0c:	ff 92       	push	r15
     e0e:	0f 93       	push	r16
     e10:	1f 93       	push	r17
     e12:	cf 93       	push	r28
     e14:	8c 01       	movw	r16, r24
     e16:	0f b6       	in	r0, 0x3f	; 63
     e18:	f8 94       	cli
     e1a:	0f 92       	push	r0
     e1c:	fc 01       	movw	r30, r24
     e1e:	c6 8d       	ldd	r28, Z+30	; 0x1e
     e20:	1c 16       	cp	r1, r28
     e22:	ac f4       	brge	.+42     	; 0xe4e <prvUnlockQueue+0x44>
     e24:	81 89       	ldd	r24, Z+17	; 0x11
     e26:	81 11       	cpse	r24, r1
     e28:	06 c0       	rjmp	.+12     	; 0xe36 <prvUnlockQueue+0x2c>
     e2a:	11 c0       	rjmp	.+34     	; 0xe4e <prvUnlockQueue+0x44>
     e2c:	f8 01       	movw	r30, r16
     e2e:	81 89       	ldd	r24, Z+17	; 0x11
     e30:	81 11       	cpse	r24, r1
     e32:	05 c0       	rjmp	.+10     	; 0xe3e <prvUnlockQueue+0x34>
     e34:	0c c0       	rjmp	.+24     	; 0xe4e <prvUnlockQueue+0x44>
     e36:	78 01       	movw	r14, r16
     e38:	f1 e1       	ldi	r31, 0x11	; 17
     e3a:	ef 0e       	add	r14, r31
     e3c:	f1 1c       	adc	r15, r1
     e3e:	c7 01       	movw	r24, r14
     e40:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <xTaskRemoveFromEventList>
     e44:	81 11       	cpse	r24, r1
     e46:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <vTaskMissedYield>
     e4a:	c1 50       	subi	r28, 0x01	; 1
     e4c:	79 f7       	brne	.-34     	; 0xe2c <prvUnlockQueue+0x22>
     e4e:	8f ef       	ldi	r24, 0xFF	; 255
     e50:	f8 01       	movw	r30, r16
     e52:	86 8f       	std	Z+30, r24	; 0x1e
     e54:	0f 90       	pop	r0
     e56:	0f be       	out	0x3f, r0	; 63
     e58:	0f b6       	in	r0, 0x3f	; 63
     e5a:	f8 94       	cli
     e5c:	0f 92       	push	r0
     e5e:	c5 8d       	ldd	r28, Z+29	; 0x1d
     e60:	1c 16       	cp	r1, r28
     e62:	ac f4       	brge	.+42     	; 0xe8e <prvUnlockQueue+0x84>
     e64:	80 85       	ldd	r24, Z+8	; 0x08
     e66:	81 11       	cpse	r24, r1
     e68:	06 c0       	rjmp	.+12     	; 0xe76 <prvUnlockQueue+0x6c>
     e6a:	11 c0       	rjmp	.+34     	; 0xe8e <prvUnlockQueue+0x84>
     e6c:	f8 01       	movw	r30, r16
     e6e:	80 85       	ldd	r24, Z+8	; 0x08
     e70:	81 11       	cpse	r24, r1
     e72:	05 c0       	rjmp	.+10     	; 0xe7e <prvUnlockQueue+0x74>
     e74:	0c c0       	rjmp	.+24     	; 0xe8e <prvUnlockQueue+0x84>
     e76:	78 01       	movw	r14, r16
     e78:	f8 e0       	ldi	r31, 0x08	; 8
     e7a:	ef 0e       	add	r14, r31
     e7c:	f1 1c       	adc	r15, r1
     e7e:	c7 01       	movw	r24, r14
     e80:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <xTaskRemoveFromEventList>
     e84:	81 11       	cpse	r24, r1
     e86:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <vTaskMissedYield>
     e8a:	c1 50       	subi	r28, 0x01	; 1
     e8c:	79 f7       	brne	.-34     	; 0xe6c <prvUnlockQueue+0x62>
     e8e:	8f ef       	ldi	r24, 0xFF	; 255
     e90:	f8 01       	movw	r30, r16
     e92:	85 8f       	std	Z+29, r24	; 0x1d
     e94:	0f 90       	pop	r0
     e96:	0f be       	out	0x3f, r0	; 63
     e98:	cf 91       	pop	r28
     e9a:	1f 91       	pop	r17
     e9c:	0f 91       	pop	r16
     e9e:	ff 90       	pop	r15
     ea0:	ef 90       	pop	r14
     ea2:	08 95       	ret

00000ea4 <xQueueGenericReset>:
     ea4:	cf 93       	push	r28
     ea6:	df 93       	push	r29
     ea8:	ec 01       	movw	r28, r24
     eaa:	0f b6       	in	r0, 0x3f	; 63
     eac:	f8 94       	cli
     eae:	0f 92       	push	r0
     eb0:	48 81       	ld	r20, Y
     eb2:	59 81       	ldd	r21, Y+1	; 0x01
     eb4:	2c 8d       	ldd	r18, Y+28	; 0x1c
     eb6:	30 e0       	ldi	r19, 0x00	; 0
     eb8:	7b 8d       	ldd	r23, Y+27	; 0x1b
     eba:	72 9f       	mul	r23, r18
     ebc:	c0 01       	movw	r24, r0
     ebe:	73 9f       	mul	r23, r19
     ec0:	90 0d       	add	r25, r0
     ec2:	11 24       	eor	r1, r1
     ec4:	fa 01       	movw	r30, r20
     ec6:	e8 0f       	add	r30, r24
     ec8:	f9 1f       	adc	r31, r25
     eca:	fb 83       	std	Y+3, r31	; 0x03
     ecc:	ea 83       	std	Y+2, r30	; 0x02
     ece:	1a 8e       	std	Y+26, r1	; 0x1a
     ed0:	5d 83       	std	Y+5, r21	; 0x05
     ed2:	4c 83       	std	Y+4, r20	; 0x04
     ed4:	82 1b       	sub	r24, r18
     ed6:	93 0b       	sbc	r25, r19
     ed8:	84 0f       	add	r24, r20
     eda:	95 1f       	adc	r25, r21
     edc:	9f 83       	std	Y+7, r25	; 0x07
     ede:	8e 83       	std	Y+6, r24	; 0x06
     ee0:	8f ef       	ldi	r24, 0xFF	; 255
     ee2:	8d 8f       	std	Y+29, r24	; 0x1d
     ee4:	8e 8f       	std	Y+30, r24	; 0x1e
     ee6:	61 11       	cpse	r22, r1
     ee8:	0c c0       	rjmp	.+24     	; 0xf02 <xQueueGenericReset+0x5e>
     eea:	88 85       	ldd	r24, Y+8	; 0x08
     eec:	88 23       	and	r24, r24
     eee:	89 f0       	breq	.+34     	; 0xf12 <xQueueGenericReset+0x6e>
     ef0:	ce 01       	movw	r24, r28
     ef2:	08 96       	adiw	r24, 0x08	; 8
     ef4:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <xTaskRemoveFromEventList>
     ef8:	88 23       	and	r24, r24
     efa:	59 f0       	breq	.+22     	; 0xf12 <xQueueGenericReset+0x6e>
     efc:	0e 94 d5 03 	call	0x7aa	; 0x7aa <vPortYield>
     f00:	08 c0       	rjmp	.+16     	; 0xf12 <xQueueGenericReset+0x6e>
     f02:	ce 01       	movw	r24, r28
     f04:	08 96       	adiw	r24, 0x08	; 8
     f06:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
     f0a:	ce 01       	movw	r24, r28
     f0c:	41 96       	adiw	r24, 0x11	; 17
     f0e:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
     f12:	0f 90       	pop	r0
     f14:	0f be       	out	0x3f, r0	; 63
     f16:	81 e0       	ldi	r24, 0x01	; 1
     f18:	df 91       	pop	r29
     f1a:	cf 91       	pop	r28
     f1c:	08 95       	ret

00000f1e <xQueueGenericCreate>:
     f1e:	ff 92       	push	r15
     f20:	0f 93       	push	r16
     f22:	1f 93       	push	r17
     f24:	cf 93       	push	r28
     f26:	df 93       	push	r29
     f28:	08 2f       	mov	r16, r24
     f2a:	16 2f       	mov	r17, r22
     f2c:	f4 2e       	mov	r15, r20
     f2e:	66 23       	and	r22, r22
     f30:	c9 f0       	breq	.+50     	; 0xf64 <xQueueGenericCreate+0x46>
     f32:	86 9f       	mul	r24, r22
     f34:	c0 01       	movw	r24, r0
     f36:	11 24       	eor	r1, r1
     f38:	81 96       	adiw	r24, 0x21	; 33
     f3a:	0e 94 8d 04 	call	0x91a	; 0x91a <pvPortMalloc>
     f3e:	ec 01       	movw	r28, r24
     f40:	00 97       	sbiw	r24, 0x00	; 0
     f42:	49 f4       	brne	.+18     	; 0xf56 <xQueueGenericCreate+0x38>
     f44:	16 c0       	rjmp	.+44     	; 0xf72 <xQueueGenericCreate+0x54>
     f46:	0b 8f       	std	Y+27, r16	; 0x1b
     f48:	1c 8f       	std	Y+28, r17	; 0x1c
     f4a:	61 e0       	ldi	r22, 0x01	; 1
     f4c:	ce 01       	movw	r24, r28
     f4e:	0e 94 52 07 	call	0xea4	; 0xea4 <xQueueGenericReset>
     f52:	f8 a2       	std	Y+32, r15	; 0x20
     f54:	0e c0       	rjmp	.+28     	; 0xf72 <xQueueGenericCreate+0x54>
     f56:	81 96       	adiw	r24, 0x21	; 33
     f58:	99 83       	std	Y+1, r25	; 0x01
     f5a:	88 83       	st	Y, r24
     f5c:	f4 cf       	rjmp	.-24     	; 0xf46 <xQueueGenericCreate+0x28>
     f5e:	d9 83       	std	Y+1, r29	; 0x01
     f60:	c8 83       	st	Y, r28
     f62:	f1 cf       	rjmp	.-30     	; 0xf46 <xQueueGenericCreate+0x28>
     f64:	81 e2       	ldi	r24, 0x21	; 33
     f66:	90 e0       	ldi	r25, 0x00	; 0
     f68:	0e 94 8d 04 	call	0x91a	; 0x91a <pvPortMalloc>
     f6c:	ec 01       	movw	r28, r24
     f6e:	89 2b       	or	r24, r25
     f70:	b1 f7       	brne	.-20     	; 0xf5e <xQueueGenericCreate+0x40>
     f72:	ce 01       	movw	r24, r28
     f74:	df 91       	pop	r29
     f76:	cf 91       	pop	r28
     f78:	1f 91       	pop	r17
     f7a:	0f 91       	pop	r16
     f7c:	ff 90       	pop	r15
     f7e:	08 95       	ret

00000f80 <xQueueGenericSend>:
     f80:	9f 92       	push	r9
     f82:	af 92       	push	r10
     f84:	bf 92       	push	r11
     f86:	cf 92       	push	r12
     f88:	df 92       	push	r13
     f8a:	ef 92       	push	r14
     f8c:	ff 92       	push	r15
     f8e:	0f 93       	push	r16
     f90:	1f 93       	push	r17
     f92:	cf 93       	push	r28
     f94:	df 93       	push	r29
     f96:	00 d0       	rcall	.+0      	; 0xf98 <xQueueGenericSend+0x18>
     f98:	00 d0       	rcall	.+0      	; 0xf9a <xQueueGenericSend+0x1a>
     f9a:	1f 92       	push	r1
     f9c:	cd b7       	in	r28, 0x3d	; 61
     f9e:	de b7       	in	r29, 0x3e	; 62
     fa0:	8c 01       	movw	r16, r24
     fa2:	6b 01       	movw	r12, r22
     fa4:	5d 83       	std	Y+5, r21	; 0x05
     fa6:	4c 83       	std	Y+4, r20	; 0x04
     fa8:	a2 2e       	mov	r10, r18
     faa:	b1 2c       	mov	r11, r1
     fac:	99 24       	eor	r9, r9
     fae:	93 94       	inc	r9
     fb0:	7c 01       	movw	r14, r24
     fb2:	88 e0       	ldi	r24, 0x08	; 8
     fb4:	e8 0e       	add	r14, r24
     fb6:	f1 1c       	adc	r15, r1
     fb8:	0f b6       	in	r0, 0x3f	; 63
     fba:	f8 94       	cli
     fbc:	0f 92       	push	r0
     fbe:	f8 01       	movw	r30, r16
     fc0:	92 8d       	ldd	r25, Z+26	; 0x1a
     fc2:	83 8d       	ldd	r24, Z+27	; 0x1b
     fc4:	98 17       	cp	r25, r24
     fc6:	18 f0       	brcs	.+6      	; 0xfce <xQueueGenericSend+0x4e>
     fc8:	f2 e0       	ldi	r31, 0x02	; 2
     fca:	af 12       	cpse	r10, r31
     fcc:	19 c0       	rjmp	.+50     	; 0x1000 <xQueueGenericSend+0x80>
     fce:	4a 2d       	mov	r20, r10
     fd0:	b6 01       	movw	r22, r12
     fd2:	c8 01       	movw	r24, r16
     fd4:	0e 94 8c 06 	call	0xd18	; 0xd18 <prvCopyDataToQueue>
     fd8:	f8 01       	movw	r30, r16
     fda:	91 89       	ldd	r25, Z+17	; 0x11
     fdc:	99 23       	and	r25, r25
     fde:	49 f0       	breq	.+18     	; 0xff2 <xQueueGenericSend+0x72>
     fe0:	c8 01       	movw	r24, r16
     fe2:	41 96       	adiw	r24, 0x11	; 17
     fe4:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <xTaskRemoveFromEventList>
     fe8:	88 23       	and	r24, r24
     fea:	31 f0       	breq	.+12     	; 0xff8 <xQueueGenericSend+0x78>
     fec:	0e 94 d5 03 	call	0x7aa	; 0x7aa <vPortYield>
     ff0:	03 c0       	rjmp	.+6      	; 0xff8 <xQueueGenericSend+0x78>
     ff2:	81 11       	cpse	r24, r1
     ff4:	0e 94 d5 03 	call	0x7aa	; 0x7aa <vPortYield>
     ff8:	0f 90       	pop	r0
     ffa:	0f be       	out	0x3f, r0	; 63
     ffc:	81 e0       	ldi	r24, 0x01	; 1
     ffe:	50 c0       	rjmp	.+160    	; 0x10a0 <xQueueGenericSend+0x120>
    1000:	8c 81       	ldd	r24, Y+4	; 0x04
    1002:	9d 81       	ldd	r25, Y+5	; 0x05
    1004:	89 2b       	or	r24, r25
    1006:	21 f4       	brne	.+8      	; 0x1010 <xQueueGenericSend+0x90>
    1008:	0f 90       	pop	r0
    100a:	0f be       	out	0x3f, r0	; 63
    100c:	80 e0       	ldi	r24, 0x00	; 0
    100e:	48 c0       	rjmp	.+144    	; 0x10a0 <xQueueGenericSend+0x120>
    1010:	b1 10       	cpse	r11, r1
    1012:	05 c0       	rjmp	.+10     	; 0x101e <xQueueGenericSend+0x9e>
    1014:	ce 01       	movw	r24, r28
    1016:	01 96       	adiw	r24, 0x01	; 1
    1018:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <vTaskSetTimeOutState>
    101c:	b9 2c       	mov	r11, r9
    101e:	0f 90       	pop	r0
    1020:	0f be       	out	0x3f, r0	; 63
    1022:	0e 94 23 0b 	call	0x1646	; 0x1646 <vTaskSuspendAll>
    1026:	0f b6       	in	r0, 0x3f	; 63
    1028:	f8 94       	cli
    102a:	0f 92       	push	r0
    102c:	f8 01       	movw	r30, r16
    102e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1030:	8f 3f       	cpi	r24, 0xFF	; 255
    1032:	09 f4       	brne	.+2      	; 0x1036 <xQueueGenericSend+0xb6>
    1034:	15 8e       	std	Z+29, r1	; 0x1d
    1036:	f8 01       	movw	r30, r16
    1038:	86 8d       	ldd	r24, Z+30	; 0x1e
    103a:	8f 3f       	cpi	r24, 0xFF	; 255
    103c:	09 f4       	brne	.+2      	; 0x1040 <xQueueGenericSend+0xc0>
    103e:	16 8e       	std	Z+30, r1	; 0x1e
    1040:	0f 90       	pop	r0
    1042:	0f be       	out	0x3f, r0	; 63
    1044:	be 01       	movw	r22, r28
    1046:	6c 5f       	subi	r22, 0xFC	; 252
    1048:	7f 4f       	sbci	r23, 0xFF	; 255
    104a:	ce 01       	movw	r24, r28
    104c:	01 96       	adiw	r24, 0x01	; 1
    104e:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <xTaskCheckForTimeOut>
    1052:	81 11       	cpse	r24, r1
    1054:	1f c0       	rjmp	.+62     	; 0x1094 <xQueueGenericSend+0x114>
    1056:	0f b6       	in	r0, 0x3f	; 63
    1058:	f8 94       	cli
    105a:	0f 92       	push	r0
    105c:	f8 01       	movw	r30, r16
    105e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1060:	0f 90       	pop	r0
    1062:	0f be       	out	0x3f, r0	; 63
    1064:	83 8d       	ldd	r24, Z+27	; 0x1b
    1066:	98 13       	cpse	r25, r24
    1068:	0f c0       	rjmp	.+30     	; 0x1088 <xQueueGenericSend+0x108>
    106a:	6c 81       	ldd	r22, Y+4	; 0x04
    106c:	7d 81       	ldd	r23, Y+5	; 0x05
    106e:	c7 01       	movw	r24, r14
    1070:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <vTaskPlaceOnEventList>
    1074:	c8 01       	movw	r24, r16
    1076:	0e 94 05 07 	call	0xe0a	; 0xe0a <prvUnlockQueue>
    107a:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <xTaskResumeAll>
    107e:	81 11       	cpse	r24, r1
    1080:	9b cf       	rjmp	.-202    	; 0xfb8 <xQueueGenericSend+0x38>
    1082:	0e 94 d5 03 	call	0x7aa	; 0x7aa <vPortYield>
    1086:	98 cf       	rjmp	.-208    	; 0xfb8 <xQueueGenericSend+0x38>
    1088:	c8 01       	movw	r24, r16
    108a:	0e 94 05 07 	call	0xe0a	; 0xe0a <prvUnlockQueue>
    108e:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <xTaskResumeAll>
    1092:	92 cf       	rjmp	.-220    	; 0xfb8 <xQueueGenericSend+0x38>
    1094:	c8 01       	movw	r24, r16
    1096:	0e 94 05 07 	call	0xe0a	; 0xe0a <prvUnlockQueue>
    109a:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <xTaskResumeAll>
    109e:	80 e0       	ldi	r24, 0x00	; 0
    10a0:	0f 90       	pop	r0
    10a2:	0f 90       	pop	r0
    10a4:	0f 90       	pop	r0
    10a6:	0f 90       	pop	r0
    10a8:	0f 90       	pop	r0
    10aa:	df 91       	pop	r29
    10ac:	cf 91       	pop	r28
    10ae:	1f 91       	pop	r17
    10b0:	0f 91       	pop	r16
    10b2:	ff 90       	pop	r15
    10b4:	ef 90       	pop	r14
    10b6:	df 90       	pop	r13
    10b8:	cf 90       	pop	r12
    10ba:	bf 90       	pop	r11
    10bc:	af 90       	pop	r10
    10be:	9f 90       	pop	r9
    10c0:	08 95       	ret

000010c2 <xQueueCreateMutex>:
    10c2:	cf 93       	push	r28
    10c4:	df 93       	push	r29
    10c6:	48 2f       	mov	r20, r24
    10c8:	60 e0       	ldi	r22, 0x00	; 0
    10ca:	81 e0       	ldi	r24, 0x01	; 1
    10cc:	0e 94 8f 07 	call	0xf1e	; 0xf1e <xQueueGenericCreate>
    10d0:	ec 01       	movw	r28, r24
    10d2:	00 97       	sbiw	r24, 0x00	; 0
    10d4:	61 f0       	breq	.+24     	; 0x10ee <xQueueCreateMutex+0x2c>
    10d6:	1b 82       	std	Y+3, r1	; 0x03
    10d8:	1a 82       	std	Y+2, r1	; 0x02
    10da:	19 82       	std	Y+1, r1	; 0x01
    10dc:	18 82       	st	Y, r1
    10de:	1e 82       	std	Y+6, r1	; 0x06
    10e0:	20 e0       	ldi	r18, 0x00	; 0
    10e2:	40 e0       	ldi	r20, 0x00	; 0
    10e4:	50 e0       	ldi	r21, 0x00	; 0
    10e6:	60 e0       	ldi	r22, 0x00	; 0
    10e8:	70 e0       	ldi	r23, 0x00	; 0
    10ea:	0e 94 c0 07 	call	0xf80	; 0xf80 <xQueueGenericSend>
    10ee:	ce 01       	movw	r24, r28
    10f0:	df 91       	pop	r29
    10f2:	cf 91       	pop	r28
    10f4:	08 95       	ret

000010f6 <xQueueGenericSendFromISR>:
    10f6:	ef 92       	push	r14
    10f8:	ff 92       	push	r15
    10fa:	0f 93       	push	r16
    10fc:	1f 93       	push	r17
    10fe:	cf 93       	push	r28
    1100:	df 93       	push	r29
    1102:	8a 01       	movw	r16, r20
    1104:	fc 01       	movw	r30, r24
    1106:	52 8d       	ldd	r21, Z+26	; 0x1a
    1108:	33 8d       	ldd	r19, Z+27	; 0x1b
    110a:	53 17       	cp	r21, r19
    110c:	10 f0       	brcs	.+4      	; 0x1112 <xQueueGenericSendFromISR+0x1c>
    110e:	22 30       	cpi	r18, 0x02	; 2
    1110:	f1 f4       	brne	.+60     	; 0x114e <xQueueGenericSendFromISR+0x58>
    1112:	42 2f       	mov	r20, r18
    1114:	78 01       	movw	r14, r16
    1116:	ec 01       	movw	r28, r24
    1118:	1e 8d       	ldd	r17, Y+30	; 0x1e
    111a:	0e 94 8c 06 	call	0xd18	; 0xd18 <prvCopyDataToQueue>
    111e:	1f 3f       	cpi	r17, 0xFF	; 255
    1120:	81 f4       	brne	.+32     	; 0x1142 <xQueueGenericSendFromISR+0x4c>
    1122:	89 89       	ldd	r24, Y+17	; 0x11
    1124:	88 23       	and	r24, r24
    1126:	a9 f0       	breq	.+42     	; 0x1152 <xQueueGenericSendFromISR+0x5c>
    1128:	ce 01       	movw	r24, r28
    112a:	41 96       	adiw	r24, 0x11	; 17
    112c:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <xTaskRemoveFromEventList>
    1130:	88 23       	and	r24, r24
    1132:	89 f0       	breq	.+34     	; 0x1156 <xQueueGenericSendFromISR+0x60>
    1134:	e1 14       	cp	r14, r1
    1136:	f1 04       	cpc	r15, r1
    1138:	81 f0       	breq	.+32     	; 0x115a <xQueueGenericSendFromISR+0x64>
    113a:	81 e0       	ldi	r24, 0x01	; 1
    113c:	f7 01       	movw	r30, r14
    113e:	80 83       	st	Z, r24
    1140:	0d c0       	rjmp	.+26     	; 0x115c <xQueueGenericSendFromISR+0x66>
    1142:	ff 24       	eor	r15, r15
    1144:	f3 94       	inc	r15
    1146:	f1 0e       	add	r15, r17
    1148:	fe 8e       	std	Y+30, r15	; 0x1e
    114a:	81 e0       	ldi	r24, 0x01	; 1
    114c:	07 c0       	rjmp	.+14     	; 0x115c <xQueueGenericSendFromISR+0x66>
    114e:	80 e0       	ldi	r24, 0x00	; 0
    1150:	05 c0       	rjmp	.+10     	; 0x115c <xQueueGenericSendFromISR+0x66>
    1152:	81 e0       	ldi	r24, 0x01	; 1
    1154:	03 c0       	rjmp	.+6      	; 0x115c <xQueueGenericSendFromISR+0x66>
    1156:	81 e0       	ldi	r24, 0x01	; 1
    1158:	01 c0       	rjmp	.+2      	; 0x115c <xQueueGenericSendFromISR+0x66>
    115a:	81 e0       	ldi	r24, 0x01	; 1
    115c:	df 91       	pop	r29
    115e:	cf 91       	pop	r28
    1160:	1f 91       	pop	r17
    1162:	0f 91       	pop	r16
    1164:	ff 90       	pop	r15
    1166:	ef 90       	pop	r14
    1168:	08 95       	ret

0000116a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    116a:	8f 92       	push	r8
    116c:	9f 92       	push	r9
    116e:	af 92       	push	r10
    1170:	bf 92       	push	r11
    1172:	cf 92       	push	r12
    1174:	df 92       	push	r13
    1176:	ef 92       	push	r14
    1178:	ff 92       	push	r15
    117a:	0f 93       	push	r16
    117c:	1f 93       	push	r17
    117e:	cf 93       	push	r28
    1180:	df 93       	push	r29
    1182:	00 d0       	rcall	.+0      	; 0x1184 <xQueueGenericReceive+0x1a>
    1184:	00 d0       	rcall	.+0      	; 0x1186 <xQueueGenericReceive+0x1c>
    1186:	1f 92       	push	r1
    1188:	cd b7       	in	r28, 0x3d	; 61
    118a:	de b7       	in	r29, 0x3e	; 62
    118c:	8c 01       	movw	r16, r24
    118e:	5b 01       	movw	r10, r22
    1190:	5d 83       	std	Y+5, r21	; 0x05
    1192:	4c 83       	std	Y+4, r20	; 0x04
    1194:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1196:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1198:	99 24       	eor	r9, r9
    119a:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    119c:	6c 01       	movw	r12, r24
    119e:	81 e1       	ldi	r24, 0x11	; 17
    11a0:	c8 0e       	add	r12, r24
    11a2:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    11a4:	0f b6       	in	r0, 0x3f	; 63
    11a6:	f8 94       	cli
    11a8:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    11aa:	f8 01       	movw	r30, r16
    11ac:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    11ae:	ff 20       	and	r15, r15
    11b0:	91 f1       	breq	.+100    	; 0x1216 <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    11b2:	c6 80       	ldd	r12, Z+6	; 0x06
    11b4:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    11b6:	b5 01       	movw	r22, r10
    11b8:	c8 01       	movw	r24, r16
    11ba:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    11be:	81 10       	cpse	r8, r1
    11c0:	19 c0       	rjmp	.+50     	; 0x11f4 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    11c2:	fa 94       	dec	r15
    11c4:	f8 01       	movw	r30, r16
    11c6:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    11c8:	80 81       	ld	r24, Z
    11ca:	91 81       	ldd	r25, Z+1	; 0x01
    11cc:	89 2b       	or	r24, r25
    11ce:	29 f4       	brne	.+10     	; 0x11da <xQueueGenericReceive+0x70>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    11d0:	0e 94 76 0e 	call	0x1cec	; 0x1cec <pvTaskIncrementMutexHeldCount>
    11d4:	f8 01       	movw	r30, r16
    11d6:	93 83       	std	Z+3, r25	; 0x03
    11d8:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    11da:	f8 01       	movw	r30, r16
    11dc:	80 85       	ldd	r24, Z+8	; 0x08
    11de:	88 23       	and	r24, r24
    11e0:	b1 f0       	breq	.+44     	; 0x120e <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    11e2:	c8 01       	movw	r24, r16
    11e4:	08 96       	adiw	r24, 0x08	; 8
    11e6:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <xTaskRemoveFromEventList>
    11ea:	88 23       	and	r24, r24
    11ec:	81 f0       	breq	.+32     	; 0x120e <xQueueGenericReceive+0xa4>
						{
							queueYIELD_IF_USING_PREEMPTION();
    11ee:	0e 94 d5 03 	call	0x7aa	; 0x7aa <vPortYield>
    11f2:	0d c0       	rjmp	.+26     	; 0x120e <xQueueGenericReceive+0xa4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    11f4:	f8 01       	movw	r30, r16
    11f6:	d7 82       	std	Z+7, r13	; 0x07
    11f8:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11fa:	81 89       	ldd	r24, Z+17	; 0x11
    11fc:	88 23       	and	r24, r24
    11fe:	39 f0       	breq	.+14     	; 0x120e <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1200:	c8 01       	movw	r24, r16
    1202:	41 96       	adiw	r24, 0x11	; 17
    1204:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <xTaskRemoveFromEventList>
    1208:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    120a:	0e 94 d5 03 	call	0x7aa	; 0x7aa <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    120e:	0f 90       	pop	r0
    1210:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1212:	81 e0       	ldi	r24, 0x01	; 1
    1214:	64 c0       	rjmp	.+200    	; 0x12de <xQueueGenericReceive+0x174>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1216:	8c 81       	ldd	r24, Y+4	; 0x04
    1218:	9d 81       	ldd	r25, Y+5	; 0x05
    121a:	89 2b       	or	r24, r25
    121c:	21 f4       	brne	.+8      	; 0x1226 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    121e:	0f 90       	pop	r0
    1220:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1222:	80 e0       	ldi	r24, 0x00	; 0
    1224:	5c c0       	rjmp	.+184    	; 0x12de <xQueueGenericReceive+0x174>
				}
				else if( xEntryTimeSet == pdFALSE )
    1226:	e1 10       	cpse	r14, r1
    1228:	05 c0       	rjmp	.+10     	; 0x1234 <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    122a:	ce 01       	movw	r24, r28
    122c:	01 96       	adiw	r24, 0x01	; 1
    122e:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1232:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1234:	0f 90       	pop	r0
    1236:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1238:	0e 94 23 0b 	call	0x1646	; 0x1646 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    123c:	0f b6       	in	r0, 0x3f	; 63
    123e:	f8 94       	cli
    1240:	0f 92       	push	r0
    1242:	f8 01       	movw	r30, r16
    1244:	85 8d       	ldd	r24, Z+29	; 0x1d
    1246:	8f 3f       	cpi	r24, 0xFF	; 255
    1248:	09 f4       	brne	.+2      	; 0x124c <xQueueGenericReceive+0xe2>
    124a:	15 8e       	std	Z+29, r1	; 0x1d
    124c:	f8 01       	movw	r30, r16
    124e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1250:	8f 3f       	cpi	r24, 0xFF	; 255
    1252:	09 f4       	brne	.+2      	; 0x1256 <xQueueGenericReceive+0xec>
    1254:	16 8e       	std	Z+30, r1	; 0x1e
    1256:	0f 90       	pop	r0
    1258:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    125a:	be 01       	movw	r22, r28
    125c:	6c 5f       	subi	r22, 0xFC	; 252
    125e:	7f 4f       	sbci	r23, 0xFF	; 255
    1260:	ce 01       	movw	r24, r28
    1262:	01 96       	adiw	r24, 0x01	; 1
    1264:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <xTaskCheckForTimeOut>
    1268:	81 11       	cpse	r24, r1
    126a:	2b c0       	rjmp	.+86     	; 0x12c2 <xQueueGenericReceive+0x158>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    126c:	0f b6       	in	r0, 0x3f	; 63
    126e:	f8 94       	cli
    1270:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1272:	f8 01       	movw	r30, r16
    1274:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1276:	0f 90       	pop	r0
    1278:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    127a:	81 11       	cpse	r24, r1
    127c:	1c c0       	rjmp	.+56     	; 0x12b6 <xQueueGenericReceive+0x14c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    127e:	80 81       	ld	r24, Z
    1280:	91 81       	ldd	r25, Z+1	; 0x01
    1282:	89 2b       	or	r24, r25
    1284:	49 f4       	brne	.+18     	; 0x1298 <xQueueGenericReceive+0x12e>
					{
						taskENTER_CRITICAL();
    1286:	0f b6       	in	r0, 0x3f	; 63
    1288:	f8 94       	cli
    128a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    128c:	82 81       	ldd	r24, Z+2	; 0x02
    128e:	93 81       	ldd	r25, Z+3	; 0x03
    1290:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1294:	0f 90       	pop	r0
    1296:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1298:	6c 81       	ldd	r22, Y+4	; 0x04
    129a:	7d 81       	ldd	r23, Y+5	; 0x05
    129c:	c6 01       	movw	r24, r12
    129e:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    12a2:	c8 01       	movw	r24, r16
    12a4:	0e 94 05 07 	call	0xe0a	; 0xe0a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    12a8:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <xTaskResumeAll>
    12ac:	81 11       	cpse	r24, r1
    12ae:	7a cf       	rjmp	.-268    	; 0x11a4 <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
    12b0:	0e 94 d5 03 	call	0x7aa	; 0x7aa <vPortYield>
    12b4:	77 cf       	rjmp	.-274    	; 0x11a4 <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    12b6:	c8 01       	movw	r24, r16
    12b8:	0e 94 05 07 	call	0xe0a	; 0xe0a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    12bc:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <xTaskResumeAll>
    12c0:	71 cf       	rjmp	.-286    	; 0x11a4 <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    12c2:	c8 01       	movw	r24, r16
    12c4:	0e 94 05 07 	call	0xe0a	; 0xe0a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    12c8:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    12cc:	0f b6       	in	r0, 0x3f	; 63
    12ce:	f8 94       	cli
    12d0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    12d2:	f8 01       	movw	r30, r16
    12d4:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    12d6:	0f 90       	pop	r0
    12d8:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    12da:	81 11       	cpse	r24, r1
    12dc:	63 cf       	rjmp	.-314    	; 0x11a4 <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    12de:	0f 90       	pop	r0
    12e0:	0f 90       	pop	r0
    12e2:	0f 90       	pop	r0
    12e4:	0f 90       	pop	r0
    12e6:	0f 90       	pop	r0
    12e8:	df 91       	pop	r29
    12ea:	cf 91       	pop	r28
    12ec:	1f 91       	pop	r17
    12ee:	0f 91       	pop	r16
    12f0:	ff 90       	pop	r15
    12f2:	ef 90       	pop	r14
    12f4:	df 90       	pop	r13
    12f6:	cf 90       	pop	r12
    12f8:	bf 90       	pop	r11
    12fa:	af 90       	pop	r10
    12fc:	9f 90       	pop	r9
    12fe:	8f 90       	pop	r8
    1300:	08 95       	ret

00001302 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1302:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxDelayedTaskList>
    1306:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxDelayedTaskList+0x1>
    130a:	80 81       	ld	r24, Z
    130c:	81 11       	cpse	r24, r1
    130e:	07 c0       	rjmp	.+14     	; 0x131e <prvResetNextTaskUnblockTime+0x1c>
    1310:	8f ef       	ldi	r24, 0xFF	; 255
    1312:	9f ef       	ldi	r25, 0xFF	; 255
    1314:	90 93 0e 06 	sts	0x060E, r25	; 0x80060e <xNextTaskUnblockTime+0x1>
    1318:	80 93 0d 06 	sts	0x060D, r24	; 0x80060d <xNextTaskUnblockTime>
    131c:	08 95       	ret
    131e:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxDelayedTaskList>
    1322:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxDelayedTaskList+0x1>
    1326:	05 80       	ldd	r0, Z+5	; 0x05
    1328:	f6 81       	ldd	r31, Z+6	; 0x06
    132a:	e0 2d       	mov	r30, r0
    132c:	06 80       	ldd	r0, Z+6	; 0x06
    132e:	f7 81       	ldd	r31, Z+7	; 0x07
    1330:	e0 2d       	mov	r30, r0
    1332:	82 81       	ldd	r24, Z+2	; 0x02
    1334:	93 81       	ldd	r25, Z+3	; 0x03
    1336:	90 93 0e 06 	sts	0x060E, r25	; 0x80060e <xNextTaskUnblockTime+0x1>
    133a:	80 93 0d 06 	sts	0x060D, r24	; 0x80060d <xNextTaskUnblockTime>
    133e:	08 95       	ret

00001340 <prvAddCurrentTaskToDelayedList>:
    1340:	0f 93       	push	r16
    1342:	1f 93       	push	r17
    1344:	cf 93       	push	r28
    1346:	df 93       	push	r29
    1348:	ec 01       	movw	r28, r24
    134a:	00 91 15 06 	lds	r16, 0x0615	; 0x800615 <xTickCount>
    134e:	10 91 16 06 	lds	r17, 0x0616	; 0x800616 <xTickCount+0x1>
    1352:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <pxCurrentTCB>
    1356:	90 91 66 06 	lds	r25, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    135a:	02 96       	adiw	r24, 0x02	; 2
    135c:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    1360:	c0 0f       	add	r28, r16
    1362:	d1 1f       	adc	r29, r17
    1364:	e0 91 65 06 	lds	r30, 0x0665	; 0x800665 <pxCurrentTCB>
    1368:	f0 91 66 06 	lds	r31, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    136c:	d3 83       	std	Z+3, r29	; 0x03
    136e:	c2 83       	std	Z+2, r28	; 0x02
    1370:	c0 17       	cp	r28, r16
    1372:	d1 07       	cpc	r29, r17
    1374:	68 f4       	brcc	.+26     	; 0x1390 <prvAddCurrentTaskToDelayedList+0x50>
    1376:	60 91 65 06 	lds	r22, 0x0665	; 0x800665 <pxCurrentTCB>
    137a:	70 91 66 06 	lds	r23, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    137e:	80 91 2b 06 	lds	r24, 0x062B	; 0x80062b <pxOverflowDelayedTaskList>
    1382:	90 91 2c 06 	lds	r25, 0x062C	; 0x80062c <pxOverflowDelayedTaskList+0x1>
    1386:	6e 5f       	subi	r22, 0xFE	; 254
    1388:	7f 4f       	sbci	r23, 0xFF	; 255
    138a:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <vListInsert>
    138e:	17 c0       	rjmp	.+46     	; 0x13be <prvAddCurrentTaskToDelayedList+0x7e>
    1390:	60 91 65 06 	lds	r22, 0x0665	; 0x800665 <pxCurrentTCB>
    1394:	70 91 66 06 	lds	r23, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    1398:	80 91 2d 06 	lds	r24, 0x062D	; 0x80062d <pxDelayedTaskList>
    139c:	90 91 2e 06 	lds	r25, 0x062E	; 0x80062e <pxDelayedTaskList+0x1>
    13a0:	6e 5f       	subi	r22, 0xFE	; 254
    13a2:	7f 4f       	sbci	r23, 0xFF	; 255
    13a4:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <vListInsert>
    13a8:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <xNextTaskUnblockTime>
    13ac:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <xNextTaskUnblockTime+0x1>
    13b0:	c8 17       	cp	r28, r24
    13b2:	d9 07       	cpc	r29, r25
    13b4:	20 f4       	brcc	.+8      	; 0x13be <prvAddCurrentTaskToDelayedList+0x7e>
    13b6:	d0 93 0e 06 	sts	0x060E, r29	; 0x80060e <xNextTaskUnblockTime+0x1>
    13ba:	c0 93 0d 06 	sts	0x060D, r28	; 0x80060d <xNextTaskUnblockTime>
    13be:	df 91       	pop	r29
    13c0:	cf 91       	pop	r28
    13c2:	1f 91       	pop	r17
    13c4:	0f 91       	pop	r16
    13c6:	08 95       	ret

000013c8 <xTaskCreate>:
    13c8:	4f 92       	push	r4
    13ca:	5f 92       	push	r5
    13cc:	6f 92       	push	r6
    13ce:	7f 92       	push	r7
    13d0:	8f 92       	push	r8
    13d2:	9f 92       	push	r9
    13d4:	af 92       	push	r10
    13d6:	bf 92       	push	r11
    13d8:	cf 92       	push	r12
    13da:	df 92       	push	r13
    13dc:	ef 92       	push	r14
    13de:	ff 92       	push	r15
    13e0:	0f 93       	push	r16
    13e2:	cf 93       	push	r28
    13e4:	df 93       	push	r29
    13e6:	4c 01       	movw	r8, r24
    13e8:	6b 01       	movw	r12, r22
    13ea:	5a 01       	movw	r10, r20
    13ec:	29 01       	movw	r4, r18
    13ee:	ca 01       	movw	r24, r20
    13f0:	0e 94 8d 04 	call	0x91a	; 0x91a <pvPortMalloc>
    13f4:	3c 01       	movw	r6, r24
    13f6:	89 2b       	or	r24, r25
    13f8:	09 f4       	brne	.+2      	; 0x13fc <xTaskCreate+0x34>
    13fa:	ea c0       	rjmp	.+468    	; 0x15d0 <xTaskCreate+0x208>
    13fc:	8c e2       	ldi	r24, 0x2C	; 44
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	0e 94 8d 04 	call	0x91a	; 0x91a <pvPortMalloc>
    1404:	ec 01       	movw	r28, r24
    1406:	89 2b       	or	r24, r25
    1408:	b1 f0       	breq	.+44     	; 0x1436 <xTaskCreate+0x6e>
    140a:	78 8e       	std	Y+24, r7	; 0x18
    140c:	6f 8a       	std	Y+23, r6	; 0x17
    140e:	a5 01       	movw	r20, r10
    1410:	65 ea       	ldi	r22, 0xA5	; 165
    1412:	70 e0       	ldi	r23, 0x00	; 0
    1414:	c3 01       	movw	r24, r6
    1416:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <memset>
    141a:	81 e0       	ldi	r24, 0x01	; 1
    141c:	a8 1a       	sub	r10, r24
    141e:	b1 08       	sbc	r11, r1
    1420:	8f 89       	ldd	r24, Y+23	; 0x17
    1422:	98 8d       	ldd	r25, Y+24	; 0x18
    1424:	a8 0e       	add	r10, r24
    1426:	b9 1e       	adc	r11, r25
    1428:	d6 01       	movw	r26, r12
    142a:	8c 91       	ld	r24, X
    142c:	89 8f       	std	Y+25, r24	; 0x19
    142e:	8c 91       	ld	r24, X
    1430:	81 11       	cpse	r24, r1
    1432:	05 c0       	rjmp	.+10     	; 0x143e <xTaskCreate+0x76>
    1434:	18 c0       	rjmp	.+48     	; 0x1466 <xTaskCreate+0x9e>
    1436:	c3 01       	movw	r24, r6
    1438:	0e 94 c2 04 	call	0x984	; 0x984 <vPortFree>
    143c:	c9 c0       	rjmp	.+402    	; 0x15d0 <xTaskCreate+0x208>
    143e:	ae 01       	movw	r20, r28
    1440:	46 5e       	subi	r20, 0xE6	; 230
    1442:	5f 4f       	sbci	r21, 0xFF	; 255
    1444:	f6 01       	movw	r30, r12
    1446:	31 96       	adiw	r30, 0x01	; 1
    1448:	b8 e0       	ldi	r27, 0x08	; 8
    144a:	cb 0e       	add	r12, r27
    144c:	d1 1c       	adc	r13, r1
    144e:	cf 01       	movw	r24, r30
    1450:	21 91       	ld	r18, Z+
    1452:	da 01       	movw	r26, r20
    1454:	2d 93       	st	X+, r18
    1456:	ad 01       	movw	r20, r26
    1458:	dc 01       	movw	r26, r24
    145a:	8c 91       	ld	r24, X
    145c:	88 23       	and	r24, r24
    145e:	19 f0       	breq	.+6      	; 0x1466 <xTaskCreate+0x9e>
    1460:	ec 15       	cp	r30, r12
    1462:	fd 05       	cpc	r31, r13
    1464:	a1 f7       	brne	.-24     	; 0x144e <xTaskCreate+0x86>
    1466:	18 a2       	std	Y+32, r1	; 0x20
    1468:	04 30       	cpi	r16, 0x04	; 4
    146a:	08 f0       	brcs	.+2      	; 0x146e <xTaskCreate+0xa6>
    146c:	03 e0       	ldi	r16, 0x03	; 3
    146e:	0e 8b       	std	Y+22, r16	; 0x16
    1470:	0b a3       	std	Y+35, r16	; 0x23
    1472:	1c a2       	std	Y+36, r1	; 0x24
    1474:	6e 01       	movw	r12, r28
    1476:	b2 e0       	ldi	r27, 0x02	; 2
    1478:	cb 0e       	add	r12, r27
    147a:	d1 1c       	adc	r13, r1
    147c:	c6 01       	movw	r24, r12
    147e:	0e 94 b3 02 	call	0x566	; 0x566 <vListInitialiseItem>
    1482:	ce 01       	movw	r24, r28
    1484:	0c 96       	adiw	r24, 0x0c	; 12
    1486:	0e 94 b3 02 	call	0x566	; 0x566 <vListInitialiseItem>
    148a:	d9 87       	std	Y+9, r29	; 0x09
    148c:	c8 87       	std	Y+8, r28	; 0x08
    148e:	84 e0       	ldi	r24, 0x04	; 4
    1490:	90 e0       	ldi	r25, 0x00	; 0
    1492:	80 1b       	sub	r24, r16
    1494:	91 09       	sbc	r25, r1
    1496:	9d 87       	std	Y+13, r25	; 0x0d
    1498:	8c 87       	std	Y+12, r24	; 0x0c
    149a:	db 8b       	std	Y+19, r29	; 0x13
    149c:	ca 8b       	std	Y+18, r28	; 0x12
    149e:	1e a2       	std	Y+38, r1	; 0x26
    14a0:	1d a2       	std	Y+37, r1	; 0x25
    14a2:	1f a2       	std	Y+39, r1	; 0x27
    14a4:	18 a6       	std	Y+40, r1	; 0x28
    14a6:	19 a6       	std	Y+41, r1	; 0x29
    14a8:	1a a6       	std	Y+42, r1	; 0x2a
    14aa:	1b a6       	std	Y+43, r1	; 0x2b
    14ac:	a2 01       	movw	r20, r4
    14ae:	b4 01       	movw	r22, r8
    14b0:	c5 01       	movw	r24, r10
    14b2:	0e 94 2f 03 	call	0x65e	; 0x65e <pxPortInitialiseStack>
    14b6:	99 83       	std	Y+1, r25	; 0x01
    14b8:	88 83       	st	Y, r24
    14ba:	e1 14       	cp	r14, r1
    14bc:	f1 04       	cpc	r15, r1
    14be:	19 f0       	breq	.+6      	; 0x14c6 <xTaskCreate+0xfe>
    14c0:	f7 01       	movw	r30, r14
    14c2:	d1 83       	std	Z+1, r29	; 0x01
    14c4:	c0 83       	st	Z, r28
    14c6:	0f b6       	in	r0, 0x3f	; 63
    14c8:	f8 94       	cli
    14ca:	0f 92       	push	r0
    14cc:	80 91 17 06 	lds	r24, 0x0617	; 0x800617 <uxCurrentNumberOfTasks>
    14d0:	8f 5f       	subi	r24, 0xFF	; 255
    14d2:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <uxCurrentNumberOfTasks>
    14d6:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <pxCurrentTCB>
    14da:	90 91 66 06 	lds	r25, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    14de:	89 2b       	or	r24, r25
    14e0:	a9 f5       	brne	.+106    	; 0x154c <xTaskCreate+0x184>
    14e2:	d0 93 66 06 	sts	0x0666, r29	; 0x800666 <pxCurrentTCB+0x1>
    14e6:	c0 93 65 06 	sts	0x0665, r28	; 0x800665 <pxCurrentTCB>
    14ea:	80 91 17 06 	lds	r24, 0x0617	; 0x800617 <uxCurrentNumberOfTasks>
    14ee:	81 30       	cpi	r24, 0x01	; 1
    14f0:	e9 f5       	brne	.+122    	; 0x156c <xTaskCreate+0x1a4>
    14f2:	81 e4       	ldi	r24, 0x41	; 65
    14f4:	96 e0       	ldi	r25, 0x06	; 6
    14f6:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    14fa:	8a e4       	ldi	r24, 0x4A	; 74
    14fc:	96 e0       	ldi	r25, 0x06	; 6
    14fe:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    1502:	83 e5       	ldi	r24, 0x53	; 83
    1504:	96 e0       	ldi	r25, 0x06	; 6
    1506:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    150a:	8c e5       	ldi	r24, 0x5C	; 92
    150c:	96 e0       	ldi	r25, 0x06	; 6
    150e:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    1512:	88 e3       	ldi	r24, 0x38	; 56
    1514:	96 e0       	ldi	r25, 0x06	; 6
    1516:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    151a:	8f e2       	ldi	r24, 0x2F	; 47
    151c:	96 e0       	ldi	r25, 0x06	; 6
    151e:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    1522:	82 e2       	ldi	r24, 0x22	; 34
    1524:	96 e0       	ldi	r25, 0x06	; 6
    1526:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    152a:	89 e1       	ldi	r24, 0x19	; 25
    152c:	96 e0       	ldi	r25, 0x06	; 6
    152e:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    1532:	88 e3       	ldi	r24, 0x38	; 56
    1534:	96 e0       	ldi	r25, 0x06	; 6
    1536:	90 93 2e 06 	sts	0x062E, r25	; 0x80062e <pxDelayedTaskList+0x1>
    153a:	80 93 2d 06 	sts	0x062D, r24	; 0x80062d <pxDelayedTaskList>
    153e:	8f e2       	ldi	r24, 0x2F	; 47
    1540:	96 e0       	ldi	r25, 0x06	; 6
    1542:	90 93 2c 06 	sts	0x062C, r25	; 0x80062c <pxOverflowDelayedTaskList+0x1>
    1546:	80 93 2b 06 	sts	0x062B, r24	; 0x80062b <pxOverflowDelayedTaskList>
    154a:	10 c0       	rjmp	.+32     	; 0x156c <xTaskCreate+0x1a4>
    154c:	80 91 13 06 	lds	r24, 0x0613	; 0x800613 <xSchedulerRunning>
    1550:	81 11       	cpse	r24, r1
    1552:	0c c0       	rjmp	.+24     	; 0x156c <xTaskCreate+0x1a4>
    1554:	e0 91 65 06 	lds	r30, 0x0665	; 0x800665 <pxCurrentTCB>
    1558:	f0 91 66 06 	lds	r31, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    155c:	96 89       	ldd	r25, Z+22	; 0x16
    155e:	8e 89       	ldd	r24, Y+22	; 0x16
    1560:	89 17       	cp	r24, r25
    1562:	20 f0       	brcs	.+8      	; 0x156c <xTaskCreate+0x1a4>
    1564:	d0 93 66 06 	sts	0x0666, r29	; 0x800666 <pxCurrentTCB+0x1>
    1568:	c0 93 65 06 	sts	0x0665, r28	; 0x800665 <pxCurrentTCB>
    156c:	80 91 0f 06 	lds	r24, 0x060F	; 0x80060f <uxTaskNumber>
    1570:	8f 5f       	subi	r24, 0xFF	; 255
    1572:	80 93 0f 06 	sts	0x060F, r24	; 0x80060f <uxTaskNumber>
    1576:	89 a3       	std	Y+33, r24	; 0x21
    1578:	8e 89       	ldd	r24, Y+22	; 0x16
    157a:	90 91 14 06 	lds	r25, 0x0614	; 0x800614 <uxTopReadyPriority>
    157e:	98 17       	cp	r25, r24
    1580:	10 f4       	brcc	.+4      	; 0x1586 <xTaskCreate+0x1be>
    1582:	80 93 14 06 	sts	0x0614, r24	; 0x800614 <uxTopReadyPriority>
    1586:	90 e0       	ldi	r25, 0x00	; 0
    1588:	9c 01       	movw	r18, r24
    158a:	22 0f       	add	r18, r18
    158c:	33 1f       	adc	r19, r19
    158e:	22 0f       	add	r18, r18
    1590:	33 1f       	adc	r19, r19
    1592:	22 0f       	add	r18, r18
    1594:	33 1f       	adc	r19, r19
    1596:	82 0f       	add	r24, r18
    1598:	93 1f       	adc	r25, r19
    159a:	b6 01       	movw	r22, r12
    159c:	8f 5b       	subi	r24, 0xBF	; 191
    159e:	99 4f       	sbci	r25, 0xF9	; 249
    15a0:	0e 94 b7 02 	call	0x56e	; 0x56e <vListInsertEnd>
    15a4:	0f 90       	pop	r0
    15a6:	0f be       	out	0x3f, r0	; 63
    15a8:	80 91 13 06 	lds	r24, 0x0613	; 0x800613 <xSchedulerRunning>
    15ac:	88 23       	and	r24, r24
    15ae:	61 f0       	breq	.+24     	; 0x15c8 <xTaskCreate+0x200>
    15b0:	e0 91 65 06 	lds	r30, 0x0665	; 0x800665 <pxCurrentTCB>
    15b4:	f0 91 66 06 	lds	r31, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    15b8:	96 89       	ldd	r25, Z+22	; 0x16
    15ba:	8e 89       	ldd	r24, Y+22	; 0x16
    15bc:	98 17       	cp	r25, r24
    15be:	30 f4       	brcc	.+12     	; 0x15cc <xTaskCreate+0x204>
    15c0:	0e 94 d5 03 	call	0x7aa	; 0x7aa <vPortYield>
    15c4:	81 e0       	ldi	r24, 0x01	; 1
    15c6:	05 c0       	rjmp	.+10     	; 0x15d2 <xTaskCreate+0x20a>
    15c8:	81 e0       	ldi	r24, 0x01	; 1
    15ca:	03 c0       	rjmp	.+6      	; 0x15d2 <xTaskCreate+0x20a>
    15cc:	81 e0       	ldi	r24, 0x01	; 1
    15ce:	01 c0       	rjmp	.+2      	; 0x15d2 <xTaskCreate+0x20a>
    15d0:	8f ef       	ldi	r24, 0xFF	; 255
    15d2:	df 91       	pop	r29
    15d4:	cf 91       	pop	r28
    15d6:	0f 91       	pop	r16
    15d8:	ff 90       	pop	r15
    15da:	ef 90       	pop	r14
    15dc:	df 90       	pop	r13
    15de:	cf 90       	pop	r12
    15e0:	bf 90       	pop	r11
    15e2:	af 90       	pop	r10
    15e4:	9f 90       	pop	r9
    15e6:	8f 90       	pop	r8
    15e8:	7f 90       	pop	r7
    15ea:	6f 90       	pop	r6
    15ec:	5f 90       	pop	r5
    15ee:	4f 90       	pop	r4
    15f0:	08 95       	ret

000015f2 <vTaskStartScheduler>:
    15f2:	ef 92       	push	r14
    15f4:	ff 92       	push	r15
    15f6:	0f 93       	push	r16
    15f8:	0f 2e       	mov	r0, r31
    15fa:	fb e0       	ldi	r31, 0x0B	; 11
    15fc:	ef 2e       	mov	r14, r31
    15fe:	f6 e0       	ldi	r31, 0x06	; 6
    1600:	ff 2e       	mov	r15, r31
    1602:	f0 2d       	mov	r31, r0
    1604:	00 e0       	ldi	r16, 0x00	; 0
    1606:	20 e0       	ldi	r18, 0x00	; 0
    1608:	30 e0       	ldi	r19, 0x00	; 0
    160a:	45 e5       	ldi	r20, 0x55	; 85
    160c:	50 e0       	ldi	r21, 0x00	; 0
    160e:	62 ec       	ldi	r22, 0xC2	; 194
    1610:	71 e0       	ldi	r23, 0x01	; 1
    1612:	87 e7       	ldi	r24, 0x77	; 119
    1614:	9c e0       	ldi	r25, 0x0C	; 12
    1616:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <xTaskCreate>
    161a:	81 30       	cpi	r24, 0x01	; 1
    161c:	81 f4       	brne	.+32     	; 0x163e <vTaskStartScheduler+0x4c>
    161e:	f8 94       	cli
    1620:	8f ef       	ldi	r24, 0xFF	; 255
    1622:	9f ef       	ldi	r25, 0xFF	; 255
    1624:	90 93 0e 06 	sts	0x060E, r25	; 0x80060e <xNextTaskUnblockTime+0x1>
    1628:	80 93 0d 06 	sts	0x060D, r24	; 0x80060d <xNextTaskUnblockTime>
    162c:	81 e0       	ldi	r24, 0x01	; 1
    162e:	80 93 13 06 	sts	0x0613, r24	; 0x800613 <xSchedulerRunning>
    1632:	10 92 16 06 	sts	0x0616, r1	; 0x800616 <xTickCount+0x1>
    1636:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <xTickCount>
    163a:	0e 94 9b 03 	call	0x736	; 0x736 <xPortStartScheduler>
    163e:	0f 91       	pop	r16
    1640:	ff 90       	pop	r15
    1642:	ef 90       	pop	r14
    1644:	08 95       	ret

00001646 <vTaskSuspendAll>:
    1646:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <uxSchedulerSuspended>
    164a:	8f 5f       	subi	r24, 0xFF	; 255
    164c:	80 93 0a 06 	sts	0x060A, r24	; 0x80060a <uxSchedulerSuspended>
    1650:	08 95       	ret

00001652 <xTaskIncrementTick>:
    1652:	cf 92       	push	r12
    1654:	df 92       	push	r13
    1656:	ef 92       	push	r14
    1658:	ff 92       	push	r15
    165a:	0f 93       	push	r16
    165c:	1f 93       	push	r17
    165e:	cf 93       	push	r28
    1660:	df 93       	push	r29
    1662:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <uxSchedulerSuspended>
    1666:	81 11       	cpse	r24, r1
    1668:	99 c0       	rjmp	.+306    	; 0x179c <xTaskIncrementTick+0x14a>
    166a:	e0 90 15 06 	lds	r14, 0x0615	; 0x800615 <xTickCount>
    166e:	f0 90 16 06 	lds	r15, 0x0616	; 0x800616 <xTickCount+0x1>
    1672:	8f ef       	ldi	r24, 0xFF	; 255
    1674:	e8 1a       	sub	r14, r24
    1676:	f8 0a       	sbc	r15, r24
    1678:	f0 92 16 06 	sts	0x0616, r15	; 0x800616 <xTickCount+0x1>
    167c:	e0 92 15 06 	sts	0x0615, r14	; 0x800615 <xTickCount>
    1680:	e1 14       	cp	r14, r1
    1682:	f1 04       	cpc	r15, r1
    1684:	b9 f4       	brne	.+46     	; 0x16b4 <xTaskIncrementTick+0x62>
    1686:	80 91 2d 06 	lds	r24, 0x062D	; 0x80062d <pxDelayedTaskList>
    168a:	90 91 2e 06 	lds	r25, 0x062E	; 0x80062e <pxDelayedTaskList+0x1>
    168e:	20 91 2b 06 	lds	r18, 0x062B	; 0x80062b <pxOverflowDelayedTaskList>
    1692:	30 91 2c 06 	lds	r19, 0x062C	; 0x80062c <pxOverflowDelayedTaskList+0x1>
    1696:	30 93 2e 06 	sts	0x062E, r19	; 0x80062e <pxDelayedTaskList+0x1>
    169a:	20 93 2d 06 	sts	0x062D, r18	; 0x80062d <pxDelayedTaskList>
    169e:	90 93 2c 06 	sts	0x062C, r25	; 0x80062c <pxOverflowDelayedTaskList+0x1>
    16a2:	80 93 2b 06 	sts	0x062B, r24	; 0x80062b <pxOverflowDelayedTaskList>
    16a6:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <xNumOfOverflows>
    16aa:	8f 5f       	subi	r24, 0xFF	; 255
    16ac:	80 93 10 06 	sts	0x0610, r24	; 0x800610 <xNumOfOverflows>
    16b0:	0e 94 81 09 	call	0x1302	; 0x1302 <prvResetNextTaskUnblockTime>
    16b4:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <xNextTaskUnblockTime>
    16b8:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <xNextTaskUnblockTime+0x1>
    16bc:	e8 16       	cp	r14, r24
    16be:	f9 06       	cpc	r15, r25
    16c0:	10 f4       	brcc	.+4      	; 0x16c6 <xTaskIncrementTick+0x74>
    16c2:	d1 2c       	mov	r13, r1
    16c4:	53 c0       	rjmp	.+166    	; 0x176c <xTaskIncrementTick+0x11a>
    16c6:	d1 2c       	mov	r13, r1
    16c8:	cc 24       	eor	r12, r12
    16ca:	c3 94       	inc	r12
    16cc:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxDelayedTaskList>
    16d0:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxDelayedTaskList+0x1>
    16d4:	80 81       	ld	r24, Z
    16d6:	81 11       	cpse	r24, r1
    16d8:	07 c0       	rjmp	.+14     	; 0x16e8 <xTaskIncrementTick+0x96>
    16da:	8f ef       	ldi	r24, 0xFF	; 255
    16dc:	9f ef       	ldi	r25, 0xFF	; 255
    16de:	90 93 0e 06 	sts	0x060E, r25	; 0x80060e <xNextTaskUnblockTime+0x1>
    16e2:	80 93 0d 06 	sts	0x060D, r24	; 0x80060d <xNextTaskUnblockTime>
    16e6:	42 c0       	rjmp	.+132    	; 0x176c <xTaskIncrementTick+0x11a>
    16e8:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxDelayedTaskList>
    16ec:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxDelayedTaskList+0x1>
    16f0:	05 80       	ldd	r0, Z+5	; 0x05
    16f2:	f6 81       	ldd	r31, Z+6	; 0x06
    16f4:	e0 2d       	mov	r30, r0
    16f6:	c6 81       	ldd	r28, Z+6	; 0x06
    16f8:	d7 81       	ldd	r29, Z+7	; 0x07
    16fa:	8a 81       	ldd	r24, Y+2	; 0x02
    16fc:	9b 81       	ldd	r25, Y+3	; 0x03
    16fe:	e8 16       	cp	r14, r24
    1700:	f9 06       	cpc	r15, r25
    1702:	28 f4       	brcc	.+10     	; 0x170e <xTaskIncrementTick+0xbc>
    1704:	90 93 0e 06 	sts	0x060E, r25	; 0x80060e <xNextTaskUnblockTime+0x1>
    1708:	80 93 0d 06 	sts	0x060D, r24	; 0x80060d <xNextTaskUnblockTime>
    170c:	2f c0       	rjmp	.+94     	; 0x176c <xTaskIncrementTick+0x11a>
    170e:	8e 01       	movw	r16, r28
    1710:	0e 5f       	subi	r16, 0xFE	; 254
    1712:	1f 4f       	sbci	r17, 0xFF	; 255
    1714:	c8 01       	movw	r24, r16
    1716:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    171a:	8c 89       	ldd	r24, Y+20	; 0x14
    171c:	9d 89       	ldd	r25, Y+21	; 0x15
    171e:	89 2b       	or	r24, r25
    1720:	21 f0       	breq	.+8      	; 0x172a <xTaskIncrementTick+0xd8>
    1722:	ce 01       	movw	r24, r28
    1724:	0c 96       	adiw	r24, 0x0c	; 12
    1726:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    172a:	8e 89       	ldd	r24, Y+22	; 0x16
    172c:	90 91 14 06 	lds	r25, 0x0614	; 0x800614 <uxTopReadyPriority>
    1730:	98 17       	cp	r25, r24
    1732:	10 f4       	brcc	.+4      	; 0x1738 <xTaskIncrementTick+0xe6>
    1734:	80 93 14 06 	sts	0x0614, r24	; 0x800614 <uxTopReadyPriority>
    1738:	90 e0       	ldi	r25, 0x00	; 0
    173a:	9c 01       	movw	r18, r24
    173c:	22 0f       	add	r18, r18
    173e:	33 1f       	adc	r19, r19
    1740:	22 0f       	add	r18, r18
    1742:	33 1f       	adc	r19, r19
    1744:	22 0f       	add	r18, r18
    1746:	33 1f       	adc	r19, r19
    1748:	82 0f       	add	r24, r18
    174a:	93 1f       	adc	r25, r19
    174c:	b8 01       	movw	r22, r16
    174e:	8f 5b       	subi	r24, 0xBF	; 191
    1750:	99 4f       	sbci	r25, 0xF9	; 249
    1752:	0e 94 b7 02 	call	0x56e	; 0x56e <vListInsertEnd>
    1756:	e0 91 65 06 	lds	r30, 0x0665	; 0x800665 <pxCurrentTCB>
    175a:	f0 91 66 06 	lds	r31, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    175e:	9e 89       	ldd	r25, Y+22	; 0x16
    1760:	86 89       	ldd	r24, Z+22	; 0x16
    1762:	98 17       	cp	r25, r24
    1764:	08 f4       	brcc	.+2      	; 0x1768 <xTaskIncrementTick+0x116>
    1766:	b2 cf       	rjmp	.-156    	; 0x16cc <xTaskIncrementTick+0x7a>
    1768:	dc 2c       	mov	r13, r12
    176a:	b0 cf       	rjmp	.-160    	; 0x16cc <xTaskIncrementTick+0x7a>
    176c:	e0 91 65 06 	lds	r30, 0x0665	; 0x800665 <pxCurrentTCB>
    1770:	f0 91 66 06 	lds	r31, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    1774:	86 89       	ldd	r24, Z+22	; 0x16
    1776:	90 e0       	ldi	r25, 0x00	; 0
    1778:	fc 01       	movw	r30, r24
    177a:	ee 0f       	add	r30, r30
    177c:	ff 1f       	adc	r31, r31
    177e:	ee 0f       	add	r30, r30
    1780:	ff 1f       	adc	r31, r31
    1782:	ee 0f       	add	r30, r30
    1784:	ff 1f       	adc	r31, r31
    1786:	8e 0f       	add	r24, r30
    1788:	9f 1f       	adc	r25, r31
    178a:	fc 01       	movw	r30, r24
    178c:	ef 5b       	subi	r30, 0xBF	; 191
    178e:	f9 4f       	sbci	r31, 0xF9	; 249
    1790:	80 81       	ld	r24, Z
    1792:	82 30       	cpi	r24, 0x02	; 2
    1794:	48 f0       	brcs	.+18     	; 0x17a8 <xTaskIncrementTick+0x156>
    1796:	dd 24       	eor	r13, r13
    1798:	d3 94       	inc	r13
    179a:	06 c0       	rjmp	.+12     	; 0x17a8 <xTaskIncrementTick+0x156>
    179c:	80 91 12 06 	lds	r24, 0x0612	; 0x800612 <uxPendedTicks>
    17a0:	8f 5f       	subi	r24, 0xFF	; 255
    17a2:	80 93 12 06 	sts	0x0612, r24	; 0x800612 <uxPendedTicks>
    17a6:	d1 2c       	mov	r13, r1
    17a8:	80 91 11 06 	lds	r24, 0x0611	; 0x800611 <xYieldPending>
    17ac:	88 23       	and	r24, r24
    17ae:	11 f0       	breq	.+4      	; 0x17b4 <xTaskIncrementTick+0x162>
    17b0:	dd 24       	eor	r13, r13
    17b2:	d3 94       	inc	r13
    17b4:	8d 2d       	mov	r24, r13
    17b6:	df 91       	pop	r29
    17b8:	cf 91       	pop	r28
    17ba:	1f 91       	pop	r17
    17bc:	0f 91       	pop	r16
    17be:	ff 90       	pop	r15
    17c0:	ef 90       	pop	r14
    17c2:	df 90       	pop	r13
    17c4:	cf 90       	pop	r12
    17c6:	08 95       	ret

000017c8 <xTaskResumeAll>:
    17c8:	df 92       	push	r13
    17ca:	ef 92       	push	r14
    17cc:	ff 92       	push	r15
    17ce:	0f 93       	push	r16
    17d0:	1f 93       	push	r17
    17d2:	cf 93       	push	r28
    17d4:	df 93       	push	r29
    17d6:	0f b6       	in	r0, 0x3f	; 63
    17d8:	f8 94       	cli
    17da:	0f 92       	push	r0
    17dc:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <uxSchedulerSuspended>
    17e0:	81 50       	subi	r24, 0x01	; 1
    17e2:	80 93 0a 06 	sts	0x060A, r24	; 0x80060a <uxSchedulerSuspended>
    17e6:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <uxSchedulerSuspended>
    17ea:	81 11       	cpse	r24, r1
    17ec:	5f c0       	rjmp	.+190    	; 0x18ac <xTaskResumeAll+0xe4>
    17ee:	80 91 17 06 	lds	r24, 0x0617	; 0x800617 <uxCurrentNumberOfTasks>
    17f2:	81 11       	cpse	r24, r1
    17f4:	33 c0       	rjmp	.+102    	; 0x185c <xTaskResumeAll+0x94>
    17f6:	5d c0       	rjmp	.+186    	; 0x18b2 <xTaskResumeAll+0xea>
    17f8:	d7 01       	movw	r26, r14
    17fa:	15 96       	adiw	r26, 0x05	; 5
    17fc:	ed 91       	ld	r30, X+
    17fe:	fc 91       	ld	r31, X
    1800:	16 97       	sbiw	r26, 0x06	; 6
    1802:	c6 81       	ldd	r28, Z+6	; 0x06
    1804:	d7 81       	ldd	r29, Z+7	; 0x07
    1806:	ce 01       	movw	r24, r28
    1808:	0c 96       	adiw	r24, 0x0c	; 12
    180a:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    180e:	8e 01       	movw	r16, r28
    1810:	0e 5f       	subi	r16, 0xFE	; 254
    1812:	1f 4f       	sbci	r17, 0xFF	; 255
    1814:	c8 01       	movw	r24, r16
    1816:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    181a:	8e 89       	ldd	r24, Y+22	; 0x16
    181c:	90 91 14 06 	lds	r25, 0x0614	; 0x800614 <uxTopReadyPriority>
    1820:	98 17       	cp	r25, r24
    1822:	10 f4       	brcc	.+4      	; 0x1828 <xTaskResumeAll+0x60>
    1824:	80 93 14 06 	sts	0x0614, r24	; 0x800614 <uxTopReadyPriority>
    1828:	90 e0       	ldi	r25, 0x00	; 0
    182a:	9c 01       	movw	r18, r24
    182c:	22 0f       	add	r18, r18
    182e:	33 1f       	adc	r19, r19
    1830:	22 0f       	add	r18, r18
    1832:	33 1f       	adc	r19, r19
    1834:	22 0f       	add	r18, r18
    1836:	33 1f       	adc	r19, r19
    1838:	82 0f       	add	r24, r18
    183a:	93 1f       	adc	r25, r19
    183c:	b8 01       	movw	r22, r16
    183e:	8f 5b       	subi	r24, 0xBF	; 191
    1840:	99 4f       	sbci	r25, 0xF9	; 249
    1842:	0e 94 b7 02 	call	0x56e	; 0x56e <vListInsertEnd>
    1846:	e0 91 65 06 	lds	r30, 0x0665	; 0x800665 <pxCurrentTCB>
    184a:	f0 91 66 06 	lds	r31, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    184e:	9e 89       	ldd	r25, Y+22	; 0x16
    1850:	86 89       	ldd	r24, Z+22	; 0x16
    1852:	98 17       	cp	r25, r24
    1854:	68 f0       	brcs	.+26     	; 0x1870 <xTaskResumeAll+0xa8>
    1856:	d0 92 11 06 	sts	0x0611, r13	; 0x800611 <xYieldPending>
    185a:	0a c0       	rjmp	.+20     	; 0x1870 <xTaskResumeAll+0xa8>
    185c:	c0 e0       	ldi	r28, 0x00	; 0
    185e:	d0 e0       	ldi	r29, 0x00	; 0
    1860:	0f 2e       	mov	r0, r31
    1862:	f2 e2       	ldi	r31, 0x22	; 34
    1864:	ef 2e       	mov	r14, r31
    1866:	f6 e0       	ldi	r31, 0x06	; 6
    1868:	ff 2e       	mov	r15, r31
    186a:	f0 2d       	mov	r31, r0
    186c:	dd 24       	eor	r13, r13
    186e:	d3 94       	inc	r13
    1870:	f7 01       	movw	r30, r14
    1872:	80 81       	ld	r24, Z
    1874:	81 11       	cpse	r24, r1
    1876:	c0 cf       	rjmp	.-128    	; 0x17f8 <xTaskResumeAll+0x30>
    1878:	cd 2b       	or	r28, r29
    187a:	11 f0       	breq	.+4      	; 0x1880 <xTaskResumeAll+0xb8>
    187c:	0e 94 81 09 	call	0x1302	; 0x1302 <prvResetNextTaskUnblockTime>
    1880:	c0 91 12 06 	lds	r28, 0x0612	; 0x800612 <uxPendedTicks>
    1884:	cc 23       	and	r28, r28
    1886:	51 f0       	breq	.+20     	; 0x189c <xTaskResumeAll+0xd4>
    1888:	d1 e0       	ldi	r29, 0x01	; 1
    188a:	0e 94 29 0b 	call	0x1652	; 0x1652 <xTaskIncrementTick>
    188e:	81 11       	cpse	r24, r1
    1890:	d0 93 11 06 	sts	0x0611, r29	; 0x800611 <xYieldPending>
    1894:	c1 50       	subi	r28, 0x01	; 1
    1896:	c9 f7       	brne	.-14     	; 0x188a <xTaskResumeAll+0xc2>
    1898:	10 92 12 06 	sts	0x0612, r1	; 0x800612 <uxPendedTicks>
    189c:	80 91 11 06 	lds	r24, 0x0611	; 0x800611 <xYieldPending>
    18a0:	88 23       	and	r24, r24
    18a2:	31 f0       	breq	.+12     	; 0x18b0 <xTaskResumeAll+0xe8>
    18a4:	0e 94 d5 03 	call	0x7aa	; 0x7aa <vPortYield>
    18a8:	81 e0       	ldi	r24, 0x01	; 1
    18aa:	03 c0       	rjmp	.+6      	; 0x18b2 <xTaskResumeAll+0xea>
    18ac:	80 e0       	ldi	r24, 0x00	; 0
    18ae:	01 c0       	rjmp	.+2      	; 0x18b2 <xTaskResumeAll+0xea>
    18b0:	80 e0       	ldi	r24, 0x00	; 0
    18b2:	0f 90       	pop	r0
    18b4:	0f be       	out	0x3f, r0	; 63
    18b6:	df 91       	pop	r29
    18b8:	cf 91       	pop	r28
    18ba:	1f 91       	pop	r17
    18bc:	0f 91       	pop	r16
    18be:	ff 90       	pop	r15
    18c0:	ef 90       	pop	r14
    18c2:	df 90       	pop	r13
    18c4:	08 95       	ret

000018c6 <vTaskDelay>:
    18c6:	cf 93       	push	r28
    18c8:	df 93       	push	r29
    18ca:	ec 01       	movw	r28, r24
    18cc:	89 2b       	or	r24, r25
    18ce:	51 f0       	breq	.+20     	; 0x18e4 <vTaskDelay+0x1e>
    18d0:	0e 94 23 0b 	call	0x1646	; 0x1646 <vTaskSuspendAll>
    18d4:	60 e0       	ldi	r22, 0x00	; 0
    18d6:	ce 01       	movw	r24, r28
    18d8:	0e 94 a0 09 	call	0x1340	; 0x1340 <prvAddCurrentTaskToDelayedList>
    18dc:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <xTaskResumeAll>
    18e0:	81 11       	cpse	r24, r1
    18e2:	02 c0       	rjmp	.+4      	; 0x18e8 <vTaskDelay+0x22>
    18e4:	0e 94 d5 03 	call	0x7aa	; 0x7aa <vPortYield>
    18e8:	df 91       	pop	r29
    18ea:	cf 91       	pop	r28
    18ec:	08 95       	ret

000018ee <prvIdleTask>:
    18ee:	09 e1       	ldi	r16, 0x19	; 25
    18f0:	16 e0       	ldi	r17, 0x06	; 6
    18f2:	0f 2e       	mov	r0, r31
    18f4:	f1 e4       	ldi	r31, 0x41	; 65
    18f6:	ef 2e       	mov	r14, r31
    18f8:	f6 e0       	ldi	r31, 0x06	; 6
    18fa:	ff 2e       	mov	r15, r31
    18fc:	f0 2d       	mov	r31, r0
    18fe:	29 c0       	rjmp	.+82     	; 0x1952 <prvIdleTask+0x64>
    1900:	0e 94 23 0b 	call	0x1646	; 0x1646 <vTaskSuspendAll>
    1904:	d8 01       	movw	r26, r16
    1906:	cc 91       	ld	r28, X
    1908:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <xTaskResumeAll>
    190c:	cc 23       	and	r28, r28
    190e:	09 f1       	breq	.+66     	; 0x1952 <prvIdleTask+0x64>
    1910:	0f b6       	in	r0, 0x3f	; 63
    1912:	f8 94       	cli
    1914:	0f 92       	push	r0
    1916:	d8 01       	movw	r26, r16
    1918:	15 96       	adiw	r26, 0x05	; 5
    191a:	ed 91       	ld	r30, X+
    191c:	fc 91       	ld	r31, X
    191e:	16 97       	sbiw	r26, 0x06	; 6
    1920:	c6 81       	ldd	r28, Z+6	; 0x06
    1922:	d7 81       	ldd	r29, Z+7	; 0x07
    1924:	ce 01       	movw	r24, r28
    1926:	02 96       	adiw	r24, 0x02	; 2
    1928:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    192c:	80 91 17 06 	lds	r24, 0x0617	; 0x800617 <uxCurrentNumberOfTasks>
    1930:	81 50       	subi	r24, 0x01	; 1
    1932:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <uxCurrentNumberOfTasks>
    1936:	80 91 18 06 	lds	r24, 0x0618	; 0x800618 <uxDeletedTasksWaitingCleanUp>
    193a:	81 50       	subi	r24, 0x01	; 1
    193c:	80 93 18 06 	sts	0x0618, r24	; 0x800618 <uxDeletedTasksWaitingCleanUp>
    1940:	0f 90       	pop	r0
    1942:	0f be       	out	0x3f, r0	; 63
    1944:	8f 89       	ldd	r24, Y+23	; 0x17
    1946:	98 8d       	ldd	r25, Y+24	; 0x18
    1948:	0e 94 c2 04 	call	0x984	; 0x984 <vPortFree>
    194c:	ce 01       	movw	r24, r28
    194e:	0e 94 c2 04 	call	0x984	; 0x984 <vPortFree>
    1952:	80 91 18 06 	lds	r24, 0x0618	; 0x800618 <uxDeletedTasksWaitingCleanUp>
    1956:	81 11       	cpse	r24, r1
    1958:	d3 cf       	rjmp	.-90     	; 0x1900 <prvIdleTask+0x12>
    195a:	f7 01       	movw	r30, r14
    195c:	80 81       	ld	r24, Z
    195e:	82 30       	cpi	r24, 0x02	; 2
    1960:	10 f0       	brcs	.+4      	; 0x1966 <prvIdleTask+0x78>
    1962:	0e 94 d5 03 	call	0x7aa	; 0x7aa <vPortYield>
    1966:	0e 94 7e 01 	call	0x2fc	; 0x2fc <vApplicationIdleHook>
    196a:	f3 cf       	rjmp	.-26     	; 0x1952 <prvIdleTask+0x64>

0000196c <vTaskSetApplicationTaskTag>:
    196c:	00 97       	sbiw	r24, 0x00	; 0
    196e:	21 f4       	brne	.+8      	; 0x1978 <vTaskSetApplicationTaskTag+0xc>
    1970:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <pxCurrentTCB>
    1974:	90 91 66 06 	lds	r25, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    1978:	0f b6       	in	r0, 0x3f	; 63
    197a:	f8 94       	cli
    197c:	0f 92       	push	r0
    197e:	fc 01       	movw	r30, r24
    1980:	76 a3       	std	Z+38, r23	; 0x26
    1982:	65 a3       	std	Z+37, r22	; 0x25
    1984:	0f 90       	pop	r0
    1986:	0f be       	out	0x3f, r0	; 63
    1988:	08 95       	ret

0000198a <vTaskSwitchContext>:
    198a:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <uxSchedulerSuspended>
    198e:	88 23       	and	r24, r24
    1990:	21 f0       	breq	.+8      	; 0x199a <vTaskSwitchContext+0x10>
    1992:	81 e0       	ldi	r24, 0x01	; 1
    1994:	80 93 11 06 	sts	0x0611, r24	; 0x800611 <xYieldPending>
    1998:	08 95       	ret
    199a:	10 92 11 06 	sts	0x0611, r1	; 0x800611 <xYieldPending>
    199e:	e0 91 65 06 	lds	r30, 0x0665	; 0x800665 <pxCurrentTCB>
    19a2:	f0 91 66 06 	lds	r31, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    19a6:	85 a1       	ldd	r24, Z+37	; 0x25
    19a8:	0e 94 5e 02 	call	0x4bc	; 0x4bc <switch_out>
    19ac:	20 91 14 06 	lds	r18, 0x0614	; 0x800614 <uxTopReadyPriority>
    19b0:	82 2f       	mov	r24, r18
    19b2:	90 e0       	ldi	r25, 0x00	; 0
    19b4:	fc 01       	movw	r30, r24
    19b6:	ee 0f       	add	r30, r30
    19b8:	ff 1f       	adc	r31, r31
    19ba:	ee 0f       	add	r30, r30
    19bc:	ff 1f       	adc	r31, r31
    19be:	ee 0f       	add	r30, r30
    19c0:	ff 1f       	adc	r31, r31
    19c2:	e8 0f       	add	r30, r24
    19c4:	f9 1f       	adc	r31, r25
    19c6:	ef 5b       	subi	r30, 0xBF	; 191
    19c8:	f9 4f       	sbci	r31, 0xF9	; 249
    19ca:	30 81       	ld	r19, Z
    19cc:	31 11       	cpse	r19, r1
    19ce:	11 c0       	rjmp	.+34     	; 0x19f2 <vTaskSwitchContext+0x68>
    19d0:	21 50       	subi	r18, 0x01	; 1
    19d2:	82 2f       	mov	r24, r18
    19d4:	90 e0       	ldi	r25, 0x00	; 0
    19d6:	fc 01       	movw	r30, r24
    19d8:	ee 0f       	add	r30, r30
    19da:	ff 1f       	adc	r31, r31
    19dc:	ee 0f       	add	r30, r30
    19de:	ff 1f       	adc	r31, r31
    19e0:	ee 0f       	add	r30, r30
    19e2:	ff 1f       	adc	r31, r31
    19e4:	e8 0f       	add	r30, r24
    19e6:	f9 1f       	adc	r31, r25
    19e8:	ef 5b       	subi	r30, 0xBF	; 191
    19ea:	f9 4f       	sbci	r31, 0xF9	; 249
    19ec:	30 81       	ld	r19, Z
    19ee:	33 23       	and	r19, r19
    19f0:	79 f3       	breq	.-34     	; 0x19d0 <vTaskSwitchContext+0x46>
    19f2:	ac 01       	movw	r20, r24
    19f4:	44 0f       	add	r20, r20
    19f6:	55 1f       	adc	r21, r21
    19f8:	44 0f       	add	r20, r20
    19fa:	55 1f       	adc	r21, r21
    19fc:	44 0f       	add	r20, r20
    19fe:	55 1f       	adc	r21, r21
    1a00:	48 0f       	add	r20, r24
    1a02:	59 1f       	adc	r21, r25
    1a04:	da 01       	movw	r26, r20
    1a06:	af 5b       	subi	r26, 0xBF	; 191
    1a08:	b9 4f       	sbci	r27, 0xF9	; 249
    1a0a:	11 96       	adiw	r26, 0x01	; 1
    1a0c:	ed 91       	ld	r30, X+
    1a0e:	fc 91       	ld	r31, X
    1a10:	12 97       	sbiw	r26, 0x02	; 2
    1a12:	02 80       	ldd	r0, Z+2	; 0x02
    1a14:	f3 81       	ldd	r31, Z+3	; 0x03
    1a16:	e0 2d       	mov	r30, r0
    1a18:	12 96       	adiw	r26, 0x02	; 2
    1a1a:	fc 93       	st	X, r31
    1a1c:	ee 93       	st	-X, r30
    1a1e:	11 97       	sbiw	r26, 0x01	; 1
    1a20:	4c 5b       	subi	r20, 0xBC	; 188
    1a22:	59 4f       	sbci	r21, 0xF9	; 249
    1a24:	e4 17       	cp	r30, r20
    1a26:	f5 07       	cpc	r31, r21
    1a28:	29 f4       	brne	.+10     	; 0x1a34 <vTaskSwitchContext+0xaa>
    1a2a:	42 81       	ldd	r20, Z+2	; 0x02
    1a2c:	53 81       	ldd	r21, Z+3	; 0x03
    1a2e:	fd 01       	movw	r30, r26
    1a30:	52 83       	std	Z+2, r21	; 0x02
    1a32:	41 83       	std	Z+1, r20	; 0x01
    1a34:	fc 01       	movw	r30, r24
    1a36:	ee 0f       	add	r30, r30
    1a38:	ff 1f       	adc	r31, r31
    1a3a:	ee 0f       	add	r30, r30
    1a3c:	ff 1f       	adc	r31, r31
    1a3e:	ee 0f       	add	r30, r30
    1a40:	ff 1f       	adc	r31, r31
    1a42:	8e 0f       	add	r24, r30
    1a44:	9f 1f       	adc	r25, r31
    1a46:	fc 01       	movw	r30, r24
    1a48:	ef 5b       	subi	r30, 0xBF	; 191
    1a4a:	f9 4f       	sbci	r31, 0xF9	; 249
    1a4c:	01 80       	ldd	r0, Z+1	; 0x01
    1a4e:	f2 81       	ldd	r31, Z+2	; 0x02
    1a50:	e0 2d       	mov	r30, r0
    1a52:	86 81       	ldd	r24, Z+6	; 0x06
    1a54:	97 81       	ldd	r25, Z+7	; 0x07
    1a56:	90 93 66 06 	sts	0x0666, r25	; 0x800666 <pxCurrentTCB+0x1>
    1a5a:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <pxCurrentTCB>
    1a5e:	20 93 14 06 	sts	0x0614, r18	; 0x800614 <uxTopReadyPriority>
    1a62:	e0 91 65 06 	lds	r30, 0x0665	; 0x800665 <pxCurrentTCB>
    1a66:	f0 91 66 06 	lds	r31, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    1a6a:	85 a1       	ldd	r24, Z+37	; 0x25
    1a6c:	0e 94 53 02 	call	0x4a6	; 0x4a6 <switch_in>
    1a70:	08 95       	ret

00001a72 <vTaskPlaceOnEventList>:
    1a72:	cf 93       	push	r28
    1a74:	df 93       	push	r29
    1a76:	eb 01       	movw	r28, r22
    1a78:	60 91 65 06 	lds	r22, 0x0665	; 0x800665 <pxCurrentTCB>
    1a7c:	70 91 66 06 	lds	r23, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    1a80:	64 5f       	subi	r22, 0xF4	; 244
    1a82:	7f 4f       	sbci	r23, 0xFF	; 255
    1a84:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <vListInsert>
    1a88:	61 e0       	ldi	r22, 0x01	; 1
    1a8a:	ce 01       	movw	r24, r28
    1a8c:	0e 94 a0 09 	call	0x1340	; 0x1340 <prvAddCurrentTaskToDelayedList>
    1a90:	df 91       	pop	r29
    1a92:	cf 91       	pop	r28
    1a94:	08 95       	ret

00001a96 <xTaskRemoveFromEventList>:
    1a96:	0f 93       	push	r16
    1a98:	1f 93       	push	r17
    1a9a:	cf 93       	push	r28
    1a9c:	df 93       	push	r29
    1a9e:	dc 01       	movw	r26, r24
    1aa0:	15 96       	adiw	r26, 0x05	; 5
    1aa2:	ed 91       	ld	r30, X+
    1aa4:	fc 91       	ld	r31, X
    1aa6:	16 97       	sbiw	r26, 0x06	; 6
    1aa8:	c6 81       	ldd	r28, Z+6	; 0x06
    1aaa:	d7 81       	ldd	r29, Z+7	; 0x07
    1aac:	8e 01       	movw	r16, r28
    1aae:	04 5f       	subi	r16, 0xF4	; 244
    1ab0:	1f 4f       	sbci	r17, 0xFF	; 255
    1ab2:	c8 01       	movw	r24, r16
    1ab4:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    1ab8:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <uxSchedulerSuspended>
    1abc:	81 11       	cpse	r24, r1
    1abe:	1c c0       	rjmp	.+56     	; 0x1af8 <xTaskRemoveFromEventList+0x62>
    1ac0:	0a 50       	subi	r16, 0x0A	; 10
    1ac2:	11 09       	sbc	r17, r1
    1ac4:	c8 01       	movw	r24, r16
    1ac6:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    1aca:	8e 89       	ldd	r24, Y+22	; 0x16
    1acc:	90 91 14 06 	lds	r25, 0x0614	; 0x800614 <uxTopReadyPriority>
    1ad0:	98 17       	cp	r25, r24
    1ad2:	10 f4       	brcc	.+4      	; 0x1ad8 <xTaskRemoveFromEventList+0x42>
    1ad4:	80 93 14 06 	sts	0x0614, r24	; 0x800614 <uxTopReadyPriority>
    1ad8:	90 e0       	ldi	r25, 0x00	; 0
    1ada:	9c 01       	movw	r18, r24
    1adc:	22 0f       	add	r18, r18
    1ade:	33 1f       	adc	r19, r19
    1ae0:	22 0f       	add	r18, r18
    1ae2:	33 1f       	adc	r19, r19
    1ae4:	22 0f       	add	r18, r18
    1ae6:	33 1f       	adc	r19, r19
    1ae8:	82 0f       	add	r24, r18
    1aea:	93 1f       	adc	r25, r19
    1aec:	b8 01       	movw	r22, r16
    1aee:	8f 5b       	subi	r24, 0xBF	; 191
    1af0:	99 4f       	sbci	r25, 0xF9	; 249
    1af2:	0e 94 b7 02 	call	0x56e	; 0x56e <vListInsertEnd>
    1af6:	05 c0       	rjmp	.+10     	; 0x1b02 <xTaskRemoveFromEventList+0x6c>
    1af8:	b8 01       	movw	r22, r16
    1afa:	82 e2       	ldi	r24, 0x22	; 34
    1afc:	96 e0       	ldi	r25, 0x06	; 6
    1afe:	0e 94 b7 02 	call	0x56e	; 0x56e <vListInsertEnd>
    1b02:	e0 91 65 06 	lds	r30, 0x0665	; 0x800665 <pxCurrentTCB>
    1b06:	f0 91 66 06 	lds	r31, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    1b0a:	9e 89       	ldd	r25, Y+22	; 0x16
    1b0c:	86 89       	ldd	r24, Z+22	; 0x16
    1b0e:	89 17       	cp	r24, r25
    1b10:	20 f4       	brcc	.+8      	; 0x1b1a <xTaskRemoveFromEventList+0x84>
    1b12:	81 e0       	ldi	r24, 0x01	; 1
    1b14:	80 93 11 06 	sts	0x0611, r24	; 0x800611 <xYieldPending>
    1b18:	01 c0       	rjmp	.+2      	; 0x1b1c <xTaskRemoveFromEventList+0x86>
    1b1a:	80 e0       	ldi	r24, 0x00	; 0
    1b1c:	df 91       	pop	r29
    1b1e:	cf 91       	pop	r28
    1b20:	1f 91       	pop	r17
    1b22:	0f 91       	pop	r16
    1b24:	08 95       	ret

00001b26 <vTaskSetTimeOutState>:
    1b26:	20 91 10 06 	lds	r18, 0x0610	; 0x800610 <xNumOfOverflows>
    1b2a:	fc 01       	movw	r30, r24
    1b2c:	20 83       	st	Z, r18
    1b2e:	20 91 15 06 	lds	r18, 0x0615	; 0x800615 <xTickCount>
    1b32:	30 91 16 06 	lds	r19, 0x0616	; 0x800616 <xTickCount+0x1>
    1b36:	32 83       	std	Z+2, r19	; 0x02
    1b38:	21 83       	std	Z+1, r18	; 0x01
    1b3a:	08 95       	ret

00001b3c <xTaskCheckForTimeOut>:
    1b3c:	cf 93       	push	r28
    1b3e:	df 93       	push	r29
    1b40:	fc 01       	movw	r30, r24
    1b42:	0f b6       	in	r0, 0x3f	; 63
    1b44:	f8 94       	cli
    1b46:	0f 92       	push	r0
    1b48:	20 91 15 06 	lds	r18, 0x0615	; 0x800615 <xTickCount>
    1b4c:	30 91 16 06 	lds	r19, 0x0616	; 0x800616 <xTickCount+0x1>
    1b50:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <xNumOfOverflows>
    1b54:	90 81       	ld	r25, Z
    1b56:	98 17       	cp	r25, r24
    1b58:	29 f0       	breq	.+10     	; 0x1b64 <xTaskCheckForTimeOut+0x28>
    1b5a:	81 81       	ldd	r24, Z+1	; 0x01
    1b5c:	92 81       	ldd	r25, Z+2	; 0x02
    1b5e:	28 17       	cp	r18, r24
    1b60:	39 07       	cpc	r19, r25
    1b62:	b0 f4       	brcc	.+44     	; 0x1b90 <xTaskCheckForTimeOut+0x54>
    1b64:	a1 81       	ldd	r26, Z+1	; 0x01
    1b66:	b2 81       	ldd	r27, Z+2	; 0x02
    1b68:	eb 01       	movw	r28, r22
    1b6a:	48 81       	ld	r20, Y
    1b6c:	59 81       	ldd	r21, Y+1	; 0x01
    1b6e:	c9 01       	movw	r24, r18
    1b70:	8a 1b       	sub	r24, r26
    1b72:	9b 0b       	sbc	r25, r27
    1b74:	84 17       	cp	r24, r20
    1b76:	95 07       	cpc	r25, r21
    1b78:	68 f4       	brcc	.+26     	; 0x1b94 <xTaskCheckForTimeOut+0x58>
    1b7a:	cf 01       	movw	r24, r30
    1b7c:	a2 1b       	sub	r26, r18
    1b7e:	b3 0b       	sbc	r27, r19
    1b80:	4a 0f       	add	r20, r26
    1b82:	5b 1f       	adc	r21, r27
    1b84:	59 83       	std	Y+1, r21	; 0x01
    1b86:	48 83       	st	Y, r20
    1b88:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <vTaskSetTimeOutState>
    1b8c:	80 e0       	ldi	r24, 0x00	; 0
    1b8e:	03 c0       	rjmp	.+6      	; 0x1b96 <xTaskCheckForTimeOut+0x5a>
    1b90:	81 e0       	ldi	r24, 0x01	; 1
    1b92:	01 c0       	rjmp	.+2      	; 0x1b96 <xTaskCheckForTimeOut+0x5a>
    1b94:	81 e0       	ldi	r24, 0x01	; 1
    1b96:	0f 90       	pop	r0
    1b98:	0f be       	out	0x3f, r0	; 63
    1b9a:	df 91       	pop	r29
    1b9c:	cf 91       	pop	r28
    1b9e:	08 95       	ret

00001ba0 <vTaskMissedYield>:
    1ba0:	81 e0       	ldi	r24, 0x01	; 1
    1ba2:	80 93 11 06 	sts	0x0611, r24	; 0x800611 <xYieldPending>
    1ba6:	08 95       	ret

00001ba8 <vTaskPriorityInherit>:
    1ba8:	0f 93       	push	r16
    1baa:	1f 93       	push	r17
    1bac:	cf 93       	push	r28
    1bae:	df 93       	push	r29
    1bb0:	fc 01       	movw	r30, r24
    1bb2:	89 2b       	or	r24, r25
    1bb4:	09 f4       	brne	.+2      	; 0x1bb8 <vTaskPriorityInherit+0x10>
    1bb6:	55 c0       	rjmp	.+170    	; 0x1c62 <vTaskPriorityInherit+0xba>
    1bb8:	26 89       	ldd	r18, Z+22	; 0x16
    1bba:	a0 91 65 06 	lds	r26, 0x0665	; 0x800665 <pxCurrentTCB>
    1bbe:	b0 91 66 06 	lds	r27, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    1bc2:	56 96       	adiw	r26, 0x16	; 22
    1bc4:	8c 91       	ld	r24, X
    1bc6:	28 17       	cp	r18, r24
    1bc8:	08 f0       	brcs	.+2      	; 0x1bcc <vTaskPriorityInherit+0x24>
    1bca:	4b c0       	rjmp	.+150    	; 0x1c62 <vTaskPriorityInherit+0xba>
    1bcc:	84 85       	ldd	r24, Z+12	; 0x0c
    1bce:	95 85       	ldd	r25, Z+13	; 0x0d
    1bd0:	99 23       	and	r25, r25
    1bd2:	64 f0       	brlt	.+24     	; 0x1bec <vTaskPriorityInherit+0x44>
    1bd4:	a0 91 65 06 	lds	r26, 0x0665	; 0x800665 <pxCurrentTCB>
    1bd8:	b0 91 66 06 	lds	r27, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    1bdc:	56 96       	adiw	r26, 0x16	; 22
    1bde:	3c 91       	ld	r19, X
    1be0:	84 e0       	ldi	r24, 0x04	; 4
    1be2:	90 e0       	ldi	r25, 0x00	; 0
    1be4:	83 1b       	sub	r24, r19
    1be6:	91 09       	sbc	r25, r1
    1be8:	95 87       	std	Z+13, r25	; 0x0d
    1bea:	84 87       	std	Z+12, r24	; 0x0c
    1bec:	30 e0       	ldi	r19, 0x00	; 0
    1bee:	c9 01       	movw	r24, r18
    1bf0:	88 0f       	add	r24, r24
    1bf2:	99 1f       	adc	r25, r25
    1bf4:	88 0f       	add	r24, r24
    1bf6:	99 1f       	adc	r25, r25
    1bf8:	88 0f       	add	r24, r24
    1bfa:	99 1f       	adc	r25, r25
    1bfc:	28 0f       	add	r18, r24
    1bfe:	39 1f       	adc	r19, r25
    1c00:	2f 5b       	subi	r18, 0xBF	; 191
    1c02:	39 4f       	sbci	r19, 0xF9	; 249
    1c04:	82 85       	ldd	r24, Z+10	; 0x0a
    1c06:	93 85       	ldd	r25, Z+11	; 0x0b
    1c08:	82 17       	cp	r24, r18
    1c0a:	93 07       	cpc	r25, r19
    1c0c:	19 f5       	brne	.+70     	; 0x1c54 <vTaskPriorityInherit+0xac>
    1c0e:	8f 01       	movw	r16, r30
    1c10:	ef 01       	movw	r28, r30
    1c12:	22 96       	adiw	r28, 0x02	; 2
    1c14:	ce 01       	movw	r24, r28
    1c16:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    1c1a:	e0 91 65 06 	lds	r30, 0x0665	; 0x800665 <pxCurrentTCB>
    1c1e:	f0 91 66 06 	lds	r31, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    1c22:	86 89       	ldd	r24, Z+22	; 0x16
    1c24:	f8 01       	movw	r30, r16
    1c26:	86 8b       	std	Z+22, r24	; 0x16
    1c28:	90 91 14 06 	lds	r25, 0x0614	; 0x800614 <uxTopReadyPriority>
    1c2c:	98 17       	cp	r25, r24
    1c2e:	10 f4       	brcc	.+4      	; 0x1c34 <vTaskPriorityInherit+0x8c>
    1c30:	80 93 14 06 	sts	0x0614, r24	; 0x800614 <uxTopReadyPriority>
    1c34:	90 e0       	ldi	r25, 0x00	; 0
    1c36:	9c 01       	movw	r18, r24
    1c38:	22 0f       	add	r18, r18
    1c3a:	33 1f       	adc	r19, r19
    1c3c:	22 0f       	add	r18, r18
    1c3e:	33 1f       	adc	r19, r19
    1c40:	22 0f       	add	r18, r18
    1c42:	33 1f       	adc	r19, r19
    1c44:	82 0f       	add	r24, r18
    1c46:	93 1f       	adc	r25, r19
    1c48:	be 01       	movw	r22, r28
    1c4a:	8f 5b       	subi	r24, 0xBF	; 191
    1c4c:	99 4f       	sbci	r25, 0xF9	; 249
    1c4e:	0e 94 b7 02 	call	0x56e	; 0x56e <vListInsertEnd>
    1c52:	07 c0       	rjmp	.+14     	; 0x1c62 <vTaskPriorityInherit+0xba>
    1c54:	a0 91 65 06 	lds	r26, 0x0665	; 0x800665 <pxCurrentTCB>
    1c58:	b0 91 66 06 	lds	r27, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    1c5c:	56 96       	adiw	r26, 0x16	; 22
    1c5e:	8c 91       	ld	r24, X
    1c60:	86 8b       	std	Z+22, r24	; 0x16
    1c62:	df 91       	pop	r29
    1c64:	cf 91       	pop	r28
    1c66:	1f 91       	pop	r17
    1c68:	0f 91       	pop	r16
    1c6a:	08 95       	ret

00001c6c <xTaskPriorityDisinherit>:
    1c6c:	0f 93       	push	r16
    1c6e:	1f 93       	push	r17
    1c70:	cf 93       	push	r28
    1c72:	df 93       	push	r29
    1c74:	fc 01       	movw	r30, r24
    1c76:	89 2b       	or	r24, r25
    1c78:	79 f1       	breq	.+94     	; 0x1cd8 <xTaskPriorityDisinherit+0x6c>
    1c7a:	84 a1       	ldd	r24, Z+36	; 0x24
    1c7c:	81 50       	subi	r24, 0x01	; 1
    1c7e:	84 a3       	std	Z+36, r24	; 0x24
    1c80:	26 89       	ldd	r18, Z+22	; 0x16
    1c82:	93 a1       	ldd	r25, Z+35	; 0x23
    1c84:	29 17       	cp	r18, r25
    1c86:	51 f1       	breq	.+84     	; 0x1cdc <xTaskPriorityDisinherit+0x70>
    1c88:	81 11       	cpse	r24, r1
    1c8a:	2a c0       	rjmp	.+84     	; 0x1ce0 <xTaskPriorityDisinherit+0x74>
    1c8c:	ef 01       	movw	r28, r30
    1c8e:	8f 01       	movw	r16, r30
    1c90:	0e 5f       	subi	r16, 0xFE	; 254
    1c92:	1f 4f       	sbci	r17, 0xFF	; 255
    1c94:	c8 01       	movw	r24, r16
    1c96:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    1c9a:	8b a1       	ldd	r24, Y+35	; 0x23
    1c9c:	8e 8b       	std	Y+22, r24	; 0x16
    1c9e:	24 e0       	ldi	r18, 0x04	; 4
    1ca0:	30 e0       	ldi	r19, 0x00	; 0
    1ca2:	28 1b       	sub	r18, r24
    1ca4:	31 09       	sbc	r19, r1
    1ca6:	3d 87       	std	Y+13, r19	; 0x0d
    1ca8:	2c 87       	std	Y+12, r18	; 0x0c
    1caa:	90 91 14 06 	lds	r25, 0x0614	; 0x800614 <uxTopReadyPriority>
    1cae:	98 17       	cp	r25, r24
    1cb0:	10 f4       	brcc	.+4      	; 0x1cb6 <xTaskPriorityDisinherit+0x4a>
    1cb2:	80 93 14 06 	sts	0x0614, r24	; 0x800614 <uxTopReadyPriority>
    1cb6:	90 e0       	ldi	r25, 0x00	; 0
    1cb8:	9c 01       	movw	r18, r24
    1cba:	22 0f       	add	r18, r18
    1cbc:	33 1f       	adc	r19, r19
    1cbe:	22 0f       	add	r18, r18
    1cc0:	33 1f       	adc	r19, r19
    1cc2:	22 0f       	add	r18, r18
    1cc4:	33 1f       	adc	r19, r19
    1cc6:	82 0f       	add	r24, r18
    1cc8:	93 1f       	adc	r25, r19
    1cca:	b8 01       	movw	r22, r16
    1ccc:	8f 5b       	subi	r24, 0xBF	; 191
    1cce:	99 4f       	sbci	r25, 0xF9	; 249
    1cd0:	0e 94 b7 02 	call	0x56e	; 0x56e <vListInsertEnd>
    1cd4:	81 e0       	ldi	r24, 0x01	; 1
    1cd6:	05 c0       	rjmp	.+10     	; 0x1ce2 <xTaskPriorityDisinherit+0x76>
    1cd8:	80 e0       	ldi	r24, 0x00	; 0
    1cda:	03 c0       	rjmp	.+6      	; 0x1ce2 <xTaskPriorityDisinherit+0x76>
    1cdc:	80 e0       	ldi	r24, 0x00	; 0
    1cde:	01 c0       	rjmp	.+2      	; 0x1ce2 <xTaskPriorityDisinherit+0x76>
    1ce0:	80 e0       	ldi	r24, 0x00	; 0
    1ce2:	df 91       	pop	r29
    1ce4:	cf 91       	pop	r28
    1ce6:	1f 91       	pop	r17
    1ce8:	0f 91       	pop	r16
    1cea:	08 95       	ret

00001cec <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1cec:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <pxCurrentTCB>
    1cf0:	90 91 66 06 	lds	r25, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    1cf4:	89 2b       	or	r24, r25
    1cf6:	39 f0       	breq	.+14     	; 0x1d06 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1cf8:	e0 91 65 06 	lds	r30, 0x0665	; 0x800665 <pxCurrentTCB>
    1cfc:	f0 91 66 06 	lds	r31, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
    1d00:	84 a1       	ldd	r24, Z+36	; 0x24
    1d02:	8f 5f       	subi	r24, 0xFF	; 255
    1d04:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    1d06:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <pxCurrentTCB>
    1d0a:	90 91 66 06 	lds	r25, 0x0666	; 0x800666 <pxCurrentTCB+0x1>
	}
    1d0e:	08 95       	ret

00001d10 <__udivmodsi4>:
    1d10:	a1 e2       	ldi	r26, 0x21	; 33
    1d12:	1a 2e       	mov	r1, r26
    1d14:	aa 1b       	sub	r26, r26
    1d16:	bb 1b       	sub	r27, r27
    1d18:	fd 01       	movw	r30, r26
    1d1a:	0d c0       	rjmp	.+26     	; 0x1d36 <__udivmodsi4_ep>

00001d1c <__udivmodsi4_loop>:
    1d1c:	aa 1f       	adc	r26, r26
    1d1e:	bb 1f       	adc	r27, r27
    1d20:	ee 1f       	adc	r30, r30
    1d22:	ff 1f       	adc	r31, r31
    1d24:	a2 17       	cp	r26, r18
    1d26:	b3 07       	cpc	r27, r19
    1d28:	e4 07       	cpc	r30, r20
    1d2a:	f5 07       	cpc	r31, r21
    1d2c:	20 f0       	brcs	.+8      	; 0x1d36 <__udivmodsi4_ep>
    1d2e:	a2 1b       	sub	r26, r18
    1d30:	b3 0b       	sbc	r27, r19
    1d32:	e4 0b       	sbc	r30, r20
    1d34:	f5 0b       	sbc	r31, r21

00001d36 <__udivmodsi4_ep>:
    1d36:	66 1f       	adc	r22, r22
    1d38:	77 1f       	adc	r23, r23
    1d3a:	88 1f       	adc	r24, r24
    1d3c:	99 1f       	adc	r25, r25
    1d3e:	1a 94       	dec	r1
    1d40:	69 f7       	brne	.-38     	; 0x1d1c <__udivmodsi4_loop>
    1d42:	60 95       	com	r22
    1d44:	70 95       	com	r23
    1d46:	80 95       	com	r24
    1d48:	90 95       	com	r25
    1d4a:	9b 01       	movw	r18, r22
    1d4c:	ac 01       	movw	r20, r24
    1d4e:	bd 01       	movw	r22, r26
    1d50:	cf 01       	movw	r24, r30
    1d52:	08 95       	ret

00001d54 <__tablejump2__>:
    1d54:	ee 0f       	add	r30, r30
    1d56:	ff 1f       	adc	r31, r31
    1d58:	05 90       	lpm	r0, Z+
    1d5a:	f4 91       	lpm	r31, Z
    1d5c:	e0 2d       	mov	r30, r0
    1d5e:	09 94       	ijmp

00001d60 <malloc>:
    1d60:	0f 93       	push	r16
    1d62:	1f 93       	push	r17
    1d64:	cf 93       	push	r28
    1d66:	df 93       	push	r29
    1d68:	82 30       	cpi	r24, 0x02	; 2
    1d6a:	91 05       	cpc	r25, r1
    1d6c:	10 f4       	brcc	.+4      	; 0x1d72 <malloc+0x12>
    1d6e:	82 e0       	ldi	r24, 0x02	; 2
    1d70:	90 e0       	ldi	r25, 0x00	; 0
    1d72:	e0 91 69 06 	lds	r30, 0x0669	; 0x800669 <__flp>
    1d76:	f0 91 6a 06 	lds	r31, 0x066A	; 0x80066a <__flp+0x1>
    1d7a:	20 e0       	ldi	r18, 0x00	; 0
    1d7c:	30 e0       	ldi	r19, 0x00	; 0
    1d7e:	a0 e0       	ldi	r26, 0x00	; 0
    1d80:	b0 e0       	ldi	r27, 0x00	; 0
    1d82:	30 97       	sbiw	r30, 0x00	; 0
    1d84:	19 f1       	breq	.+70     	; 0x1dcc <malloc+0x6c>
    1d86:	40 81       	ld	r20, Z
    1d88:	51 81       	ldd	r21, Z+1	; 0x01
    1d8a:	02 81       	ldd	r16, Z+2	; 0x02
    1d8c:	13 81       	ldd	r17, Z+3	; 0x03
    1d8e:	48 17       	cp	r20, r24
    1d90:	59 07       	cpc	r21, r25
    1d92:	c8 f0       	brcs	.+50     	; 0x1dc6 <malloc+0x66>
    1d94:	84 17       	cp	r24, r20
    1d96:	95 07       	cpc	r25, r21
    1d98:	69 f4       	brne	.+26     	; 0x1db4 <malloc+0x54>
    1d9a:	10 97       	sbiw	r26, 0x00	; 0
    1d9c:	31 f0       	breq	.+12     	; 0x1daa <malloc+0x4a>
    1d9e:	12 96       	adiw	r26, 0x02	; 2
    1da0:	0c 93       	st	X, r16
    1da2:	12 97       	sbiw	r26, 0x02	; 2
    1da4:	13 96       	adiw	r26, 0x03	; 3
    1da6:	1c 93       	st	X, r17
    1da8:	27 c0       	rjmp	.+78     	; 0x1df8 <malloc+0x98>
    1daa:	00 93 69 06 	sts	0x0669, r16	; 0x800669 <__flp>
    1dae:	10 93 6a 06 	sts	0x066A, r17	; 0x80066a <__flp+0x1>
    1db2:	22 c0       	rjmp	.+68     	; 0x1df8 <malloc+0x98>
    1db4:	21 15       	cp	r18, r1
    1db6:	31 05       	cpc	r19, r1
    1db8:	19 f0       	breq	.+6      	; 0x1dc0 <malloc+0x60>
    1dba:	42 17       	cp	r20, r18
    1dbc:	53 07       	cpc	r21, r19
    1dbe:	18 f4       	brcc	.+6      	; 0x1dc6 <malloc+0x66>
    1dc0:	9a 01       	movw	r18, r20
    1dc2:	bd 01       	movw	r22, r26
    1dc4:	ef 01       	movw	r28, r30
    1dc6:	df 01       	movw	r26, r30
    1dc8:	f8 01       	movw	r30, r16
    1dca:	db cf       	rjmp	.-74     	; 0x1d82 <malloc+0x22>
    1dcc:	21 15       	cp	r18, r1
    1dce:	31 05       	cpc	r19, r1
    1dd0:	f9 f0       	breq	.+62     	; 0x1e10 <malloc+0xb0>
    1dd2:	28 1b       	sub	r18, r24
    1dd4:	39 0b       	sbc	r19, r25
    1dd6:	24 30       	cpi	r18, 0x04	; 4
    1dd8:	31 05       	cpc	r19, r1
    1dda:	80 f4       	brcc	.+32     	; 0x1dfc <malloc+0x9c>
    1ddc:	8a 81       	ldd	r24, Y+2	; 0x02
    1dde:	9b 81       	ldd	r25, Y+3	; 0x03
    1de0:	61 15       	cp	r22, r1
    1de2:	71 05       	cpc	r23, r1
    1de4:	21 f0       	breq	.+8      	; 0x1dee <malloc+0x8e>
    1de6:	fb 01       	movw	r30, r22
    1de8:	93 83       	std	Z+3, r25	; 0x03
    1dea:	82 83       	std	Z+2, r24	; 0x02
    1dec:	04 c0       	rjmp	.+8      	; 0x1df6 <malloc+0x96>
    1dee:	90 93 6a 06 	sts	0x066A, r25	; 0x80066a <__flp+0x1>
    1df2:	80 93 69 06 	sts	0x0669, r24	; 0x800669 <__flp>
    1df6:	fe 01       	movw	r30, r28
    1df8:	32 96       	adiw	r30, 0x02	; 2
    1dfa:	44 c0       	rjmp	.+136    	; 0x1e84 <malloc+0x124>
    1dfc:	fe 01       	movw	r30, r28
    1dfe:	e2 0f       	add	r30, r18
    1e00:	f3 1f       	adc	r31, r19
    1e02:	81 93       	st	Z+, r24
    1e04:	91 93       	st	Z+, r25
    1e06:	22 50       	subi	r18, 0x02	; 2
    1e08:	31 09       	sbc	r19, r1
    1e0a:	39 83       	std	Y+1, r19	; 0x01
    1e0c:	28 83       	st	Y, r18
    1e0e:	3a c0       	rjmp	.+116    	; 0x1e84 <malloc+0x124>
    1e10:	20 91 67 06 	lds	r18, 0x0667	; 0x800667 <__brkval>
    1e14:	30 91 68 06 	lds	r19, 0x0668	; 0x800668 <__brkval+0x1>
    1e18:	23 2b       	or	r18, r19
    1e1a:	41 f4       	brne	.+16     	; 0x1e2c <malloc+0xcc>
    1e1c:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    1e20:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    1e24:	30 93 68 06 	sts	0x0668, r19	; 0x800668 <__brkval+0x1>
    1e28:	20 93 67 06 	sts	0x0667, r18	; 0x800667 <__brkval>
    1e2c:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    1e30:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    1e34:	21 15       	cp	r18, r1
    1e36:	31 05       	cpc	r19, r1
    1e38:	41 f4       	brne	.+16     	; 0x1e4a <malloc+0xea>
    1e3a:	2d b7       	in	r18, 0x3d	; 61
    1e3c:	3e b7       	in	r19, 0x3e	; 62
    1e3e:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    1e42:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    1e46:	24 1b       	sub	r18, r20
    1e48:	35 0b       	sbc	r19, r21
    1e4a:	e0 91 67 06 	lds	r30, 0x0667	; 0x800667 <__brkval>
    1e4e:	f0 91 68 06 	lds	r31, 0x0668	; 0x800668 <__brkval+0x1>
    1e52:	e2 17       	cp	r30, r18
    1e54:	f3 07       	cpc	r31, r19
    1e56:	a0 f4       	brcc	.+40     	; 0x1e80 <malloc+0x120>
    1e58:	2e 1b       	sub	r18, r30
    1e5a:	3f 0b       	sbc	r19, r31
    1e5c:	28 17       	cp	r18, r24
    1e5e:	39 07       	cpc	r19, r25
    1e60:	78 f0       	brcs	.+30     	; 0x1e80 <malloc+0x120>
    1e62:	ac 01       	movw	r20, r24
    1e64:	4e 5f       	subi	r20, 0xFE	; 254
    1e66:	5f 4f       	sbci	r21, 0xFF	; 255
    1e68:	24 17       	cp	r18, r20
    1e6a:	35 07       	cpc	r19, r21
    1e6c:	48 f0       	brcs	.+18     	; 0x1e80 <malloc+0x120>
    1e6e:	4e 0f       	add	r20, r30
    1e70:	5f 1f       	adc	r21, r31
    1e72:	50 93 68 06 	sts	0x0668, r21	; 0x800668 <__brkval+0x1>
    1e76:	40 93 67 06 	sts	0x0667, r20	; 0x800667 <__brkval>
    1e7a:	81 93       	st	Z+, r24
    1e7c:	91 93       	st	Z+, r25
    1e7e:	02 c0       	rjmp	.+4      	; 0x1e84 <malloc+0x124>
    1e80:	e0 e0       	ldi	r30, 0x00	; 0
    1e82:	f0 e0       	ldi	r31, 0x00	; 0
    1e84:	cf 01       	movw	r24, r30
    1e86:	df 91       	pop	r29
    1e88:	cf 91       	pop	r28
    1e8a:	1f 91       	pop	r17
    1e8c:	0f 91       	pop	r16
    1e8e:	08 95       	ret

00001e90 <free>:
    1e90:	cf 93       	push	r28
    1e92:	df 93       	push	r29
    1e94:	00 97       	sbiw	r24, 0x00	; 0
    1e96:	09 f4       	brne	.+2      	; 0x1e9a <free+0xa>
    1e98:	81 c0       	rjmp	.+258    	; 0x1f9c <free+0x10c>
    1e9a:	fc 01       	movw	r30, r24
    1e9c:	32 97       	sbiw	r30, 0x02	; 2
    1e9e:	13 82       	std	Z+3, r1	; 0x03
    1ea0:	12 82       	std	Z+2, r1	; 0x02
    1ea2:	a0 91 69 06 	lds	r26, 0x0669	; 0x800669 <__flp>
    1ea6:	b0 91 6a 06 	lds	r27, 0x066A	; 0x80066a <__flp+0x1>
    1eaa:	10 97       	sbiw	r26, 0x00	; 0
    1eac:	81 f4       	brne	.+32     	; 0x1ece <free+0x3e>
    1eae:	20 81       	ld	r18, Z
    1eb0:	31 81       	ldd	r19, Z+1	; 0x01
    1eb2:	82 0f       	add	r24, r18
    1eb4:	93 1f       	adc	r25, r19
    1eb6:	20 91 67 06 	lds	r18, 0x0667	; 0x800667 <__brkval>
    1eba:	30 91 68 06 	lds	r19, 0x0668	; 0x800668 <__brkval+0x1>
    1ebe:	28 17       	cp	r18, r24
    1ec0:	39 07       	cpc	r19, r25
    1ec2:	51 f5       	brne	.+84     	; 0x1f18 <free+0x88>
    1ec4:	f0 93 68 06 	sts	0x0668, r31	; 0x800668 <__brkval+0x1>
    1ec8:	e0 93 67 06 	sts	0x0667, r30	; 0x800667 <__brkval>
    1ecc:	67 c0       	rjmp	.+206    	; 0x1f9c <free+0x10c>
    1ece:	ed 01       	movw	r28, r26
    1ed0:	20 e0       	ldi	r18, 0x00	; 0
    1ed2:	30 e0       	ldi	r19, 0x00	; 0
    1ed4:	ce 17       	cp	r28, r30
    1ed6:	df 07       	cpc	r29, r31
    1ed8:	40 f4       	brcc	.+16     	; 0x1eea <free+0x5a>
    1eda:	4a 81       	ldd	r20, Y+2	; 0x02
    1edc:	5b 81       	ldd	r21, Y+3	; 0x03
    1ede:	9e 01       	movw	r18, r28
    1ee0:	41 15       	cp	r20, r1
    1ee2:	51 05       	cpc	r21, r1
    1ee4:	f1 f0       	breq	.+60     	; 0x1f22 <free+0x92>
    1ee6:	ea 01       	movw	r28, r20
    1ee8:	f5 cf       	rjmp	.-22     	; 0x1ed4 <free+0x44>
    1eea:	d3 83       	std	Z+3, r29	; 0x03
    1eec:	c2 83       	std	Z+2, r28	; 0x02
    1eee:	40 81       	ld	r20, Z
    1ef0:	51 81       	ldd	r21, Z+1	; 0x01
    1ef2:	84 0f       	add	r24, r20
    1ef4:	95 1f       	adc	r25, r21
    1ef6:	c8 17       	cp	r28, r24
    1ef8:	d9 07       	cpc	r29, r25
    1efa:	59 f4       	brne	.+22     	; 0x1f12 <free+0x82>
    1efc:	88 81       	ld	r24, Y
    1efe:	99 81       	ldd	r25, Y+1	; 0x01
    1f00:	84 0f       	add	r24, r20
    1f02:	95 1f       	adc	r25, r21
    1f04:	02 96       	adiw	r24, 0x02	; 2
    1f06:	91 83       	std	Z+1, r25	; 0x01
    1f08:	80 83       	st	Z, r24
    1f0a:	8a 81       	ldd	r24, Y+2	; 0x02
    1f0c:	9b 81       	ldd	r25, Y+3	; 0x03
    1f0e:	93 83       	std	Z+3, r25	; 0x03
    1f10:	82 83       	std	Z+2, r24	; 0x02
    1f12:	21 15       	cp	r18, r1
    1f14:	31 05       	cpc	r19, r1
    1f16:	29 f4       	brne	.+10     	; 0x1f22 <free+0x92>
    1f18:	f0 93 6a 06 	sts	0x066A, r31	; 0x80066a <__flp+0x1>
    1f1c:	e0 93 69 06 	sts	0x0669, r30	; 0x800669 <__flp>
    1f20:	3d c0       	rjmp	.+122    	; 0x1f9c <free+0x10c>
    1f22:	e9 01       	movw	r28, r18
    1f24:	fb 83       	std	Y+3, r31	; 0x03
    1f26:	ea 83       	std	Y+2, r30	; 0x02
    1f28:	49 91       	ld	r20, Y+
    1f2a:	59 91       	ld	r21, Y+
    1f2c:	c4 0f       	add	r28, r20
    1f2e:	d5 1f       	adc	r29, r21
    1f30:	ec 17       	cp	r30, r28
    1f32:	fd 07       	cpc	r31, r29
    1f34:	61 f4       	brne	.+24     	; 0x1f4e <free+0xbe>
    1f36:	80 81       	ld	r24, Z
    1f38:	91 81       	ldd	r25, Z+1	; 0x01
    1f3a:	84 0f       	add	r24, r20
    1f3c:	95 1f       	adc	r25, r21
    1f3e:	02 96       	adiw	r24, 0x02	; 2
    1f40:	e9 01       	movw	r28, r18
    1f42:	99 83       	std	Y+1, r25	; 0x01
    1f44:	88 83       	st	Y, r24
    1f46:	82 81       	ldd	r24, Z+2	; 0x02
    1f48:	93 81       	ldd	r25, Z+3	; 0x03
    1f4a:	9b 83       	std	Y+3, r25	; 0x03
    1f4c:	8a 83       	std	Y+2, r24	; 0x02
    1f4e:	e0 e0       	ldi	r30, 0x00	; 0
    1f50:	f0 e0       	ldi	r31, 0x00	; 0
    1f52:	12 96       	adiw	r26, 0x02	; 2
    1f54:	8d 91       	ld	r24, X+
    1f56:	9c 91       	ld	r25, X
    1f58:	13 97       	sbiw	r26, 0x03	; 3
    1f5a:	00 97       	sbiw	r24, 0x00	; 0
    1f5c:	19 f0       	breq	.+6      	; 0x1f64 <free+0xd4>
    1f5e:	fd 01       	movw	r30, r26
    1f60:	dc 01       	movw	r26, r24
    1f62:	f7 cf       	rjmp	.-18     	; 0x1f52 <free+0xc2>
    1f64:	8d 91       	ld	r24, X+
    1f66:	9c 91       	ld	r25, X
    1f68:	11 97       	sbiw	r26, 0x01	; 1
    1f6a:	9d 01       	movw	r18, r26
    1f6c:	2e 5f       	subi	r18, 0xFE	; 254
    1f6e:	3f 4f       	sbci	r19, 0xFF	; 255
    1f70:	82 0f       	add	r24, r18
    1f72:	93 1f       	adc	r25, r19
    1f74:	20 91 67 06 	lds	r18, 0x0667	; 0x800667 <__brkval>
    1f78:	30 91 68 06 	lds	r19, 0x0668	; 0x800668 <__brkval+0x1>
    1f7c:	28 17       	cp	r18, r24
    1f7e:	39 07       	cpc	r19, r25
    1f80:	69 f4       	brne	.+26     	; 0x1f9c <free+0x10c>
    1f82:	30 97       	sbiw	r30, 0x00	; 0
    1f84:	29 f4       	brne	.+10     	; 0x1f90 <free+0x100>
    1f86:	10 92 6a 06 	sts	0x066A, r1	; 0x80066a <__flp+0x1>
    1f8a:	10 92 69 06 	sts	0x0669, r1	; 0x800669 <__flp>
    1f8e:	02 c0       	rjmp	.+4      	; 0x1f94 <free+0x104>
    1f90:	13 82       	std	Z+3, r1	; 0x03
    1f92:	12 82       	std	Z+2, r1	; 0x02
    1f94:	b0 93 68 06 	sts	0x0668, r27	; 0x800668 <__brkval+0x1>
    1f98:	a0 93 67 06 	sts	0x0667, r26	; 0x800667 <__brkval>
    1f9c:	df 91       	pop	r29
    1f9e:	cf 91       	pop	r28
    1fa0:	08 95       	ret

00001fa2 <memcpy>:
    1fa2:	fb 01       	movw	r30, r22
    1fa4:	dc 01       	movw	r26, r24
    1fa6:	02 c0       	rjmp	.+4      	; 0x1fac <memcpy+0xa>
    1fa8:	01 90       	ld	r0, Z+
    1faa:	0d 92       	st	X+, r0
    1fac:	41 50       	subi	r20, 0x01	; 1
    1fae:	50 40       	sbci	r21, 0x00	; 0
    1fb0:	d8 f7       	brcc	.-10     	; 0x1fa8 <memcpy+0x6>
    1fb2:	08 95       	ret

00001fb4 <memset>:
    1fb4:	dc 01       	movw	r26, r24
    1fb6:	01 c0       	rjmp	.+2      	; 0x1fba <memset+0x6>
    1fb8:	6d 93       	st	X+, r22
    1fba:	41 50       	subi	r20, 0x01	; 1
    1fbc:	50 40       	sbci	r21, 0x00	; 0
    1fbe:	e0 f7       	brcc	.-8      	; 0x1fb8 <memset+0x4>
    1fc0:	08 95       	ret

00001fc2 <_exit>:
    1fc2:	f8 94       	cli

00001fc4 <__stop_program>:
    1fc4:	ff cf       	rjmp	.-2      	; 0x1fc4 <__stop_program>
