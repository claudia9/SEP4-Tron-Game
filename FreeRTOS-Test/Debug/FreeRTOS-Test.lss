
FreeRTOS-Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ba  00800100  00001fbe  00002052  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001fbe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000004a2  008001ba  008001ba  0000210c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000210c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000213c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000468  00000000  00000000  0000217c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000568f  00000000  00000000  000025e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000015fc  00000000  00000000  00007c73  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002e69  00000000  00000000  0000926f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000e60  00000000  00000000  0000c0d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001bb7  00000000  00000000  0000cf38  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000053df  00000000  00000000  0000eaef  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004c8  00000000  00000000  00013ece  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 75 00 	jmp	0xea	; 0xea <__ctors_end>
       4:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
       8:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
       c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      10:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      14:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      18:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      1c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      20:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      24:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      28:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      2c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      30:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      34:	0c 94 86 04 	jmp	0x90c	; 0x90c <__vector_13>
      38:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      3c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      40:	0c 94 d3 01 	jmp	0x3a6	; 0x3a6 <__vector_16>
      44:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      48:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      4c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      50:	0c 94 7c 05 	jmp	0xaf8	; 0xaf8 <__vector_20>
      54:	0c 94 ba 05 	jmp	0xb74	; 0xb74 <__vector_21>
      58:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      5c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      60:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      64:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      68:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      6c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      70:	0c 94 02 06 	jmp	0xc04	; 0xc04 <__vector_28>
      74:	0c 94 40 06 	jmp	0xc80	; 0xc80 <__vector_29>
      78:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
      7c:	a4 00       	.word	0x00a4	; ????
      7e:	a2 00       	.word	0x00a2	; ????
      80:	a2 00       	.word	0x00a2	; ????
      82:	a4 00       	.word	0x00a4	; ????
      84:	a2 00       	.word	0x00a2	; ????
      86:	a2 00       	.word	0x00a2	; ????
      88:	a2 00       	.word	0x00a2	; ????
      8a:	a2 00       	.word	0x00a2	; ????
      8c:	a2 00       	.word	0x00a2	; ????
      8e:	a2 00       	.word	0x00a2	; ????
      90:	a2 00       	.word	0x00a2	; ????
      92:	a2 00       	.word	0x00a2	; ????
      94:	a2 00       	.word	0x00a2	; ????
      96:	a2 00       	.word	0x00a2	; ????
      98:	a2 00       	.word	0x00a2	; ????
      9a:	a2 00       	.word	0x00a2	; ????
      9c:	a2 00       	.word	0x00a2	; ????
      9e:	a2 00       	.word	0x00a2	; ????
      a0:	a4 00       	.word	0x00a4	; ????
      a2:	a2 00       	.word	0x00a2	; ????
      a4:	a2 00       	.word	0x00a2	; ????
      a6:	a2 00       	.word	0x00a2	; ????
      a8:	a4 00       	.word	0x00a4	; ????
      aa:	a2 00       	.word	0x00a2	; ????
      ac:	a2 00       	.word	0x00a2	; ????
      ae:	a2 00       	.word	0x00a2	; ????
      b0:	a2 00       	.word	0x00a2	; ????
      b2:	a2 00       	.word	0x00a2	; ????
      b4:	a2 00       	.word	0x00a2	; ????
      b6:	a2 00       	.word	0x00a2	; ????
      b8:	a2 00       	.word	0x00a2	; ????
      ba:	a2 00       	.word	0x00a2	; ????
      bc:	a4 00       	.word	0x00a4	; ????
      be:	a2 00       	.word	0x00a2	; ????
      c0:	a2 00       	.word	0x00a2	; ????
      c2:	a4 00       	.word	0x00a4	; ????
      c4:	a2 00       	.word	0x00a2	; ????
      c6:	a2 00       	.word	0x00a2	; ????
      c8:	a2 00       	.word	0x00a2	; ????
      ca:	a2 00       	.word	0x00a2	; ????
      cc:	a2 00       	.word	0x00a2	; ????
      ce:	a2 00       	.word	0x00a2	; ????
      d0:	a2 00       	.word	0x00a2	; ????
      d2:	a2 00       	.word	0x00a2	; ????
      d4:	a2 00       	.word	0x00a2	; ????
      d6:	a2 00       	.word	0x00a2	; ????
      d8:	a2 00       	.word	0x00a2	; ????
      da:	a2 00       	.word	0x00a2	; ????
      dc:	a2 00       	.word	0x00a2	; ????
      de:	a2 00       	.word	0x00a2	; ????
      e0:	a4 00       	.word	0x00a4	; ????
      e2:	a2 00       	.word	0x00a2	; ????
      e4:	a2 00       	.word	0x00a2	; ????
      e6:	a2 00       	.word	0x00a2	; ????
      e8:	a4 00       	.word	0x00a4	; ????

000000ea <__ctors_end>:
      ea:	11 24       	eor	r1, r1
      ec:	1f be       	out	0x3f, r1	; 63
      ee:	cf ef       	ldi	r28, 0xFF	; 255
      f0:	d8 e0       	ldi	r29, 0x08	; 8
      f2:	de bf       	out	0x3e, r29	; 62
      f4:	cd bf       	out	0x3d, r28	; 61

000000f6 <__do_copy_data>:
      f6:	11 e0       	ldi	r17, 0x01	; 1
      f8:	a0 e0       	ldi	r26, 0x00	; 0
      fa:	b1 e0       	ldi	r27, 0x01	; 1
      fc:	ee eb       	ldi	r30, 0xBE	; 190
      fe:	ff e1       	ldi	r31, 0x1F	; 31
     100:	02 c0       	rjmp	.+4      	; 0x106 <__do_copy_data+0x10>
     102:	05 90       	lpm	r0, Z+
     104:	0d 92       	st	X+, r0
     106:	aa 3b       	cpi	r26, 0xBA	; 186
     108:	b1 07       	cpc	r27, r17
     10a:	d9 f7       	brne	.-10     	; 0x102 <__do_copy_data+0xc>

0000010c <__do_clear_bss>:
     10c:	26 e0       	ldi	r18, 0x06	; 6
     10e:	aa eb       	ldi	r26, 0xBA	; 186
     110:	b1 e0       	ldi	r27, 0x01	; 1
     112:	01 c0       	rjmp	.+2      	; 0x116 <.do_clear_bss_start>

00000114 <.do_clear_bss_loop>:
     114:	1d 92       	st	X+, r1

00000116 <.do_clear_bss_start>:
     116:	ac 35       	cpi	r26, 0x5C	; 92
     118:	b2 07       	cpc	r27, r18
     11a:	e1 f7       	brne	.-8      	; 0x114 <.do_clear_bss_loop>
     11c:	0e 94 85 01 	call	0x30a	; 0x30a <main>
     120:	0c 94 dd 0f 	jmp	0x1fba	; 0x1fba <_exit>

00000124 <__bad_interrupt>:
     124:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000128 <correctArrowKey>:
			//We were able to obtain the semaphore and can now access the shared resource.
			com_send_bytes((uint8_t *)"Processing matrix\n", 19);
			vTaskDelay(50);
			
			// We have finished accessing the shared resource. Release the semaphore.
			xSemaphoreGive(xMutexReceivedData);
     128:	dc 01       	movw	r26, r24
     12a:	ec 91       	ld	r30, X
     12c:	8e 2f       	mov	r24, r30
     12e:	90 e0       	ldi	r25, 0x00	; 0
     130:	fc 01       	movw	r30, r24
     132:	e1 54       	subi	r30, 0x41	; 65
     134:	f1 09       	sbc	r31, r1
     136:	e7 33       	cpi	r30, 0x37	; 55
     138:	f1 05       	cpc	r31, r1
     13a:	20 f4       	brcc	.+8      	; 0x144 <correctArrowKey+0x1c>
     13c:	e2 5c       	subi	r30, 0xC2	; 194
     13e:	ff 4f       	sbci	r31, 0xFF	; 255
     140:	0c 94 a6 0e 	jmp	0x1d4c	; 0x1d4c <__tablejump2__>
     144:	80 e0       	ldi	r24, 0x00	; 0
     146:	08 95       	ret
     148:	81 e0       	ldi	r24, 0x01	; 1
     14a:	08 95       	ret

0000014c <waitForKeyPress>:
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29
     150:	1f 92       	push	r1
     152:	cd b7       	in	r28, 0x3d	; 61
     154:	de b7       	in	r29, 0x3e	; 62
     156:	19 82       	std	Y+1, r1	; 0x01
     158:	40 e0       	ldi	r20, 0x00	; 0
     15a:	61 e0       	ldi	r22, 0x01	; 1
     15c:	8e e1       	ldi	r24, 0x1E	; 30
     15e:	0e 94 8b 07 	call	0xf16	; 0xf16 <xQueueGenericCreate>
     162:	90 93 be 01 	sts	0x01BE, r25	; 0x8001be <_received_chars_queue+0x1>
     166:	80 93 bd 01 	sts	0x01BD, r24	; 0x8001bd <_received_chars_queue>
     16a:	0e 94 bc 01 	call	0x378	; 0x378 <init_com>
     16e:	81 e0       	ldi	r24, 0x01	; 1
     170:	0e 94 5d 08 	call	0x10ba	; 0x10ba <xQueueCreateMutex>
     174:	90 93 bc 01 	sts	0x01BC, r25	; 0x8001bc <xMutexReceivedData+0x1>
     178:	80 93 bb 01 	sts	0x01BB, r24	; 0x8001bb <xMutexReceivedData>
     17c:	61 e0       	ldi	r22, 0x01	; 1
     17e:	70 e0       	ldi	r23, 0x00	; 0
     180:	80 e0       	ldi	r24, 0x00	; 0
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	0e 94 b2 0c 	call	0x1964	; 0x1964 <vTaskSetApplicationTaskTag>
     188:	2d c0       	rjmp	.+90     	; 0x1e4 <waitForKeyPress+0x98>
     18a:	20 e0       	ldi	r18, 0x00	; 0
     18c:	4a e0       	ldi	r20, 0x0A	; 10
     18e:	50 e0       	ldi	r21, 0x00	; 0
     190:	be 01       	movw	r22, r28
     192:	6f 5f       	subi	r22, 0xFF	; 255
     194:	7f 4f       	sbci	r23, 0xFF	; 255
     196:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <_received_chars_queue>
     19a:	90 91 be 01 	lds	r25, 0x01BE	; 0x8001be <_received_chars_queue+0x1>
     19e:	0e 94 b1 08 	call	0x1162	; 0x1162 <xQueueGenericReceive>
     1a2:	88 23       	and	r24, r24
     1a4:	f9 f0       	breq	.+62     	; 0x1e4 <waitForKeyPress+0x98>
     1a6:	61 e0       	ldi	r22, 0x01	; 1
     1a8:	ce 01       	movw	r24, r28
     1aa:	01 96       	adiw	r24, 0x01	; 1
     1ac:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <com_send_bytes>
     1b0:	89 81       	ldd	r24, Y+1	; 0x01
     1b2:	81 33       	cpi	r24, 0x31	; 49
     1b4:	71 f4       	brne	.+28     	; 0x1d2 <waitForKeyPress+0x86>
     1b6:	60 e2       	ldi	r22, 0x20	; 32
     1b8:	8c e0       	ldi	r24, 0x0C	; 12
     1ba:	91 e0       	ldi	r25, 0x01	; 1
     1bc:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <com_send_bytes>
     1c0:	82 e3       	ldi	r24, 0x32	; 50
     1c2:	90 e0       	ldi	r25, 0x00	; 0
     1c4:	0e 94 5f 0c 	call	0x18be	; 0x18be <vTaskDelay>
     1c8:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <start_game+0x1>
     1cc:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <start_game>
     1d0:	09 c0       	rjmp	.+18     	; 0x1e4 <waitForKeyPress+0x98>
     1d2:	63 e2       	ldi	r22, 0x23	; 35
     1d4:	8c e2       	ldi	r24, 0x2C	; 44
     1d6:	91 e0       	ldi	r25, 0x01	; 1
     1d8:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <com_send_bytes>
     1dc:	84 e6       	ldi	r24, 0x64	; 100
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	0e 94 5f 0c 	call	0x18be	; 0x18be <vTaskDelay>
     1e4:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <start_game>
     1e8:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <start_game+0x1>
     1ec:	01 97       	sbiw	r24, 0x01	; 1
     1ee:	69 f2       	breq	.-102    	; 0x18a <waitForKeyPress+0x3e>
     1f0:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <_received_chars_queue>
     1f4:	90 91 be 01 	lds	r25, 0x01BE	; 0x8001be <_received_chars_queue+0x1>
     1f8:	0e 94 bc 01 	call	0x378	; 0x378 <init_com>
     1fc:	20 e0       	ldi	r18, 0x00	; 0
     1fe:	40 e0       	ldi	r20, 0x00	; 0
     200:	50 e0       	ldi	r21, 0x00	; 0
     202:	60 e0       	ldi	r22, 0x00	; 0
     204:	70 e0       	ldi	r23, 0x00	; 0
     206:	80 91 bb 01 	lds	r24, 0x01BB	; 0x8001bb <xMutexReceivedData>
     20a:	90 91 bc 01 	lds	r25, 0x01BC	; 0x8001bc <xMutexReceivedData+0x1>
     20e:	0e 94 b1 08 	call	0x1162	; 0x1162 <xQueueGenericReceive>
     212:	20 e0       	ldi	r18, 0x00	; 0
     214:	4a e0       	ldi	r20, 0x0A	; 10
     216:	50 e0       	ldi	r21, 0x00	; 0
     218:	be 01       	movw	r22, r28
     21a:	6f 5f       	subi	r22, 0xFF	; 255
     21c:	7f 4f       	sbci	r23, 0xFF	; 255
     21e:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <_received_chars_queue>
     222:	90 91 be 01 	lds	r25, 0x01BE	; 0x8001be <_received_chars_queue+0x1>
     226:	0e 94 b1 08 	call	0x1162	; 0x1162 <xQueueGenericReceive>
     22a:	88 23       	and	r24, r24
     22c:	39 f3       	breq	.-50     	; 0x1fc <waitForKeyPress+0xb0>
     22e:	ce 01       	movw	r24, r28
     230:	01 96       	adiw	r24, 0x01	; 1
     232:	0e 94 94 00 	call	0x128	; 0x128 <correctArrowKey>
     236:	88 23       	and	r24, r24
     238:	b1 f0       	breq	.+44     	; 0x266 <waitForKeyPress+0x11a>
     23a:	66 e0       	ldi	r22, 0x06	; 6
     23c:	8f e4       	ldi	r24, 0x4F	; 79
     23e:	91 e0       	ldi	r25, 0x01	; 1
     240:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <com_send_bytes>
     244:	61 e0       	ldi	r22, 0x01	; 1
     246:	ce 01       	movw	r24, r28
     248:	01 96       	adiw	r24, 0x01	; 1
     24a:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <com_send_bytes>
     24e:	20 e0       	ldi	r18, 0x00	; 0
     250:	40 e0       	ldi	r20, 0x00	; 0
     252:	50 e0       	ldi	r21, 0x00	; 0
     254:	60 e0       	ldi	r22, 0x00	; 0
     256:	70 e0       	ldi	r23, 0x00	; 0
     258:	80 91 bb 01 	lds	r24, 0x01BB	; 0x8001bb <xMutexReceivedData>
     25c:	90 91 bc 01 	lds	r25, 0x01BC	; 0x8001bc <xMutexReceivedData+0x1>
     260:	0e 94 bc 07 	call	0xf78	; 0xf78 <xQueueGenericSend>
     264:	cb cf       	rjmp	.-106    	; 0x1fc <waitForKeyPress+0xb0>
     266:	89 81       	ldd	r24, Y+1	; 0x01
     268:	80 32       	cpi	r24, 0x20	; 32
     26a:	51 f4       	brne	.+20     	; 0x280 <waitForKeyPress+0x134>
     26c:	6c e0       	ldi	r22, 0x0C	; 12
     26e:	86 e5       	ldi	r24, 0x56	; 86
     270:	91 e0       	ldi	r25, 0x01	; 1
     272:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <com_send_bytes>
     276:	8a e0       	ldi	r24, 0x0A	; 10
     278:	90 e0       	ldi	r25, 0x00	; 0
     27a:	0e 94 5f 0c 	call	0x18be	; 0x18be <vTaskDelay>
     27e:	be cf       	rjmp	.-132    	; 0x1fc <waitForKeyPress+0xb0>
     280:	60 e1       	ldi	r22, 0x10	; 16
     282:	82 e6       	ldi	r24, 0x62	; 98
     284:	91 e0       	ldi	r25, 0x01	; 1
     286:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <com_send_bytes>
     28a:	8a e0       	ldi	r24, 0x0A	; 10
     28c:	90 e0       	ldi	r25, 0x00	; 0
     28e:	0e 94 5f 0c 	call	0x18be	; 0x18be <vTaskDelay>
     292:	b4 cf       	rjmp	.-152    	; 0x1fc <waitForKeyPress+0xb0>

00000294 <prepare_shiftregister>:

// Prepare shift register setting SER = 1
void prepare_shiftregister()
{
	// Set SER to 1
	PORTD |= _BV(PORTD2);
     294:	5a 9a       	sbi	0x0b, 2	; 11
     296:	08 95       	ret

00000298 <clock_shift_register_and_prepare_for_next_col>:

// clock shift-register
void clock_shift_register_and_prepare_for_next_col()
{
	// one SCK pulse
	PORTD |= _BV(PORTD5);
     298:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD &= ~_BV(PORTD5);
     29a:	5d 98       	cbi	0x0b, 5	; 11
	
	// one RCK pulse
	PORTD |= _BV(PORTD4);
     29c:	5c 9a       	sbi	0x0b, 4	; 11
	PORTD &= ~_BV(PORTD4);
     29e:	5c 98       	cbi	0x0b, 4	; 11
	
	// Set SER to 0 - for next column
	PORTD &= ~_BV(PORTD2);
     2a0:	5a 98       	cbi	0x0b, 2	; 11
     2a2:	08 95       	ret

000002a4 <load_col_value>:
}

// Load column value for column to show
void load_col_value(uint16_t col_value)
{
	PORTA = ~(col_value & 0xFF);
     2a4:	80 95       	com	r24
     2a6:	82 b9       	out	0x02, r24	; 2
	
	// Manipulate only with PB0 and PB1
	PORTB |= 0x03;
     2a8:	85 b1       	in	r24, 0x05	; 5
     2aa:	83 60       	ori	r24, 0x03	; 3
     2ac:	85 b9       	out	0x05, r24	; 5
	PORTB &= ~((col_value >> 8) & 0x03);
     2ae:	85 b1       	in	r24, 0x05	; 5
     2b0:	93 70       	andi	r25, 0x03	; 3
     2b2:	90 95       	com	r25
     2b4:	89 23       	and	r24, r25
     2b6:	85 b9       	out	0x05, r24	; 5
     2b8:	08 95       	ret

000002ba <handle_display>:
}

//-----------------------------------------
void handle_display(void)
{
     2ba:	cf 93       	push	r28
	static uint8_t col = 0;
	
	if (col == 0)
     2bc:	c0 91 ba 01 	lds	r28, 0x01BA	; 0x8001ba <__data_end>
     2c0:	c1 11       	cpse	r28, r1
     2c2:	0c c0       	rjmp	.+24     	; 0x2dc <handle_display+0x22>
	{
		prepare_shiftregister();
     2c4:	0e 94 4a 01 	call	0x294	; 0x294 <prepare_shiftregister>
	}
	
	load_col_value(frame_buf[col]);
     2c8:	80 e0       	ldi	r24, 0x00	; 0
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	0e 94 52 01 	call	0x2a4	; 0x2a4 <load_col_value>
	
	clock_shift_register_and_prepare_for_next_col();
     2d0:	0e 94 4c 01 	call	0x298	; 0x298 <clock_shift_register_and_prepare_for_next_col>
	
	// count column up - prepare for next
	col++;
     2d4:	81 e0       	ldi	r24, 0x01	; 1
     2d6:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
     2da:	14 c0       	rjmp	.+40     	; 0x304 <handle_display+0x4a>
	if (col == 0)
	{
		prepare_shiftregister();
	}
	
	load_col_value(frame_buf[col]);
     2dc:	ec 2f       	mov	r30, r28
     2de:	f0 e0       	ldi	r31, 0x00	; 0
     2e0:	ee 0f       	add	r30, r30
     2e2:	ff 1f       	adc	r31, r31
     2e4:	e7 56       	subi	r30, 0x67	; 103
     2e6:	fe 4f       	sbci	r31, 0xFE	; 254
     2e8:	80 81       	ld	r24, Z
     2ea:	91 81       	ldd	r25, Z+1	; 0x01
     2ec:	0e 94 52 01 	call	0x2a4	; 0x2a4 <load_col_value>
	
	clock_shift_register_and_prepare_for_next_col();
     2f0:	0e 94 4c 01 	call	0x298	; 0x298 <clock_shift_register_and_prepare_for_next_col>
	
	// count column up - prepare for next
	col++;
     2f4:	cf 5f       	subi	r28, 0xFF	; 255
	if (col > 13)
     2f6:	ce 30       	cpi	r28, 0x0E	; 14
     2f8:	18 f4       	brcc	.+6      	; 0x300 <handle_display+0x46>
	load_col_value(frame_buf[col]);
	
	clock_shift_register_and_prepare_for_next_col();
	
	// count column up - prepare for next
	col++;
     2fa:	c0 93 ba 01 	sts	0x01BA, r28	; 0x8001ba <__data_end>
     2fe:	02 c0       	rjmp	.+4      	; 0x304 <handle_display+0x4a>
	if (col > 13)
	{
		col = 0;
     300:	10 92 ba 01 	sts	0x01BA, r1	; 0x8001ba <__data_end>
	}
}
     304:	cf 91       	pop	r28
     306:	08 95       	ret

00000308 <vApplicationIdleHook>:


//Don't delete or program crashes..
void vApplicationIdleHook( void )
{
     308:	08 95       	ret

0000030a <main>:
}

//-----------------------------------------
int main(void)
{
	init_board();
     30a:	0e 94 05 02 	call	0x40a	; 0x40a <init_board>
	
	// Shift register Enable output (G=0)
	PORTD &= ~_BV(PORTD6);
     30e:	5e 98       	cbi	0x0b, 6	; 11

	//Create task to check key press
	BaseType_t taskWaitForKeyPress = xTaskCreate(waitForKeyPress, (const char *)"Wait for key press", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY, NULL);
     310:	e1 2c       	mov	r14, r1
     312:	f1 2c       	mov	r15, r1
     314:	00 e0       	ldi	r16, 0x00	; 0
     316:	20 e0       	ldi	r18, 0x00	; 0
     318:	30 e0       	ldi	r19, 0x00	; 0
     31a:	45 e5       	ldi	r20, 0x55	; 85
     31c:	50 e0       	ldi	r21, 0x00	; 0
     31e:	66 e8       	ldi	r22, 0x86	; 134
     320:	71 e0       	ldi	r23, 0x01	; 1
     322:	86 ea       	ldi	r24, 0xA6	; 166
     324:	90 e0       	ldi	r25, 0x00	; 0
     326:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <xTaskCreate>

	// Start the display handler timer
	init_display_timer(handle_display);
     32a:	8d e5       	ldi	r24, 0x5D	; 93
     32c:	91 e0       	ldi	r25, 0x01	; 1
     32e:	0e 94 c1 01 	call	0x382	; 0x382 <init_display_timer>
	
	sei();
     332:	78 94       	sei

	//Start the scheduler
	vTaskStartScheduler();
     334:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <vTaskStartScheduler>
     338:	ff cf       	rjmp	.-2      	; 0x338 <main+0x2e>

0000033a <_com_call_back>:

// Pointer to application display handler
static display_callback_ptr_t cb_ptr = NULL;

// ----------------------------------------------------------------------------------------------------------------------
static void _com_call_back(serial_p _com_serial_instance, uint8_t serial_last_received_byte) {
     33a:	cf 93       	push	r28
     33c:	df 93       	push	r29
     33e:	00 d0       	rcall	.+0      	; 0x340 <_com_call_back+0x6>
     340:	cd b7       	in	r28, 0x3d	; 61
     342:	de b7       	in	r29, 0x3e	; 62
     344:	6a 83       	std	Y+2, r22	; 0x02
	if (_x_rx_com_queue) {
     346:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <_x_rx_com_queue>
     34a:	90 91 08 02 	lds	r25, 0x0208	; 0x800208 <_x_rx_com_queue+0x1>
     34e:	00 97       	sbiw	r24, 0x00	; 0
     350:	71 f0       	breq	.+28     	; 0x36e <_com_call_back+0x34>
		signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     352:	19 82       	std	Y+1, r1	; 0x01

		xQueueSendFromISR( _x_rx_com_queue, &serial_last_received_byte, &xHigherPriorityTaskWoken );
     354:	20 e0       	ldi	r18, 0x00	; 0
     356:	ae 01       	movw	r20, r28
     358:	4f 5f       	subi	r20, 0xFF	; 255
     35a:	5f 4f       	sbci	r21, 0xFF	; 255
     35c:	be 01       	movw	r22, r28
     35e:	6e 5f       	subi	r22, 0xFE	; 254
     360:	7f 4f       	sbci	r23, 0xFF	; 255
     362:	0e 94 77 08 	call	0x10ee	; 0x10ee <xQueueGenericSendFromISR>

		if( xHigherPriorityTaskWoken != pdFALSE )
     366:	89 81       	ldd	r24, Y+1	; 0x01
     368:	81 11       	cpse	r24, r1
		{
			taskYIELD();
     36a:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vPortYield>
		}
	}
}
     36e:	0f 90       	pop	r0
     370:	0f 90       	pop	r0
     372:	df 91       	pop	r29
     374:	cf 91       	pop	r28
     376:	08 95       	ret

00000378 <init_com>:

// ----------------------------------------------------------------------------------------------------------------------
void init_com(QueueHandle_t x_rx_queue) {
	_x_rx_com_queue = x_rx_queue;
     378:	90 93 08 02 	sts	0x0208, r25	; 0x800208 <_x_rx_com_queue+0x1>
     37c:	80 93 07 02 	sts	0x0207, r24	; 0x800207 <_x_rx_com_queue>
     380:	08 95       	ret

00000382 <init_display_timer>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_display_timer(display_callback_ptr_t cb)
{
	cb_ptr = cb;
     382:	90 93 06 02 	sts	0x0206, r25	; 0x800206 <cb_ptr+0x1>
     386:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <cb_ptr>
	
	// Setup timer T0 to CTC, ~1309 Hz
	OCR0A = 10;
     38a:	8a e0       	ldi	r24, 0x0A	; 10
     38c:	87 bd       	out	0x27, r24	; 39
	TCCR0A |= _BV(WGM01); // Mode 2
     38e:	84 b5       	in	r24, 0x24	; 36
     390:	82 60       	ori	r24, 0x02	; 2
     392:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= _BV(OCIE0A); // Enable interrupt
     394:	ee e6       	ldi	r30, 0x6E	; 110
     396:	f0 e0       	ldi	r31, 0x00	; 0
     398:	80 81       	ld	r24, Z
     39a:	82 60       	ori	r24, 0x02	; 2
     39c:	80 83       	st	Z, r24
	TCCR0B |= _BV(CS00) | _BV(CS02); // Prescaler 1024 - and start timer
     39e:	85 b5       	in	r24, 0x25	; 37
     3a0:	85 60       	ori	r24, 0x05	; 5
     3a2:	85 bd       	out	0x25, r24	; 37
     3a4:	08 95       	ret

000003a6 <__vector_16>:
}

// ----------------------------------------------------------------------------------------------------------------------
//ISR for display timer
ISR(TIMER0_COMPA_vect)
{
     3a6:	1f 92       	push	r1
     3a8:	0f 92       	push	r0
     3aa:	0f b6       	in	r0, 0x3f	; 63
     3ac:	0f 92       	push	r0
     3ae:	11 24       	eor	r1, r1
     3b0:	2f 93       	push	r18
     3b2:	3f 93       	push	r19
     3b4:	4f 93       	push	r20
     3b6:	5f 93       	push	r21
     3b8:	6f 93       	push	r22
     3ba:	7f 93       	push	r23
     3bc:	8f 93       	push	r24
     3be:	9f 93       	push	r25
     3c0:	af 93       	push	r26
     3c2:	bf 93       	push	r27
     3c4:	ef 93       	push	r30
     3c6:	ff 93       	push	r31
	if (cb_ptr)
     3c8:	e0 91 05 02 	lds	r30, 0x0205	; 0x800205 <cb_ptr>
     3cc:	f0 91 06 02 	lds	r31, 0x0206	; 0x800206 <cb_ptr+0x1>
     3d0:	30 97       	sbiw	r30, 0x00	; 0
     3d2:	09 f0       	breq	.+2      	; 0x3d6 <__vector_16+0x30>
	{
		cb_ptr();
     3d4:	09 95       	icall
	}
}
     3d6:	ff 91       	pop	r31
     3d8:	ef 91       	pop	r30
     3da:	bf 91       	pop	r27
     3dc:	af 91       	pop	r26
     3de:	9f 91       	pop	r25
     3e0:	8f 91       	pop	r24
     3e2:	7f 91       	pop	r23
     3e4:	6f 91       	pop	r22
     3e6:	5f 91       	pop	r21
     3e8:	4f 91       	pop	r20
     3ea:	3f 91       	pop	r19
     3ec:	2f 91       	pop	r18
     3ee:	0f 90       	pop	r0
     3f0:	0f be       	out	0x3f, r0	; 63
     3f2:	0f 90       	pop	r0
     3f4:	1f 90       	pop	r1
     3f6:	18 95       	reti

000003f8 <com_send_bytes>:

// ----------------------------------------------------------------------------------------------------------------------
void com_send_bytes(uint8_t *bytes, uint8_t len) {
     3f8:	46 2f       	mov	r20, r22
	serial_send_bytes(_com_serial_instance, bytes, len);
     3fa:	bc 01       	movw	r22, r24
     3fc:	80 91 09 02 	lds	r24, 0x0209	; 0x800209 <_com_serial_instance>
     400:	90 91 0a 02 	lds	r25, 0x020A	; 0x80020a <_com_serial_instance+0x1>
     404:	0e 94 39 05 	call	0xa72	; 0xa72 <serial_send_bytes>
     408:	08 95       	ret

0000040a <init_board>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_board(void) {
     40a:	8f 92       	push	r8
     40c:	9f 92       	push	r9
     40e:	af 92       	push	r10
     410:	bf 92       	push	r11
     412:	cf 92       	push	r12
     414:	df 92       	push	r13
     416:	ef 92       	push	r14
     418:	0f 93       	push	r16
	static buffer_struct_t _com_rx_buffer;
	static buffer_struct_t _com_tx_buffer;
	buffer_init(&_com_rx_buffer);
     41a:	82 ee       	ldi	r24, 0xE2	; 226
     41c:	91 e0       	ldi	r25, 0x01	; 1
     41e:	0e 94 5e 02 	call	0x4bc	; 0x4bc <buffer_init>
	buffer_init(&_com_tx_buffer);
     422:	8f eb       	ldi	r24, 0xBF	; 191
     424:	91 e0       	ldi	r25, 0x01	; 1
     426:	0e 94 5e 02 	call	0x4bc	; 0x4bc <buffer_init>
	_com_serial_instance = serial_new_instance(ser_USART0, 115200UL, ser_BITS_8, ser_STOP_1, ser_NO_PARITY, &_com_rx_buffer, &_com_tx_buffer, _com_call_back);
     42a:	0f 2e       	mov	r0, r31
     42c:	fd e9       	ldi	r31, 0x9D	; 157
     42e:	8f 2e       	mov	r8, r31
     430:	f1 e0       	ldi	r31, 0x01	; 1
     432:	9f 2e       	mov	r9, r31
     434:	f0 2d       	mov	r31, r0
     436:	0f 2e       	mov	r0, r31
     438:	ff eb       	ldi	r31, 0xBF	; 191
     43a:	af 2e       	mov	r10, r31
     43c:	f1 e0       	ldi	r31, 0x01	; 1
     43e:	bf 2e       	mov	r11, r31
     440:	f0 2d       	mov	r31, r0
     442:	0f 2e       	mov	r0, r31
     444:	f2 ee       	ldi	r31, 0xE2	; 226
     446:	cf 2e       	mov	r12, r31
     448:	f1 e0       	ldi	r31, 0x01	; 1
     44a:	df 2e       	mov	r13, r31
     44c:	f0 2d       	mov	r31, r0
     44e:	e1 2c       	mov	r14, r1
     450:	00 e0       	ldi	r16, 0x00	; 0
     452:	23 e0       	ldi	r18, 0x03	; 3
     454:	40 e0       	ldi	r20, 0x00	; 0
     456:	52 ec       	ldi	r21, 0xC2	; 194
     458:	61 e0       	ldi	r22, 0x01	; 1
     45a:	70 e0       	ldi	r23, 0x00	; 0
     45c:	80 e0       	ldi	r24, 0x00	; 0
     45e:	0e 94 bf 04 	call	0x97e	; 0x97e <serial_new_instance>
     462:	90 93 0a 02 	sts	0x020A, r25	; 0x80020a <_com_serial_instance+0x1>
     466:	80 93 09 02 	sts	0x0209, r24	; 0x800209 <_com_serial_instance>
	
	// Pull up on Joystick inputs
	PORTC |= _BV(PORTC0) | _BV(PORTC1) | _BV(PORTC6) | _BV(PORTC7);
     46a:	88 b1       	in	r24, 0x08	; 8
     46c:	83 6c       	ori	r24, 0xC3	; 195
     46e:	88 b9       	out	0x08, r24	; 8
	PORTD |= _BV(PORTD3);
     470:	5b 9a       	sbi	0x0b, 3	; 11
	
	// Shift register control pins to output
	// SER, RCK, SCK, G (enable output)
	DDRD |= _BV(DDD2) | _BV(DDD4) | _BV(DDD5) | _BV(DDD6);
     472:	8a b1       	in	r24, 0x0a	; 10
     474:	84 67       	ori	r24, 0x74	; 116
     476:	8a b9       	out	0x0a, r24	; 10
	// G (enable output) high
	PORTD |= _BV(PORTD6);
     478:	5e 9a       	sbi	0x0b, 6	; 11
	
	// Column pins to output
	DDRA |= 0xFF;
     47a:	81 b1       	in	r24, 0x01	; 1
     47c:	8f ef       	ldi	r24, 0xFF	; 255
     47e:	81 b9       	out	0x01, r24	; 1
	DDRB |= _BV(DDB0) | _BV(DDB1);
     480:	84 b1       	in	r24, 0x04	; 4
     482:	83 60       	ori	r24, 0x03	; 3
     484:	84 b9       	out	0x04, r24	; 4
	
	// Trace pins Task Monitor (R2R)
	DDRB |= _BV(DDB2) | _BV(DDB3) | _BV(DDB4) | _BV(DDB5);
     486:	84 b1       	in	r24, 0x04	; 4
     488:	8c 63       	ori	r24, 0x3C	; 60
     48a:	84 b9       	out	0x04, r24	; 4
}
     48c:	0f 91       	pop	r16
     48e:	ef 90       	pop	r14
     490:	df 90       	pop	r13
     492:	cf 90       	pop	r12
     494:	bf 90       	pop	r11
     496:	af 90       	pop	r10
     498:	9f 90       	pop	r9
     49a:	8f 90       	pop	r8
     49c:	08 95       	ret

0000049e <switch_in>:
	
	 Called by the the traceTASK_SWITCHED_IN() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_in(uint8_t task_no) {
		PORTB &= 0b11000011;
     49e:	95 b1       	in	r25, 0x05	; 5
     4a0:	93 7c       	andi	r25, 0xC3	; 195
     4a2:	95 b9       	out	0x05, r25	; 5
		PORTB |= task_no << 2;
     4a4:	25 b1       	in	r18, 0x05	; 5
     4a6:	34 e0       	ldi	r19, 0x04	; 4
     4a8:	83 9f       	mul	r24, r19
     4aa:	c0 01       	movw	r24, r0
     4ac:	11 24       	eor	r1, r1
     4ae:	82 2b       	or	r24, r18
     4b0:	85 b9       	out	0x05, r24	; 5
     4b2:	08 95       	ret

000004b4 <switch_out>:
	
	 Called by the the traceTASK_SWITCHED_OUT() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_out(uint8_t task_no) {
		PORTB &= 0b11000011;
     4b4:	85 b1       	in	r24, 0x05	; 5
     4b6:	83 7c       	andi	r24, 0xC3	; 195
     4b8:	85 b9       	out	0x05, r24	; 5
     4ba:	08 95       	ret

000004bc <buffer_init>:
  @endcode

 @note The buffer structure must be initialized before any of the buffer functions must be called.
 @param *buffer Pointer to the buffer structure to be used.
 ***********************************************/
void buffer_init(buffer_struct_t *buffer) {
     4bc:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     4be:	10 a2       	std	Z+32, r1	; 0x20
	buffer->out_i = 0;
     4c0:	11 a2       	std	Z+33, r1	; 0x21
	buffer->no_in_buffer = 0;
     4c2:	12 a2       	std	Z+34, r1	; 0x22
     4c4:	08 95       	ret

000004c6 <buffer_get_item>:
 @return BUFFER_OK: item removed from buffer and returned in item.\n
    BUFFER_EMPTY: The buffer is empty, item is not updated.
 @param *buffer pointer to the buffer structure.
 @param *item pointer to the variable where the value of the item is returned.
 ***********************************************/
uint8_t buffer_get_item(buffer_struct_t *buffer, uint8_t *item) {
     4c6:	fc 01       	movw	r30, r24
	if (buffer->no_in_buffer > 0) {
     4c8:	82 a1       	ldd	r24, Z+34	; 0x22
     4ca:	88 23       	and	r24, r24
     4cc:	d9 f0       	breq	.+54     	; 0x504 <buffer_get_item+0x3e>
		*item = buffer->storage[buffer->out_i];
     4ce:	81 a1       	ldd	r24, Z+33	; 0x21
     4d0:	df 01       	movw	r26, r30
     4d2:	a8 0f       	add	r26, r24
     4d4:	b1 1d       	adc	r27, r1
     4d6:	8c 91       	ld	r24, X
     4d8:	db 01       	movw	r26, r22
     4da:	8c 93       	st	X, r24
		buffer->out_i = INCREMENT(buffer->out_i);
     4dc:	21 a1       	ldd	r18, Z+33	; 0x21
     4de:	30 e0       	ldi	r19, 0x00	; 0
     4e0:	2f 5f       	subi	r18, 0xFF	; 255
     4e2:	3f 4f       	sbci	r19, 0xFF	; 255
     4e4:	2f 71       	andi	r18, 0x1F	; 31
     4e6:	30 78       	andi	r19, 0x80	; 128
     4e8:	33 23       	and	r19, r19
     4ea:	34 f4       	brge	.+12     	; 0x4f8 <buffer_get_item+0x32>
     4ec:	21 50       	subi	r18, 0x01	; 1
     4ee:	31 09       	sbc	r19, r1
     4f0:	20 6e       	ori	r18, 0xE0	; 224
     4f2:	3f 6f       	ori	r19, 0xFF	; 255
     4f4:	2f 5f       	subi	r18, 0xFF	; 255
     4f6:	3f 4f       	sbci	r19, 0xFF	; 255
     4f8:	21 a3       	std	Z+33, r18	; 0x21
		buffer->no_in_buffer--;
     4fa:	82 a1       	ldd	r24, Z+34	; 0x22
     4fc:	81 50       	subi	r24, 0x01	; 1
     4fe:	82 a3       	std	Z+34, r24	; 0x22
		return BUFFER_OK;
     500:	80 e0       	ldi	r24, 0x00	; 0
     502:	08 95       	ret
	}
	return BUFFER_EMPTY;
     504:	81 e0       	ldi	r24, 0x01	; 1
}
     506:	08 95       	ret

00000508 <buffer_put_item>:
    BUFFER_FULL: The buffer is full, item is not stored.
 @param *buffer pointer to the buffer structure.
 @param item to be stored in the buffer.
 ***********************************************/
uint8_t buffer_put_item(buffer_struct_t *buffer, uint8_t item) {
	if (buffer->no_in_buffer<BUFFER_SIZE) {
     508:	fc 01       	movw	r30, r24
     50a:	42 a1       	ldd	r20, Z+34	; 0x22
     50c:	40 32       	cpi	r20, 0x20	; 32
     50e:	b8 f4       	brcc	.+46     	; 0x53e <buffer_put_item+0x36>
		buffer->storage[buffer->in_i] = item;
     510:	20 a1       	ldd	r18, Z+32	; 0x20
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	e2 0f       	add	r30, r18
     516:	f3 1f       	adc	r31, r19
     518:	60 83       	st	Z, r22
		buffer->in_i = INCREMENT(buffer->in_i);
     51a:	2f 5f       	subi	r18, 0xFF	; 255
     51c:	3f 4f       	sbci	r19, 0xFF	; 255
     51e:	2f 71       	andi	r18, 0x1F	; 31
     520:	30 78       	andi	r19, 0x80	; 128
     522:	33 23       	and	r19, r19
     524:	34 f4       	brge	.+12     	; 0x532 <buffer_put_item+0x2a>
     526:	21 50       	subi	r18, 0x01	; 1
     528:	31 09       	sbc	r19, r1
     52a:	20 6e       	ori	r18, 0xE0	; 224
     52c:	3f 6f       	ori	r19, 0xFF	; 255
     52e:	2f 5f       	subi	r18, 0xFF	; 255
     530:	3f 4f       	sbci	r19, 0xFF	; 255
     532:	fc 01       	movw	r30, r24
     534:	20 a3       	std	Z+32, r18	; 0x20
		buffer->no_in_buffer++;
     536:	4f 5f       	subi	r20, 0xFF	; 255
     538:	42 a3       	std	Z+34, r20	; 0x22
		return BUFFER_OK;
     53a:	80 e0       	ldi	r24, 0x00	; 0
     53c:	08 95       	ret
	}
	return BUFFER_FULL;
     53e:	82 e0       	ldi	r24, 0x02	; 2
}
     540:	08 95       	ret

00000542 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     542:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     544:	03 96       	adiw	r24, 0x03	; 3
     546:	92 83       	std	Z+2, r25	; 0x02
     548:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     54a:	2f ef       	ldi	r18, 0xFF	; 255
     54c:	3f ef       	ldi	r19, 0xFF	; 255
     54e:	34 83       	std	Z+4, r19	; 0x04
     550:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     552:	96 83       	std	Z+6, r25	; 0x06
     554:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     556:	90 87       	std	Z+8, r25	; 0x08
     558:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     55a:	10 82       	st	Z, r1
     55c:	08 95       	ret

0000055e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     55e:	fc 01       	movw	r30, r24
     560:	11 86       	std	Z+9, r1	; 0x09
     562:	10 86       	std	Z+8, r1	; 0x08
     564:	08 95       	ret

00000566 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     566:	cf 93       	push	r28
     568:	df 93       	push	r29
     56a:	9c 01       	movw	r18, r24
     56c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     56e:	dc 01       	movw	r26, r24
     570:	11 96       	adiw	r26, 0x01	; 1
     572:	cd 91       	ld	r28, X+
     574:	dc 91       	ld	r29, X
     576:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     578:	d3 83       	std	Z+3, r29	; 0x03
     57a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     57c:	8c 81       	ldd	r24, Y+4	; 0x04
     57e:	9d 81       	ldd	r25, Y+5	; 0x05
     580:	95 83       	std	Z+5, r25	; 0x05
     582:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     584:	8c 81       	ldd	r24, Y+4	; 0x04
     586:	9d 81       	ldd	r25, Y+5	; 0x05
     588:	dc 01       	movw	r26, r24
     58a:	13 96       	adiw	r26, 0x03	; 3
     58c:	7c 93       	st	X, r23
     58e:	6e 93       	st	-X, r22
     590:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     592:	7d 83       	std	Y+5, r23	; 0x05
     594:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     596:	31 87       	std	Z+9, r19	; 0x09
     598:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     59a:	f9 01       	movw	r30, r18
     59c:	80 81       	ld	r24, Z
     59e:	8f 5f       	subi	r24, 0xFF	; 255
     5a0:	80 83       	st	Z, r24
}
     5a2:	df 91       	pop	r29
     5a4:	cf 91       	pop	r28
     5a6:	08 95       	ret

000005a8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5a8:	cf 93       	push	r28
     5aa:	df 93       	push	r29
     5ac:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     5ae:	48 81       	ld	r20, Y
     5b0:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     5b2:	4f 3f       	cpi	r20, 0xFF	; 255
     5b4:	2f ef       	ldi	r18, 0xFF	; 255
     5b6:	52 07       	cpc	r21, r18
     5b8:	21 f4       	brne	.+8      	; 0x5c2 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     5ba:	fc 01       	movw	r30, r24
     5bc:	a7 81       	ldd	r26, Z+7	; 0x07
     5be:	b0 85       	ldd	r27, Z+8	; 0x08
     5c0:	0d c0       	rjmp	.+26     	; 0x5dc <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5c2:	dc 01       	movw	r26, r24
     5c4:	13 96       	adiw	r26, 0x03	; 3
     5c6:	01 c0       	rjmp	.+2      	; 0x5ca <vListInsert+0x22>
     5c8:	df 01       	movw	r26, r30
     5ca:	12 96       	adiw	r26, 0x02	; 2
     5cc:	ed 91       	ld	r30, X+
     5ce:	fc 91       	ld	r31, X
     5d0:	13 97       	sbiw	r26, 0x03	; 3
     5d2:	20 81       	ld	r18, Z
     5d4:	31 81       	ldd	r19, Z+1	; 0x01
     5d6:	42 17       	cp	r20, r18
     5d8:	53 07       	cpc	r21, r19
     5da:	b0 f7       	brcc	.-20     	; 0x5c8 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     5dc:	12 96       	adiw	r26, 0x02	; 2
     5de:	ed 91       	ld	r30, X+
     5e0:	fc 91       	ld	r31, X
     5e2:	13 97       	sbiw	r26, 0x03	; 3
     5e4:	fb 83       	std	Y+3, r31	; 0x03
     5e6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     5e8:	d5 83       	std	Z+5, r29	; 0x05
     5ea:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     5ec:	bd 83       	std	Y+5, r27	; 0x05
     5ee:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     5f0:	13 96       	adiw	r26, 0x03	; 3
     5f2:	dc 93       	st	X, r29
     5f4:	ce 93       	st	-X, r28
     5f6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5f8:	99 87       	std	Y+9, r25	; 0x09
     5fa:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     5fc:	fc 01       	movw	r30, r24
     5fe:	20 81       	ld	r18, Z
     600:	2f 5f       	subi	r18, 0xFF	; 255
     602:	20 83       	st	Z, r18
}
     604:	df 91       	pop	r29
     606:	cf 91       	pop	r28
     608:	08 95       	ret

0000060a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     60a:	cf 93       	push	r28
     60c:	df 93       	push	r29
     60e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     610:	a0 85       	ldd	r26, Z+8	; 0x08
     612:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     614:	c2 81       	ldd	r28, Z+2	; 0x02
     616:	d3 81       	ldd	r29, Z+3	; 0x03
     618:	84 81       	ldd	r24, Z+4	; 0x04
     61a:	95 81       	ldd	r25, Z+5	; 0x05
     61c:	9d 83       	std	Y+5, r25	; 0x05
     61e:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     620:	c4 81       	ldd	r28, Z+4	; 0x04
     622:	d5 81       	ldd	r29, Z+5	; 0x05
     624:	82 81       	ldd	r24, Z+2	; 0x02
     626:	93 81       	ldd	r25, Z+3	; 0x03
     628:	9b 83       	std	Y+3, r25	; 0x03
     62a:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     62c:	11 96       	adiw	r26, 0x01	; 1
     62e:	8d 91       	ld	r24, X+
     630:	9c 91       	ld	r25, X
     632:	12 97       	sbiw	r26, 0x02	; 2
     634:	e8 17       	cp	r30, r24
     636:	f9 07       	cpc	r31, r25
     638:	31 f4       	brne	.+12     	; 0x646 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     63a:	84 81       	ldd	r24, Z+4	; 0x04
     63c:	95 81       	ldd	r25, Z+5	; 0x05
     63e:	12 96       	adiw	r26, 0x02	; 2
     640:	9c 93       	st	X, r25
     642:	8e 93       	st	-X, r24
     644:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     646:	11 86       	std	Z+9, r1	; 0x09
     648:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     64a:	8c 91       	ld	r24, X
     64c:	81 50       	subi	r24, 0x01	; 1
     64e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     650:	df 91       	pop	r29
     652:	cf 91       	pop	r28
     654:	08 95       	ret

00000656 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     656:	31 e1       	ldi	r19, 0x11	; 17
     658:	fc 01       	movw	r30, r24
     65a:	30 83       	st	Z, r19
     65c:	31 97       	sbiw	r30, 0x01	; 1
     65e:	22 e2       	ldi	r18, 0x22	; 34
     660:	20 83       	st	Z, r18
     662:	31 97       	sbiw	r30, 0x01	; 1
     664:	a3 e3       	ldi	r26, 0x33	; 51
     666:	a0 83       	st	Z, r26
     668:	31 97       	sbiw	r30, 0x01	; 1
     66a:	60 83       	st	Z, r22
     66c:	31 97       	sbiw	r30, 0x01	; 1
     66e:	70 83       	st	Z, r23
     670:	31 97       	sbiw	r30, 0x01	; 1
     672:	10 82       	st	Z, r1
     674:	31 97       	sbiw	r30, 0x01	; 1
     676:	60 e8       	ldi	r22, 0x80	; 128
     678:	60 83       	st	Z, r22
     67a:	31 97       	sbiw	r30, 0x01	; 1
     67c:	10 82       	st	Z, r1
     67e:	31 97       	sbiw	r30, 0x01	; 1
     680:	62 e0       	ldi	r22, 0x02	; 2
     682:	60 83       	st	Z, r22
     684:	31 97       	sbiw	r30, 0x01	; 1
     686:	63 e0       	ldi	r22, 0x03	; 3
     688:	60 83       	st	Z, r22
     68a:	31 97       	sbiw	r30, 0x01	; 1
     68c:	64 e0       	ldi	r22, 0x04	; 4
     68e:	60 83       	st	Z, r22
     690:	31 97       	sbiw	r30, 0x01	; 1
     692:	65 e0       	ldi	r22, 0x05	; 5
     694:	60 83       	st	Z, r22
     696:	31 97       	sbiw	r30, 0x01	; 1
     698:	66 e0       	ldi	r22, 0x06	; 6
     69a:	60 83       	st	Z, r22
     69c:	31 97       	sbiw	r30, 0x01	; 1
     69e:	67 e0       	ldi	r22, 0x07	; 7
     6a0:	60 83       	st	Z, r22
     6a2:	31 97       	sbiw	r30, 0x01	; 1
     6a4:	68 e0       	ldi	r22, 0x08	; 8
     6a6:	60 83       	st	Z, r22
     6a8:	31 97       	sbiw	r30, 0x01	; 1
     6aa:	69 e0       	ldi	r22, 0x09	; 9
     6ac:	60 83       	st	Z, r22
     6ae:	31 97       	sbiw	r30, 0x01	; 1
     6b0:	60 e1       	ldi	r22, 0x10	; 16
     6b2:	60 83       	st	Z, r22
     6b4:	31 97       	sbiw	r30, 0x01	; 1
     6b6:	30 83       	st	Z, r19
     6b8:	31 97       	sbiw	r30, 0x01	; 1
     6ba:	32 e1       	ldi	r19, 0x12	; 18
     6bc:	30 83       	st	Z, r19
     6be:	31 97       	sbiw	r30, 0x01	; 1
     6c0:	33 e1       	ldi	r19, 0x13	; 19
     6c2:	30 83       	st	Z, r19
     6c4:	31 97       	sbiw	r30, 0x01	; 1
     6c6:	34 e1       	ldi	r19, 0x14	; 20
     6c8:	30 83       	st	Z, r19
     6ca:	31 97       	sbiw	r30, 0x01	; 1
     6cc:	35 e1       	ldi	r19, 0x15	; 21
     6ce:	30 83       	st	Z, r19
     6d0:	31 97       	sbiw	r30, 0x01	; 1
     6d2:	36 e1       	ldi	r19, 0x16	; 22
     6d4:	30 83       	st	Z, r19
     6d6:	31 97       	sbiw	r30, 0x01	; 1
     6d8:	37 e1       	ldi	r19, 0x17	; 23
     6da:	30 83       	st	Z, r19
     6dc:	31 97       	sbiw	r30, 0x01	; 1
     6de:	38 e1       	ldi	r19, 0x18	; 24
     6e0:	30 83       	st	Z, r19
     6e2:	31 97       	sbiw	r30, 0x01	; 1
     6e4:	39 e1       	ldi	r19, 0x19	; 25
     6e6:	30 83       	st	Z, r19
     6e8:	31 97       	sbiw	r30, 0x01	; 1
     6ea:	30 e2       	ldi	r19, 0x20	; 32
     6ec:	30 83       	st	Z, r19
     6ee:	31 97       	sbiw	r30, 0x01	; 1
     6f0:	31 e2       	ldi	r19, 0x21	; 33
     6f2:	30 83       	st	Z, r19
     6f4:	31 97       	sbiw	r30, 0x01	; 1
     6f6:	20 83       	st	Z, r18
     6f8:	31 97       	sbiw	r30, 0x01	; 1
     6fa:	23 e2       	ldi	r18, 0x23	; 35
     6fc:	20 83       	st	Z, r18
     6fe:	31 97       	sbiw	r30, 0x01	; 1
     700:	40 83       	st	Z, r20
     702:	31 97       	sbiw	r30, 0x01	; 1
     704:	50 83       	st	Z, r21
     706:	31 97       	sbiw	r30, 0x01	; 1
     708:	26 e2       	ldi	r18, 0x26	; 38
     70a:	20 83       	st	Z, r18
     70c:	31 97       	sbiw	r30, 0x01	; 1
     70e:	27 e2       	ldi	r18, 0x27	; 39
     710:	20 83       	st	Z, r18
     712:	31 97       	sbiw	r30, 0x01	; 1
     714:	28 e2       	ldi	r18, 0x28	; 40
     716:	20 83       	st	Z, r18
     718:	31 97       	sbiw	r30, 0x01	; 1
     71a:	29 e2       	ldi	r18, 0x29	; 41
     71c:	20 83       	st	Z, r18
     71e:	31 97       	sbiw	r30, 0x01	; 1
     720:	20 e3       	ldi	r18, 0x30	; 48
     722:	20 83       	st	Z, r18
     724:	31 97       	sbiw	r30, 0x01	; 1
     726:	21 e3       	ldi	r18, 0x31	; 49
     728:	20 83       	st	Z, r18
     72a:	86 97       	sbiw	r24, 0x26	; 38
     72c:	08 95       	ret

0000072e <xPortStartScheduler>:
     72e:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     732:	85 ee       	ldi	r24, 0xE5	; 229
     734:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     738:	8b e0       	ldi	r24, 0x0B	; 11
     73a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     73e:	ef e6       	ldi	r30, 0x6F	; 111
     740:	f0 e0       	ldi	r31, 0x00	; 0
     742:	80 81       	ld	r24, Z
     744:	82 60       	ori	r24, 0x02	; 2
     746:	80 83       	st	Z, r24
     748:	a0 91 56 06 	lds	r26, 0x0656	; 0x800656 <pxCurrentTCB>
     74c:	b0 91 57 06 	lds	r27, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
     750:	cd 91       	ld	r28, X+
     752:	cd bf       	out	0x3d, r28	; 61
     754:	dd 91       	ld	r29, X+
     756:	de bf       	out	0x3e, r29	; 62
     758:	ff 91       	pop	r31
     75a:	ef 91       	pop	r30
     75c:	df 91       	pop	r29
     75e:	cf 91       	pop	r28
     760:	bf 91       	pop	r27
     762:	af 91       	pop	r26
     764:	9f 91       	pop	r25
     766:	8f 91       	pop	r24
     768:	7f 91       	pop	r23
     76a:	6f 91       	pop	r22
     76c:	5f 91       	pop	r21
     76e:	4f 91       	pop	r20
     770:	3f 91       	pop	r19
     772:	2f 91       	pop	r18
     774:	1f 91       	pop	r17
     776:	0f 91       	pop	r16
     778:	ff 90       	pop	r15
     77a:	ef 90       	pop	r14
     77c:	df 90       	pop	r13
     77e:	cf 90       	pop	r12
     780:	bf 90       	pop	r11
     782:	af 90       	pop	r10
     784:	9f 90       	pop	r9
     786:	8f 90       	pop	r8
     788:	7f 90       	pop	r7
     78a:	6f 90       	pop	r6
     78c:	5f 90       	pop	r5
     78e:	4f 90       	pop	r4
     790:	3f 90       	pop	r3
     792:	2f 90       	pop	r2
     794:	1f 90       	pop	r1
     796:	0f 90       	pop	r0
     798:	0f be       	out	0x3f, r0	; 63
     79a:	0f 90       	pop	r0
     79c:	08 95       	ret
     79e:	81 e0       	ldi	r24, 0x01	; 1
     7a0:	08 95       	ret

000007a2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     7a2:	0f 92       	push	r0
     7a4:	0f b6       	in	r0, 0x3f	; 63
     7a6:	f8 94       	cli
     7a8:	0f 92       	push	r0
     7aa:	1f 92       	push	r1
     7ac:	11 24       	eor	r1, r1
     7ae:	2f 92       	push	r2
     7b0:	3f 92       	push	r3
     7b2:	4f 92       	push	r4
     7b4:	5f 92       	push	r5
     7b6:	6f 92       	push	r6
     7b8:	7f 92       	push	r7
     7ba:	8f 92       	push	r8
     7bc:	9f 92       	push	r9
     7be:	af 92       	push	r10
     7c0:	bf 92       	push	r11
     7c2:	cf 92       	push	r12
     7c4:	df 92       	push	r13
     7c6:	ef 92       	push	r14
     7c8:	ff 92       	push	r15
     7ca:	0f 93       	push	r16
     7cc:	1f 93       	push	r17
     7ce:	2f 93       	push	r18
     7d0:	3f 93       	push	r19
     7d2:	4f 93       	push	r20
     7d4:	5f 93       	push	r21
     7d6:	6f 93       	push	r22
     7d8:	7f 93       	push	r23
     7da:	8f 93       	push	r24
     7dc:	9f 93       	push	r25
     7de:	af 93       	push	r26
     7e0:	bf 93       	push	r27
     7e2:	cf 93       	push	r28
     7e4:	df 93       	push	r29
     7e6:	ef 93       	push	r30
     7e8:	ff 93       	push	r31
     7ea:	a0 91 56 06 	lds	r26, 0x0656	; 0x800656 <pxCurrentTCB>
     7ee:	b0 91 57 06 	lds	r27, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
     7f2:	0d b6       	in	r0, 0x3d	; 61
     7f4:	0d 92       	st	X+, r0
     7f6:	0e b6       	in	r0, 0x3e	; 62
     7f8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     7fa:	0e 94 c1 0c 	call	0x1982	; 0x1982 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     7fe:	a0 91 56 06 	lds	r26, 0x0656	; 0x800656 <pxCurrentTCB>
     802:	b0 91 57 06 	lds	r27, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
     806:	cd 91       	ld	r28, X+
     808:	cd bf       	out	0x3d, r28	; 61
     80a:	dd 91       	ld	r29, X+
     80c:	de bf       	out	0x3e, r29	; 62
     80e:	ff 91       	pop	r31
     810:	ef 91       	pop	r30
     812:	df 91       	pop	r29
     814:	cf 91       	pop	r28
     816:	bf 91       	pop	r27
     818:	af 91       	pop	r26
     81a:	9f 91       	pop	r25
     81c:	8f 91       	pop	r24
     81e:	7f 91       	pop	r23
     820:	6f 91       	pop	r22
     822:	5f 91       	pop	r21
     824:	4f 91       	pop	r20
     826:	3f 91       	pop	r19
     828:	2f 91       	pop	r18
     82a:	1f 91       	pop	r17
     82c:	0f 91       	pop	r16
     82e:	ff 90       	pop	r15
     830:	ef 90       	pop	r14
     832:	df 90       	pop	r13
     834:	cf 90       	pop	r12
     836:	bf 90       	pop	r11
     838:	af 90       	pop	r10
     83a:	9f 90       	pop	r9
     83c:	8f 90       	pop	r8
     83e:	7f 90       	pop	r7
     840:	6f 90       	pop	r6
     842:	5f 90       	pop	r5
     844:	4f 90       	pop	r4
     846:	3f 90       	pop	r3
     848:	2f 90       	pop	r2
     84a:	1f 90       	pop	r1
     84c:	0f 90       	pop	r0
     84e:	0f be       	out	0x3f, r0	; 63
     850:	0f 90       	pop	r0

	asm volatile ( "ret" );
     852:	08 95       	ret

00000854 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     854:	0f 92       	push	r0
     856:	0f b6       	in	r0, 0x3f	; 63
     858:	f8 94       	cli
     85a:	0f 92       	push	r0
     85c:	1f 92       	push	r1
     85e:	11 24       	eor	r1, r1
     860:	2f 92       	push	r2
     862:	3f 92       	push	r3
     864:	4f 92       	push	r4
     866:	5f 92       	push	r5
     868:	6f 92       	push	r6
     86a:	7f 92       	push	r7
     86c:	8f 92       	push	r8
     86e:	9f 92       	push	r9
     870:	af 92       	push	r10
     872:	bf 92       	push	r11
     874:	cf 92       	push	r12
     876:	df 92       	push	r13
     878:	ef 92       	push	r14
     87a:	ff 92       	push	r15
     87c:	0f 93       	push	r16
     87e:	1f 93       	push	r17
     880:	2f 93       	push	r18
     882:	3f 93       	push	r19
     884:	4f 93       	push	r20
     886:	5f 93       	push	r21
     888:	6f 93       	push	r22
     88a:	7f 93       	push	r23
     88c:	8f 93       	push	r24
     88e:	9f 93       	push	r25
     890:	af 93       	push	r26
     892:	bf 93       	push	r27
     894:	cf 93       	push	r28
     896:	df 93       	push	r29
     898:	ef 93       	push	r30
     89a:	ff 93       	push	r31
     89c:	a0 91 56 06 	lds	r26, 0x0656	; 0x800656 <pxCurrentTCB>
     8a0:	b0 91 57 06 	lds	r27, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
     8a4:	0d b6       	in	r0, 0x3d	; 61
     8a6:	0d 92       	st	X+, r0
     8a8:	0e b6       	in	r0, 0x3e	; 62
     8aa:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     8ac:	0e 94 25 0b 	call	0x164a	; 0x164a <xTaskIncrementTick>
     8b0:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     8b2:	0e 94 c1 0c 	call	0x1982	; 0x1982 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     8b6:	a0 91 56 06 	lds	r26, 0x0656	; 0x800656 <pxCurrentTCB>
     8ba:	b0 91 57 06 	lds	r27, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
     8be:	cd 91       	ld	r28, X+
     8c0:	cd bf       	out	0x3d, r28	; 61
     8c2:	dd 91       	ld	r29, X+
     8c4:	de bf       	out	0x3e, r29	; 62
     8c6:	ff 91       	pop	r31
     8c8:	ef 91       	pop	r30
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	bf 91       	pop	r27
     8d0:	af 91       	pop	r26
     8d2:	9f 91       	pop	r25
     8d4:	8f 91       	pop	r24
     8d6:	7f 91       	pop	r23
     8d8:	6f 91       	pop	r22
     8da:	5f 91       	pop	r21
     8dc:	4f 91       	pop	r20
     8de:	3f 91       	pop	r19
     8e0:	2f 91       	pop	r18
     8e2:	1f 91       	pop	r17
     8e4:	0f 91       	pop	r16
     8e6:	ff 90       	pop	r15
     8e8:	ef 90       	pop	r14
     8ea:	df 90       	pop	r13
     8ec:	cf 90       	pop	r12
     8ee:	bf 90       	pop	r11
     8f0:	af 90       	pop	r10
     8f2:	9f 90       	pop	r9
     8f4:	8f 90       	pop	r8
     8f6:	7f 90       	pop	r7
     8f8:	6f 90       	pop	r6
     8fa:	5f 90       	pop	r5
     8fc:	4f 90       	pop	r4
     8fe:	3f 90       	pop	r3
     900:	2f 90       	pop	r2
     902:	1f 90       	pop	r1
     904:	0f 90       	pop	r0
     906:	0f be       	out	0x3f, r0	; 63
     908:	0f 90       	pop	r0

	asm volatile ( "ret" );
     90a:	08 95       	ret

0000090c <__vector_13>:
	 */
// 	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
// 	void SIG_OUTPUT_COMPARE1A( void )
ISR(TIMER1_COMPA_vect, ISR_NAKED)  // IHA
	{
		vPortYieldFromTick();
     90c:	0e 94 2a 04 	call	0x854	; 0x854 <vPortYieldFromTick>
		asm volatile ( "reti" );
     910:	18 95       	reti

00000912 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     912:	cf 93       	push	r28
     914:	df 93       	push	r29
     916:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     918:	0e 94 1f 0b 	call	0x163e	; 0x163e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     91c:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <pucAlignedHeap.2084>
     920:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <pucAlignedHeap.2084+0x1>
     924:	89 2b       	or	r24, r25
     926:	31 f4       	brne	.+12     	; 0x934 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     928:	80 e1       	ldi	r24, 0x10	; 16
     92a:	92 e0       	ldi	r25, 0x02	; 2
     92c:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <pucAlignedHeap.2084+0x1>
     930:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <pucAlignedHeap.2084>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     934:	20 91 0d 02 	lds	r18, 0x020D	; 0x80020d <xNextFreeByte>
     938:	30 91 0e 02 	lds	r19, 0x020E	; 0x80020e <xNextFreeByte+0x1>
     93c:	c9 01       	movw	r24, r18
     93e:	8c 0f       	add	r24, r28
     940:	9d 1f       	adc	r25, r29
     942:	87 3e       	cpi	r24, 0xE7	; 231
     944:	43 e0       	ldi	r20, 0x03	; 3
     946:	94 07       	cpc	r25, r20
     948:	70 f4       	brcc	.+28     	; 0x966 <pvPortMalloc+0x54>
     94a:	28 17       	cp	r18, r24
     94c:	39 07       	cpc	r19, r25
     94e:	70 f4       	brcc	.+28     	; 0x96c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     950:	c0 91 0b 02 	lds	r28, 0x020B	; 0x80020b <pucAlignedHeap.2084>
     954:	d0 91 0c 02 	lds	r29, 0x020C	; 0x80020c <pucAlignedHeap.2084+0x1>
     958:	c2 0f       	add	r28, r18
     95a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     95c:	90 93 0e 02 	sts	0x020E, r25	; 0x80020e <xNextFreeByte+0x1>
     960:	80 93 0d 02 	sts	0x020D, r24	; 0x80020d <xNextFreeByte>
     964:	05 c0       	rjmp	.+10     	; 0x970 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     966:	c0 e0       	ldi	r28, 0x00	; 0
     968:	d0 e0       	ldi	r29, 0x00	; 0
     96a:	02 c0       	rjmp	.+4      	; 0x970 <pvPortMalloc+0x5e>
     96c:	c0 e0       	ldi	r28, 0x00	; 0
     96e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     970:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     974:	ce 01       	movw	r24, r28
     976:	df 91       	pop	r29
     978:	cf 91       	pop	r28
     97a:	08 95       	ret

0000097c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     97c:	08 95       	ret

0000097e <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
     97e:	4f 92       	push	r4
     980:	5f 92       	push	r5
     982:	6f 92       	push	r6
     984:	7f 92       	push	r7
     986:	8f 92       	push	r8
     988:	9f 92       	push	r9
     98a:	af 92       	push	r10
     98c:	bf 92       	push	r11
     98e:	cf 92       	push	r12
     990:	df 92       	push	r13
     992:	ff 92       	push	r15
     994:	0f 93       	push	r16
     996:	1f 93       	push	r17
     998:	cf 93       	push	r28
     99a:	df 93       	push	r29
     99c:	cd b7       	in	r28, 0x3d	; 61
     99e:	de b7       	in	r29, 0x3e	; 62
     9a0:	f8 2e       	mov	r15, r24
     9a2:	2a 01       	movw	r4, r20
     9a4:	3b 01       	movw	r6, r22
     9a6:	88 e0       	ldi	r24, 0x08	; 8
     9a8:	90 e0       	ldi	r25, 0x00	; 0
     9aa:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <malloc>
     9ae:	8c 01       	movw	r16, r24
     9b0:	8f 2d       	mov	r24, r15
     9b2:	90 e0       	ldi	r25, 0x00	; 0
     9b4:	88 0f       	add	r24, r24
     9b6:	99 1f       	adc	r25, r25
     9b8:	fc 01       	movw	r30, r24
     9ba:	e9 50       	subi	r30, 0x09	; 9
     9bc:	fa 4f       	sbci	r31, 0xFA	; 250
     9be:	11 83       	std	Z+1, r17	; 0x01
     9c0:	00 83       	st	Z, r16
     9c2:	fc 01       	movw	r30, r24
     9c4:	e8 5f       	subi	r30, 0xF8	; 248
     9c6:	fe 4f       	sbci	r31, 0xFE	; 254
     9c8:	80 81       	ld	r24, Z
     9ca:	91 81       	ldd	r25, Z+1	; 0x01
     9cc:	d8 01       	movw	r26, r16
     9ce:	11 96       	adiw	r26, 0x01	; 1
     9d0:	9c 93       	st	X, r25
     9d2:	8e 93       	st	-X, r24
     9d4:	13 96       	adiw	r26, 0x03	; 3
     9d6:	bc 92       	st	X, r11
     9d8:	ae 92       	st	-X, r10
     9da:	12 97       	sbiw	r26, 0x02	; 2
     9dc:	15 96       	adiw	r26, 0x05	; 5
     9de:	dc 92       	st	X, r13
     9e0:	ce 92       	st	-X, r12
     9e2:	14 97       	sbiw	r26, 0x04	; 4
     9e4:	17 96       	adiw	r26, 0x07	; 7
     9e6:	9c 92       	st	X, r9
     9e8:	8e 92       	st	-X, r8
     9ea:	16 97       	sbiw	r26, 0x06	; 6
     9ec:	ff b6       	in	r15, 0x3f	; 63
     9ee:	f8 94       	cli
     9f0:	ed 91       	ld	r30, X+
     9f2:	fc 91       	ld	r31, X
     9f4:	11 97       	sbiw	r26, 0x01	; 1
     9f6:	36 97       	sbiw	r30, 0x06	; 6
     9f8:	80 81       	ld	r24, Z
     9fa:	82 60       	ori	r24, 0x02	; 2
     9fc:	80 83       	st	Z, r24
     9fe:	cd 90       	ld	r12, X+
     a00:	dc 90       	ld	r13, X
     a02:	d3 01       	movw	r26, r6
     a04:	c2 01       	movw	r24, r4
     a06:	88 0f       	add	r24, r24
     a08:	99 1f       	adc	r25, r25
     a0a:	aa 1f       	adc	r26, r26
     a0c:	bb 1f       	adc	r27, r27
     a0e:	88 0f       	add	r24, r24
     a10:	99 1f       	adc	r25, r25
     a12:	aa 1f       	adc	r26, r26
     a14:	bb 1f       	adc	r27, r27
     a16:	9c 01       	movw	r18, r24
     a18:	ad 01       	movw	r20, r26
     a1a:	22 0f       	add	r18, r18
     a1c:	33 1f       	adc	r19, r19
     a1e:	44 1f       	adc	r20, r20
     a20:	55 1f       	adc	r21, r21
     a22:	60 e0       	ldi	r22, 0x00	; 0
     a24:	70 e0       	ldi	r23, 0x00	; 0
     a26:	81 ee       	ldi	r24, 0xE1	; 225
     a28:	90 e0       	ldi	r25, 0x00	; 0
     a2a:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <__udivmodsi4>
     a2e:	21 50       	subi	r18, 0x01	; 1
     a30:	f6 01       	movw	r30, r12
     a32:	32 97       	sbiw	r30, 0x02	; 2
     a34:	20 83       	st	Z, r18
     a36:	d8 01       	movw	r26, r16
     a38:	ed 91       	ld	r30, X+
     a3a:	fc 91       	ld	r31, X
     a3c:	11 97       	sbiw	r26, 0x01	; 1
     a3e:	35 97       	sbiw	r30, 0x05	; 5
     a40:	88 e9       	ldi	r24, 0x98	; 152
     a42:	80 83       	st	Z, r24
     a44:	ed 91       	ld	r30, X+
     a46:	fc 91       	ld	r31, X
     a48:	34 97       	sbiw	r30, 0x04	; 4
     a4a:	86 e0       	ldi	r24, 0x06	; 6
     a4c:	80 83       	st	Z, r24
     a4e:	ff be       	out	0x3f, r15	; 63
     a50:	c8 01       	movw	r24, r16
     a52:	df 91       	pop	r29
     a54:	cf 91       	pop	r28
     a56:	1f 91       	pop	r17
     a58:	0f 91       	pop	r16
     a5a:	ff 90       	pop	r15
     a5c:	df 90       	pop	r13
     a5e:	cf 90       	pop	r12
     a60:	bf 90       	pop	r11
     a62:	af 90       	pop	r10
     a64:	9f 90       	pop	r9
     a66:	8f 90       	pop	r8
     a68:	7f 90       	pop	r7
     a6a:	6f 90       	pop	r6
     a6c:	5f 90       	pop	r5
     a6e:	4f 90       	pop	r4
     a70:	08 95       	ret

00000a72 <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
     a72:	ef 92       	push	r14
     a74:	ff 92       	push	r15
     a76:	0f 93       	push	r16
     a78:	1f 93       	push	r17
     a7a:	cf 93       	push	r28
     a7c:	df 93       	push	r29
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     a7e:	fc 01       	movw	r30, r24
     a80:	a2 81       	ldd	r26, Z+2	; 0x02
     a82:	b3 81       	ldd	r27, Z+3	; 0x03
     a84:	10 97       	sbiw	r26, 0x00	; 0
     a86:	79 f0       	breq	.+30     	; 0xaa6 <serial_send_bytes+0x34>
     a88:	e4 2f       	mov	r30, r20
     a8a:	f0 e0       	ldi	r31, 0x00	; 0
     a8c:	92 96       	adiw	r26, 0x22	; 34
     a8e:	5c 91       	ld	r21, X
     a90:	20 e2       	ldi	r18, 0x20	; 32
     a92:	30 e0       	ldi	r19, 0x00	; 0
     a94:	25 1b       	sub	r18, r21
     a96:	31 09       	sbc	r19, r1
     a98:	2e 17       	cp	r18, r30
     a9a:	3f 07       	cpc	r19, r31
     a9c:	1c f1       	brlt	.+70     	; 0xae4 <serial_send_bytes+0x72>
     a9e:	7c 01       	movw	r14, r24
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     aa0:	41 11       	cpse	r20, r1
     aa2:	04 c0       	rjmp	.+8      	; 0xaac <serial_send_bytes+0x3a>
     aa4:	16 c0       	rjmp	.+44     	; 0xad2 <serial_send_bytes+0x60>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     aa6:	42 30       	cpi	r20, 0x02	; 2
     aa8:	f8 f4       	brcc	.+62     	; 0xae8 <serial_send_bytes+0x76>
     aaa:	f9 cf       	rjmp	.-14     	; 0xa9e <serial_send_bytes+0x2c>
     aac:	eb 01       	movw	r28, r22
     aae:	41 50       	subi	r20, 0x01	; 1
     ab0:	04 2f       	mov	r16, r20
     ab2:	10 e0       	ldi	r17, 0x00	; 0
     ab4:	0f 5f       	subi	r16, 0xFF	; 255
     ab6:	1f 4f       	sbci	r17, 0xFF	; 255
     ab8:	06 0f       	add	r16, r22
     aba:	17 1f       	adc	r17, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
     abc:	69 91       	ld	r22, Y+
     abe:	d7 01       	movw	r26, r14
     ac0:	12 96       	adiw	r26, 0x02	; 2
     ac2:	8d 91       	ld	r24, X+
     ac4:	9c 91       	ld	r25, X
     ac6:	13 97       	sbiw	r26, 0x03	; 3
     ac8:	0e 94 84 02 	call	0x508	; 0x508 <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     acc:	c0 17       	cp	r28, r16
     ace:	d1 07       	cpc	r29, r17
     ad0:	a9 f7       	brne	.-22     	; 0xabc <serial_send_bytes+0x4a>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
     ad2:	d7 01       	movw	r26, r14
     ad4:	ed 91       	ld	r30, X+
     ad6:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
     ad8:	35 97       	sbiw	r30, 0x05	; 5
     ada:	80 81       	ld	r24, Z
     adc:	80 62       	ori	r24, 0x20	; 32
     ade:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
     ae0:	80 e0       	ldi	r24, 0x00	; 0
     ae2:	03 c0       	rjmp	.+6      	; 0xaea <serial_send_bytes+0x78>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
     ae4:	82 e0       	ldi	r24, 0x02	; 2
     ae6:	01 c0       	rjmp	.+2      	; 0xaea <serial_send_bytes+0x78>
     ae8:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
     aea:	df 91       	pop	r29
     aec:	cf 91       	pop	r28
     aee:	1f 91       	pop	r17
     af0:	0f 91       	pop	r16
     af2:	ff 90       	pop	r15
     af4:	ef 90       	pop	r14
     af6:	08 95       	ret

00000af8 <__vector_20>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
     af8:	1f 92       	push	r1
     afa:	0f 92       	push	r0
     afc:	0f b6       	in	r0, 0x3f	; 63
     afe:	0f 92       	push	r0
     b00:	11 24       	eor	r1, r1
     b02:	2f 93       	push	r18
     b04:	3f 93       	push	r19
     b06:	4f 93       	push	r20
     b08:	5f 93       	push	r21
     b0a:	6f 93       	push	r22
     b0c:	7f 93       	push	r23
     b0e:	8f 93       	push	r24
     b10:	9f 93       	push	r25
     b12:	af 93       	push	r26
     b14:	bf 93       	push	r27
     b16:	cf 93       	push	r28
     b18:	ef 93       	push	r30
     b1a:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     b1c:	e0 91 f7 05 	lds	r30, 0x05F7	; 0x8005f7 <_ser_handle>
     b20:	f0 91 f8 05 	lds	r31, 0x05F8	; 0x8005f8 <_ser_handle+0x1>
     b24:	30 97       	sbiw	r30, 0x00	; 0
     b26:	a1 f0       	breq	.+40     	; 0xb50 <__vector_20+0x58>
		item = UDR0;
     b28:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
     b2c:	6c 2f       	mov	r22, r28
     b2e:	84 81       	ldd	r24, Z+4	; 0x04
     b30:	95 81       	ldd	r25, Z+5	; 0x05
     b32:	0e 94 84 02 	call	0x508	; 0x508 <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
     b36:	80 91 f7 05 	lds	r24, 0x05F7	; 0x8005f7 <_ser_handle>
     b3a:	90 91 f8 05 	lds	r25, 0x05F8	; 0x8005f8 <_ser_handle+0x1>
     b3e:	dc 01       	movw	r26, r24
     b40:	16 96       	adiw	r26, 0x06	; 6
     b42:	ed 91       	ld	r30, X+
     b44:	fc 91       	ld	r31, X
     b46:	17 97       	sbiw	r26, 0x07	; 7
     b48:	30 97       	sbiw	r30, 0x00	; 0
     b4a:	11 f0       	breq	.+4      	; 0xb50 <__vector_20+0x58>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
     b4c:	6c 2f       	mov	r22, r28
     b4e:	09 95       	icall
		}
	}
}
     b50:	ff 91       	pop	r31
     b52:	ef 91       	pop	r30
     b54:	cf 91       	pop	r28
     b56:	bf 91       	pop	r27
     b58:	af 91       	pop	r26
     b5a:	9f 91       	pop	r25
     b5c:	8f 91       	pop	r24
     b5e:	7f 91       	pop	r23
     b60:	6f 91       	pop	r22
     b62:	5f 91       	pop	r21
     b64:	4f 91       	pop	r20
     b66:	3f 91       	pop	r19
     b68:	2f 91       	pop	r18
     b6a:	0f 90       	pop	r0
     b6c:	0f be       	out	0x3f, r0	; 63
     b6e:	0f 90       	pop	r0
     b70:	1f 90       	pop	r1
     b72:	18 95       	reti

00000b74 <__vector_21>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
     b74:	1f 92       	push	r1
     b76:	0f 92       	push	r0
     b78:	0f b6       	in	r0, 0x3f	; 63
     b7a:	0f 92       	push	r0
     b7c:	11 24       	eor	r1, r1
     b7e:	2f 93       	push	r18
     b80:	3f 93       	push	r19
     b82:	4f 93       	push	r20
     b84:	5f 93       	push	r21
     b86:	6f 93       	push	r22
     b88:	7f 93       	push	r23
     b8a:	8f 93       	push	r24
     b8c:	9f 93       	push	r25
     b8e:	af 93       	push	r26
     b90:	bf 93       	push	r27
     b92:	ef 93       	push	r30
     b94:	ff 93       	push	r31
     b96:	cf 93       	push	r28
     b98:	df 93       	push	r29
     b9a:	1f 92       	push	r1
     b9c:	cd b7       	in	r28, 0x3d	; 61
     b9e:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     ba0:	e0 91 f7 05 	lds	r30, 0x05F7	; 0x8005f7 <_ser_handle>
     ba4:	f0 91 f8 05 	lds	r31, 0x05F8	; 0x8005f8 <_ser_handle+0x1>
     ba8:	30 97       	sbiw	r30, 0x00	; 0
     baa:	99 f0       	breq	.+38     	; 0xbd2 <__vector_21+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
     bac:	be 01       	movw	r22, r28
     bae:	6f 5f       	subi	r22, 0xFF	; 255
     bb0:	7f 4f       	sbci	r23, 0xFF	; 255
     bb2:	82 81       	ldd	r24, Z+2	; 0x02
     bb4:	93 81       	ldd	r25, Z+3	; 0x03
     bb6:	0e 94 63 02 	call	0x4c6	; 0x4c6 <buffer_get_item>
     bba:	81 11       	cpse	r24, r1
     bbc:	04 c0       	rjmp	.+8      	; 0xbc6 <__vector_21+0x52>
			UDR0 = item;
     bbe:	89 81       	ldd	r24, Y+1	; 0x01
     bc0:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     bc4:	0b c0       	rjmp	.+22     	; 0xbdc <__vector_21+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
     bc6:	e1 ec       	ldi	r30, 0xC1	; 193
     bc8:	f0 e0       	ldi	r31, 0x00	; 0
     bca:	80 81       	ld	r24, Z
     bcc:	8f 7d       	andi	r24, 0xDF	; 223
     bce:	80 83       	st	Z, r24
     bd0:	05 c0       	rjmp	.+10     	; 0xbdc <__vector_21+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
     bd2:	e1 ec       	ldi	r30, 0xC1	; 193
     bd4:	f0 e0       	ldi	r31, 0x00	; 0
     bd6:	80 81       	ld	r24, Z
     bd8:	8f 7d       	andi	r24, 0xDF	; 223
     bda:	80 83       	st	Z, r24
	}
}
     bdc:	0f 90       	pop	r0
     bde:	df 91       	pop	r29
     be0:	cf 91       	pop	r28
     be2:	ff 91       	pop	r31
     be4:	ef 91       	pop	r30
     be6:	bf 91       	pop	r27
     be8:	af 91       	pop	r26
     bea:	9f 91       	pop	r25
     bec:	8f 91       	pop	r24
     bee:	7f 91       	pop	r23
     bf0:	6f 91       	pop	r22
     bf2:	5f 91       	pop	r21
     bf4:	4f 91       	pop	r20
     bf6:	3f 91       	pop	r19
     bf8:	2f 91       	pop	r18
     bfa:	0f 90       	pop	r0
     bfc:	0f be       	out	0x3f, r0	; 63
     bfe:	0f 90       	pop	r0
     c00:	1f 90       	pop	r1
     c02:	18 95       	reti

00000c04 <__vector_28>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
     c04:	1f 92       	push	r1
     c06:	0f 92       	push	r0
     c08:	0f b6       	in	r0, 0x3f	; 63
     c0a:	0f 92       	push	r0
     c0c:	11 24       	eor	r1, r1
     c0e:	2f 93       	push	r18
     c10:	3f 93       	push	r19
     c12:	4f 93       	push	r20
     c14:	5f 93       	push	r21
     c16:	6f 93       	push	r22
     c18:	7f 93       	push	r23
     c1a:	8f 93       	push	r24
     c1c:	9f 93       	push	r25
     c1e:	af 93       	push	r26
     c20:	bf 93       	push	r27
     c22:	cf 93       	push	r28
     c24:	ef 93       	push	r30
     c26:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
     c28:	e0 91 f9 05 	lds	r30, 0x05F9	; 0x8005f9 <_ser_handle+0x2>
     c2c:	f0 91 fa 05 	lds	r31, 0x05FA	; 0x8005fa <_ser_handle+0x3>
     c30:	30 97       	sbiw	r30, 0x00	; 0
     c32:	a1 f0       	breq	.+40     	; 0xc5c <__vector_28+0x58>
		item = UDR1;
     c34:	c0 91 ce 00 	lds	r28, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
     c38:	6c 2f       	mov	r22, r28
     c3a:	84 81       	ldd	r24, Z+4	; 0x04
     c3c:	95 81       	ldd	r25, Z+5	; 0x05
     c3e:	0e 94 84 02 	call	0x508	; 0x508 <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
     c42:	80 91 f9 05 	lds	r24, 0x05F9	; 0x8005f9 <_ser_handle+0x2>
     c46:	90 91 fa 05 	lds	r25, 0x05FA	; 0x8005fa <_ser_handle+0x3>
     c4a:	dc 01       	movw	r26, r24
     c4c:	16 96       	adiw	r26, 0x06	; 6
     c4e:	ed 91       	ld	r30, X+
     c50:	fc 91       	ld	r31, X
     c52:	17 97       	sbiw	r26, 0x07	; 7
     c54:	30 97       	sbiw	r30, 0x00	; 0
     c56:	11 f0       	breq	.+4      	; 0xc5c <__vector_28+0x58>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
     c58:	6c 2f       	mov	r22, r28
     c5a:	09 95       	icall
		}
	}
}
     c5c:	ff 91       	pop	r31
     c5e:	ef 91       	pop	r30
     c60:	cf 91       	pop	r28
     c62:	bf 91       	pop	r27
     c64:	af 91       	pop	r26
     c66:	9f 91       	pop	r25
     c68:	8f 91       	pop	r24
     c6a:	7f 91       	pop	r23
     c6c:	6f 91       	pop	r22
     c6e:	5f 91       	pop	r21
     c70:	4f 91       	pop	r20
     c72:	3f 91       	pop	r19
     c74:	2f 91       	pop	r18
     c76:	0f 90       	pop	r0
     c78:	0f be       	out	0x3f, r0	; 63
     c7a:	0f 90       	pop	r0
     c7c:	1f 90       	pop	r1
     c7e:	18 95       	reti

00000c80 <__vector_29>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
     c80:	1f 92       	push	r1
     c82:	0f 92       	push	r0
     c84:	0f b6       	in	r0, 0x3f	; 63
     c86:	0f 92       	push	r0
     c88:	11 24       	eor	r1, r1
     c8a:	2f 93       	push	r18
     c8c:	3f 93       	push	r19
     c8e:	4f 93       	push	r20
     c90:	5f 93       	push	r21
     c92:	6f 93       	push	r22
     c94:	7f 93       	push	r23
     c96:	8f 93       	push	r24
     c98:	9f 93       	push	r25
     c9a:	af 93       	push	r26
     c9c:	bf 93       	push	r27
     c9e:	ef 93       	push	r30
     ca0:	ff 93       	push	r31
     ca2:	cf 93       	push	r28
     ca4:	df 93       	push	r29
     ca6:	1f 92       	push	r1
     ca8:	cd b7       	in	r28, 0x3d	; 61
     caa:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
     cac:	e0 91 f9 05 	lds	r30, 0x05F9	; 0x8005f9 <_ser_handle+0x2>
     cb0:	f0 91 fa 05 	lds	r31, 0x05FA	; 0x8005fa <_ser_handle+0x3>
     cb4:	30 97       	sbiw	r30, 0x00	; 0
     cb6:	99 f0       	breq	.+38     	; 0xcde <__vector_29+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
     cb8:	be 01       	movw	r22, r28
     cba:	6f 5f       	subi	r22, 0xFF	; 255
     cbc:	7f 4f       	sbci	r23, 0xFF	; 255
     cbe:	82 81       	ldd	r24, Z+2	; 0x02
     cc0:	93 81       	ldd	r25, Z+3	; 0x03
     cc2:	0e 94 63 02 	call	0x4c6	; 0x4c6 <buffer_get_item>
     cc6:	81 11       	cpse	r24, r1
     cc8:	04 c0       	rjmp	.+8      	; 0xcd2 <__vector_29+0x52>
			UDR1 = item;
     cca:	89 81       	ldd	r24, Y+1	; 0x01
     ccc:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
     cd0:	0b c0       	rjmp	.+22     	; 0xce8 <__vector_29+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
     cd2:	e9 ec       	ldi	r30, 0xC9	; 201
     cd4:	f0 e0       	ldi	r31, 0x00	; 0
     cd6:	80 81       	ld	r24, Z
     cd8:	8f 7d       	andi	r24, 0xDF	; 223
     cda:	80 83       	st	Z, r24
     cdc:	05 c0       	rjmp	.+10     	; 0xce8 <__vector_29+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
     cde:	e9 ec       	ldi	r30, 0xC9	; 201
     ce0:	f0 e0       	ldi	r31, 0x00	; 0
     ce2:	80 81       	ld	r24, Z
     ce4:	8f 7d       	andi	r24, 0xDF	; 223
     ce6:	80 83       	st	Z, r24
	}
}
     ce8:	0f 90       	pop	r0
     cea:	df 91       	pop	r29
     cec:	cf 91       	pop	r28
     cee:	ff 91       	pop	r31
     cf0:	ef 91       	pop	r30
     cf2:	bf 91       	pop	r27
     cf4:	af 91       	pop	r26
     cf6:	9f 91       	pop	r25
     cf8:	8f 91       	pop	r24
     cfa:	7f 91       	pop	r23
     cfc:	6f 91       	pop	r22
     cfe:	5f 91       	pop	r21
     d00:	4f 91       	pop	r20
     d02:	3f 91       	pop	r19
     d04:	2f 91       	pop	r18
     d06:	0f 90       	pop	r0
     d08:	0f be       	out	0x3f, r0	; 63
     d0a:	0f 90       	pop	r0
     d0c:	1f 90       	pop	r1
     d0e:	18 95       	reti

00000d10 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     d10:	0f 93       	push	r16
     d12:	1f 93       	push	r17
     d14:	cf 93       	push	r28
     d16:	df 93       	push	r29
     d18:	ec 01       	movw	r28, r24
     d1a:	04 2f       	mov	r16, r20
     d1c:	1a 8d       	ldd	r17, Y+26	; 0x1a
     d1e:	4c 8d       	ldd	r20, Y+28	; 0x1c
     d20:	41 11       	cpse	r20, r1
     d22:	0c c0       	rjmp	.+24     	; 0xd3c <prvCopyDataToQueue+0x2c>
     d24:	88 81       	ld	r24, Y
     d26:	99 81       	ldd	r25, Y+1	; 0x01
     d28:	89 2b       	or	r24, r25
     d2a:	09 f0       	breq	.+2      	; 0xd2e <prvCopyDataToQueue+0x1e>
     d2c:	42 c0       	rjmp	.+132    	; 0xdb2 <prvCopyDataToQueue+0xa2>
     d2e:	8a 81       	ldd	r24, Y+2	; 0x02
     d30:	9b 81       	ldd	r25, Y+3	; 0x03
     d32:	0e 94 32 0e 	call	0x1c64	; 0x1c64 <xTaskPriorityDisinherit>
     d36:	1b 82       	std	Y+3, r1	; 0x03
     d38:	1a 82       	std	Y+2, r1	; 0x02
     d3a:	42 c0       	rjmp	.+132    	; 0xdc0 <prvCopyDataToQueue+0xb0>
     d3c:	01 11       	cpse	r16, r1
     d3e:	17 c0       	rjmp	.+46     	; 0xd6e <prvCopyDataToQueue+0x5e>
     d40:	50 e0       	ldi	r21, 0x00	; 0
     d42:	8c 81       	ldd	r24, Y+4	; 0x04
     d44:	9d 81       	ldd	r25, Y+5	; 0x05
     d46:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <memcpy>
     d4a:	2c 8d       	ldd	r18, Y+28	; 0x1c
     d4c:	8c 81       	ldd	r24, Y+4	; 0x04
     d4e:	9d 81       	ldd	r25, Y+5	; 0x05
     d50:	82 0f       	add	r24, r18
     d52:	91 1d       	adc	r25, r1
     d54:	9d 83       	std	Y+5, r25	; 0x05
     d56:	8c 83       	std	Y+4, r24	; 0x04
     d58:	2a 81       	ldd	r18, Y+2	; 0x02
     d5a:	3b 81       	ldd	r19, Y+3	; 0x03
     d5c:	82 17       	cp	r24, r18
     d5e:	93 07       	cpc	r25, r19
     d60:	50 f1       	brcs	.+84     	; 0xdb6 <prvCopyDataToQueue+0xa6>
     d62:	88 81       	ld	r24, Y
     d64:	99 81       	ldd	r25, Y+1	; 0x01
     d66:	9d 83       	std	Y+5, r25	; 0x05
     d68:	8c 83       	std	Y+4, r24	; 0x04
     d6a:	80 e0       	ldi	r24, 0x00	; 0
     d6c:	29 c0       	rjmp	.+82     	; 0xdc0 <prvCopyDataToQueue+0xb0>
     d6e:	50 e0       	ldi	r21, 0x00	; 0
     d70:	8e 81       	ldd	r24, Y+6	; 0x06
     d72:	9f 81       	ldd	r25, Y+7	; 0x07
     d74:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <memcpy>
     d78:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d7a:	90 e0       	ldi	r25, 0x00	; 0
     d7c:	91 95       	neg	r25
     d7e:	81 95       	neg	r24
     d80:	91 09       	sbc	r25, r1
     d82:	2e 81       	ldd	r18, Y+6	; 0x06
     d84:	3f 81       	ldd	r19, Y+7	; 0x07
     d86:	28 0f       	add	r18, r24
     d88:	39 1f       	adc	r19, r25
     d8a:	3f 83       	std	Y+7, r19	; 0x07
     d8c:	2e 83       	std	Y+6, r18	; 0x06
     d8e:	48 81       	ld	r20, Y
     d90:	59 81       	ldd	r21, Y+1	; 0x01
     d92:	24 17       	cp	r18, r20
     d94:	35 07       	cpc	r19, r21
     d96:	30 f4       	brcc	.+12     	; 0xda4 <prvCopyDataToQueue+0x94>
     d98:	2a 81       	ldd	r18, Y+2	; 0x02
     d9a:	3b 81       	ldd	r19, Y+3	; 0x03
     d9c:	82 0f       	add	r24, r18
     d9e:	93 1f       	adc	r25, r19
     da0:	9f 83       	std	Y+7, r25	; 0x07
     da2:	8e 83       	std	Y+6, r24	; 0x06
     da4:	02 30       	cpi	r16, 0x02	; 2
     da6:	49 f4       	brne	.+18     	; 0xdba <prvCopyDataToQueue+0xaa>
     da8:	11 23       	and	r17, r17
     daa:	49 f0       	breq	.+18     	; 0xdbe <prvCopyDataToQueue+0xae>
     dac:	11 50       	subi	r17, 0x01	; 1
     dae:	80 e0       	ldi	r24, 0x00	; 0
     db0:	07 c0       	rjmp	.+14     	; 0xdc0 <prvCopyDataToQueue+0xb0>
     db2:	80 e0       	ldi	r24, 0x00	; 0
     db4:	05 c0       	rjmp	.+10     	; 0xdc0 <prvCopyDataToQueue+0xb0>
     db6:	80 e0       	ldi	r24, 0x00	; 0
     db8:	03 c0       	rjmp	.+6      	; 0xdc0 <prvCopyDataToQueue+0xb0>
     dba:	80 e0       	ldi	r24, 0x00	; 0
     dbc:	01 c0       	rjmp	.+2      	; 0xdc0 <prvCopyDataToQueue+0xb0>
     dbe:	80 e0       	ldi	r24, 0x00	; 0
     dc0:	1f 5f       	subi	r17, 0xFF	; 255
     dc2:	1a 8f       	std	Y+26, r17	; 0x1a
     dc4:	df 91       	pop	r29
     dc6:	cf 91       	pop	r28
     dc8:	1f 91       	pop	r17
     dca:	0f 91       	pop	r16
     dcc:	08 95       	ret

00000dce <prvCopyDataFromQueue>:
     dce:	fc 01       	movw	r30, r24
     dd0:	44 8d       	ldd	r20, Z+28	; 0x1c
     dd2:	44 23       	and	r20, r20
     dd4:	a9 f0       	breq	.+42     	; 0xe00 <prvCopyDataFromQueue+0x32>
     dd6:	50 e0       	ldi	r21, 0x00	; 0
     dd8:	26 81       	ldd	r18, Z+6	; 0x06
     dda:	37 81       	ldd	r19, Z+7	; 0x07
     ddc:	24 0f       	add	r18, r20
     dde:	35 1f       	adc	r19, r21
     de0:	37 83       	std	Z+7, r19	; 0x07
     de2:	26 83       	std	Z+6, r18	; 0x06
     de4:	82 81       	ldd	r24, Z+2	; 0x02
     de6:	93 81       	ldd	r25, Z+3	; 0x03
     de8:	28 17       	cp	r18, r24
     dea:	39 07       	cpc	r19, r25
     dec:	20 f0       	brcs	.+8      	; 0xdf6 <prvCopyDataFromQueue+0x28>
     dee:	80 81       	ld	r24, Z
     df0:	91 81       	ldd	r25, Z+1	; 0x01
     df2:	97 83       	std	Z+7, r25	; 0x07
     df4:	86 83       	std	Z+6, r24	; 0x06
     df6:	cb 01       	movw	r24, r22
     df8:	66 81       	ldd	r22, Z+6	; 0x06
     dfa:	77 81       	ldd	r23, Z+7	; 0x07
     dfc:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <memcpy>
     e00:	08 95       	ret

00000e02 <prvUnlockQueue>:
     e02:	ef 92       	push	r14
     e04:	ff 92       	push	r15
     e06:	0f 93       	push	r16
     e08:	1f 93       	push	r17
     e0a:	cf 93       	push	r28
     e0c:	8c 01       	movw	r16, r24
     e0e:	0f b6       	in	r0, 0x3f	; 63
     e10:	f8 94       	cli
     e12:	0f 92       	push	r0
     e14:	fc 01       	movw	r30, r24
     e16:	c6 8d       	ldd	r28, Z+30	; 0x1e
     e18:	1c 16       	cp	r1, r28
     e1a:	ac f4       	brge	.+42     	; 0xe46 <prvUnlockQueue+0x44>
     e1c:	81 89       	ldd	r24, Z+17	; 0x11
     e1e:	81 11       	cpse	r24, r1
     e20:	06 c0       	rjmp	.+12     	; 0xe2e <prvUnlockQueue+0x2c>
     e22:	11 c0       	rjmp	.+34     	; 0xe46 <prvUnlockQueue+0x44>
     e24:	f8 01       	movw	r30, r16
     e26:	81 89       	ldd	r24, Z+17	; 0x11
     e28:	81 11       	cpse	r24, r1
     e2a:	05 c0       	rjmp	.+10     	; 0xe36 <prvUnlockQueue+0x34>
     e2c:	0c c0       	rjmp	.+24     	; 0xe46 <prvUnlockQueue+0x44>
     e2e:	78 01       	movw	r14, r16
     e30:	f1 e1       	ldi	r31, 0x11	; 17
     e32:	ef 0e       	add	r14, r31
     e34:	f1 1c       	adc	r15, r1
     e36:	c7 01       	movw	r24, r14
     e38:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <xTaskRemoveFromEventList>
     e3c:	81 11       	cpse	r24, r1
     e3e:	0e 94 cc 0d 	call	0x1b98	; 0x1b98 <vTaskMissedYield>
     e42:	c1 50       	subi	r28, 0x01	; 1
     e44:	79 f7       	brne	.-34     	; 0xe24 <prvUnlockQueue+0x22>
     e46:	8f ef       	ldi	r24, 0xFF	; 255
     e48:	f8 01       	movw	r30, r16
     e4a:	86 8f       	std	Z+30, r24	; 0x1e
     e4c:	0f 90       	pop	r0
     e4e:	0f be       	out	0x3f, r0	; 63
     e50:	0f b6       	in	r0, 0x3f	; 63
     e52:	f8 94       	cli
     e54:	0f 92       	push	r0
     e56:	c5 8d       	ldd	r28, Z+29	; 0x1d
     e58:	1c 16       	cp	r1, r28
     e5a:	ac f4       	brge	.+42     	; 0xe86 <prvUnlockQueue+0x84>
     e5c:	80 85       	ldd	r24, Z+8	; 0x08
     e5e:	81 11       	cpse	r24, r1
     e60:	06 c0       	rjmp	.+12     	; 0xe6e <prvUnlockQueue+0x6c>
     e62:	11 c0       	rjmp	.+34     	; 0xe86 <prvUnlockQueue+0x84>
     e64:	f8 01       	movw	r30, r16
     e66:	80 85       	ldd	r24, Z+8	; 0x08
     e68:	81 11       	cpse	r24, r1
     e6a:	05 c0       	rjmp	.+10     	; 0xe76 <prvUnlockQueue+0x74>
     e6c:	0c c0       	rjmp	.+24     	; 0xe86 <prvUnlockQueue+0x84>
     e6e:	78 01       	movw	r14, r16
     e70:	f8 e0       	ldi	r31, 0x08	; 8
     e72:	ef 0e       	add	r14, r31
     e74:	f1 1c       	adc	r15, r1
     e76:	c7 01       	movw	r24, r14
     e78:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <xTaskRemoveFromEventList>
     e7c:	81 11       	cpse	r24, r1
     e7e:	0e 94 cc 0d 	call	0x1b98	; 0x1b98 <vTaskMissedYield>
     e82:	c1 50       	subi	r28, 0x01	; 1
     e84:	79 f7       	brne	.-34     	; 0xe64 <prvUnlockQueue+0x62>
     e86:	8f ef       	ldi	r24, 0xFF	; 255
     e88:	f8 01       	movw	r30, r16
     e8a:	85 8f       	std	Z+29, r24	; 0x1d
     e8c:	0f 90       	pop	r0
     e8e:	0f be       	out	0x3f, r0	; 63
     e90:	cf 91       	pop	r28
     e92:	1f 91       	pop	r17
     e94:	0f 91       	pop	r16
     e96:	ff 90       	pop	r15
     e98:	ef 90       	pop	r14
     e9a:	08 95       	ret

00000e9c <xQueueGenericReset>:
     e9c:	cf 93       	push	r28
     e9e:	df 93       	push	r29
     ea0:	ec 01       	movw	r28, r24
     ea2:	0f b6       	in	r0, 0x3f	; 63
     ea4:	f8 94       	cli
     ea6:	0f 92       	push	r0
     ea8:	48 81       	ld	r20, Y
     eaa:	59 81       	ldd	r21, Y+1	; 0x01
     eac:	2c 8d       	ldd	r18, Y+28	; 0x1c
     eae:	30 e0       	ldi	r19, 0x00	; 0
     eb0:	7b 8d       	ldd	r23, Y+27	; 0x1b
     eb2:	72 9f       	mul	r23, r18
     eb4:	c0 01       	movw	r24, r0
     eb6:	73 9f       	mul	r23, r19
     eb8:	90 0d       	add	r25, r0
     eba:	11 24       	eor	r1, r1
     ebc:	fa 01       	movw	r30, r20
     ebe:	e8 0f       	add	r30, r24
     ec0:	f9 1f       	adc	r31, r25
     ec2:	fb 83       	std	Y+3, r31	; 0x03
     ec4:	ea 83       	std	Y+2, r30	; 0x02
     ec6:	1a 8e       	std	Y+26, r1	; 0x1a
     ec8:	5d 83       	std	Y+5, r21	; 0x05
     eca:	4c 83       	std	Y+4, r20	; 0x04
     ecc:	82 1b       	sub	r24, r18
     ece:	93 0b       	sbc	r25, r19
     ed0:	84 0f       	add	r24, r20
     ed2:	95 1f       	adc	r25, r21
     ed4:	9f 83       	std	Y+7, r25	; 0x07
     ed6:	8e 83       	std	Y+6, r24	; 0x06
     ed8:	8f ef       	ldi	r24, 0xFF	; 255
     eda:	8d 8f       	std	Y+29, r24	; 0x1d
     edc:	8e 8f       	std	Y+30, r24	; 0x1e
     ede:	61 11       	cpse	r22, r1
     ee0:	0c c0       	rjmp	.+24     	; 0xefa <xQueueGenericReset+0x5e>
     ee2:	88 85       	ldd	r24, Y+8	; 0x08
     ee4:	88 23       	and	r24, r24
     ee6:	89 f0       	breq	.+34     	; 0xf0a <xQueueGenericReset+0x6e>
     ee8:	ce 01       	movw	r24, r28
     eea:	08 96       	adiw	r24, 0x08	; 8
     eec:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <xTaskRemoveFromEventList>
     ef0:	88 23       	and	r24, r24
     ef2:	59 f0       	breq	.+22     	; 0xf0a <xQueueGenericReset+0x6e>
     ef4:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vPortYield>
     ef8:	08 c0       	rjmp	.+16     	; 0xf0a <xQueueGenericReset+0x6e>
     efa:	ce 01       	movw	r24, r28
     efc:	08 96       	adiw	r24, 0x08	; 8
     efe:	0e 94 a1 02 	call	0x542	; 0x542 <vListInitialise>
     f02:	ce 01       	movw	r24, r28
     f04:	41 96       	adiw	r24, 0x11	; 17
     f06:	0e 94 a1 02 	call	0x542	; 0x542 <vListInitialise>
     f0a:	0f 90       	pop	r0
     f0c:	0f be       	out	0x3f, r0	; 63
     f0e:	81 e0       	ldi	r24, 0x01	; 1
     f10:	df 91       	pop	r29
     f12:	cf 91       	pop	r28
     f14:	08 95       	ret

00000f16 <xQueueGenericCreate>:
     f16:	ff 92       	push	r15
     f18:	0f 93       	push	r16
     f1a:	1f 93       	push	r17
     f1c:	cf 93       	push	r28
     f1e:	df 93       	push	r29
     f20:	08 2f       	mov	r16, r24
     f22:	16 2f       	mov	r17, r22
     f24:	f4 2e       	mov	r15, r20
     f26:	66 23       	and	r22, r22
     f28:	c9 f0       	breq	.+50     	; 0xf5c <xQueueGenericCreate+0x46>
     f2a:	86 9f       	mul	r24, r22
     f2c:	c0 01       	movw	r24, r0
     f2e:	11 24       	eor	r1, r1
     f30:	81 96       	adiw	r24, 0x21	; 33
     f32:	0e 94 89 04 	call	0x912	; 0x912 <pvPortMalloc>
     f36:	ec 01       	movw	r28, r24
     f38:	00 97       	sbiw	r24, 0x00	; 0
     f3a:	49 f4       	brne	.+18     	; 0xf4e <xQueueGenericCreate+0x38>
     f3c:	16 c0       	rjmp	.+44     	; 0xf6a <xQueueGenericCreate+0x54>
     f3e:	0b 8f       	std	Y+27, r16	; 0x1b
     f40:	1c 8f       	std	Y+28, r17	; 0x1c
     f42:	61 e0       	ldi	r22, 0x01	; 1
     f44:	ce 01       	movw	r24, r28
     f46:	0e 94 4e 07 	call	0xe9c	; 0xe9c <xQueueGenericReset>
     f4a:	f8 a2       	std	Y+32, r15	; 0x20
     f4c:	0e c0       	rjmp	.+28     	; 0xf6a <xQueueGenericCreate+0x54>
     f4e:	81 96       	adiw	r24, 0x21	; 33
     f50:	99 83       	std	Y+1, r25	; 0x01
     f52:	88 83       	st	Y, r24
     f54:	f4 cf       	rjmp	.-24     	; 0xf3e <xQueueGenericCreate+0x28>
     f56:	d9 83       	std	Y+1, r29	; 0x01
     f58:	c8 83       	st	Y, r28
     f5a:	f1 cf       	rjmp	.-30     	; 0xf3e <xQueueGenericCreate+0x28>
     f5c:	81 e2       	ldi	r24, 0x21	; 33
     f5e:	90 e0       	ldi	r25, 0x00	; 0
     f60:	0e 94 89 04 	call	0x912	; 0x912 <pvPortMalloc>
     f64:	ec 01       	movw	r28, r24
     f66:	89 2b       	or	r24, r25
     f68:	b1 f7       	brne	.-20     	; 0xf56 <xQueueGenericCreate+0x40>
     f6a:	ce 01       	movw	r24, r28
     f6c:	df 91       	pop	r29
     f6e:	cf 91       	pop	r28
     f70:	1f 91       	pop	r17
     f72:	0f 91       	pop	r16
     f74:	ff 90       	pop	r15
     f76:	08 95       	ret

00000f78 <xQueueGenericSend>:
     f78:	9f 92       	push	r9
     f7a:	af 92       	push	r10
     f7c:	bf 92       	push	r11
     f7e:	cf 92       	push	r12
     f80:	df 92       	push	r13
     f82:	ef 92       	push	r14
     f84:	ff 92       	push	r15
     f86:	0f 93       	push	r16
     f88:	1f 93       	push	r17
     f8a:	cf 93       	push	r28
     f8c:	df 93       	push	r29
     f8e:	00 d0       	rcall	.+0      	; 0xf90 <xQueueGenericSend+0x18>
     f90:	00 d0       	rcall	.+0      	; 0xf92 <xQueueGenericSend+0x1a>
     f92:	1f 92       	push	r1
     f94:	cd b7       	in	r28, 0x3d	; 61
     f96:	de b7       	in	r29, 0x3e	; 62
     f98:	8c 01       	movw	r16, r24
     f9a:	6b 01       	movw	r12, r22
     f9c:	5d 83       	std	Y+5, r21	; 0x05
     f9e:	4c 83       	std	Y+4, r20	; 0x04
     fa0:	a2 2e       	mov	r10, r18
     fa2:	b1 2c       	mov	r11, r1
     fa4:	99 24       	eor	r9, r9
     fa6:	93 94       	inc	r9
     fa8:	7c 01       	movw	r14, r24
     faa:	88 e0       	ldi	r24, 0x08	; 8
     fac:	e8 0e       	add	r14, r24
     fae:	f1 1c       	adc	r15, r1
     fb0:	0f b6       	in	r0, 0x3f	; 63
     fb2:	f8 94       	cli
     fb4:	0f 92       	push	r0
     fb6:	f8 01       	movw	r30, r16
     fb8:	92 8d       	ldd	r25, Z+26	; 0x1a
     fba:	83 8d       	ldd	r24, Z+27	; 0x1b
     fbc:	98 17       	cp	r25, r24
     fbe:	18 f0       	brcs	.+6      	; 0xfc6 <xQueueGenericSend+0x4e>
     fc0:	f2 e0       	ldi	r31, 0x02	; 2
     fc2:	af 12       	cpse	r10, r31
     fc4:	19 c0       	rjmp	.+50     	; 0xff8 <xQueueGenericSend+0x80>
     fc6:	4a 2d       	mov	r20, r10
     fc8:	b6 01       	movw	r22, r12
     fca:	c8 01       	movw	r24, r16
     fcc:	0e 94 88 06 	call	0xd10	; 0xd10 <prvCopyDataToQueue>
     fd0:	f8 01       	movw	r30, r16
     fd2:	91 89       	ldd	r25, Z+17	; 0x11
     fd4:	99 23       	and	r25, r25
     fd6:	49 f0       	breq	.+18     	; 0xfea <xQueueGenericSend+0x72>
     fd8:	c8 01       	movw	r24, r16
     fda:	41 96       	adiw	r24, 0x11	; 17
     fdc:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <xTaskRemoveFromEventList>
     fe0:	88 23       	and	r24, r24
     fe2:	31 f0       	breq	.+12     	; 0xff0 <xQueueGenericSend+0x78>
     fe4:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vPortYield>
     fe8:	03 c0       	rjmp	.+6      	; 0xff0 <xQueueGenericSend+0x78>
     fea:	81 11       	cpse	r24, r1
     fec:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vPortYield>
     ff0:	0f 90       	pop	r0
     ff2:	0f be       	out	0x3f, r0	; 63
     ff4:	81 e0       	ldi	r24, 0x01	; 1
     ff6:	50 c0       	rjmp	.+160    	; 0x1098 <xQueueGenericSend+0x120>
     ff8:	8c 81       	ldd	r24, Y+4	; 0x04
     ffa:	9d 81       	ldd	r25, Y+5	; 0x05
     ffc:	89 2b       	or	r24, r25
     ffe:	21 f4       	brne	.+8      	; 0x1008 <xQueueGenericSend+0x90>
    1000:	0f 90       	pop	r0
    1002:	0f be       	out	0x3f, r0	; 63
    1004:	80 e0       	ldi	r24, 0x00	; 0
    1006:	48 c0       	rjmp	.+144    	; 0x1098 <xQueueGenericSend+0x120>
    1008:	b1 10       	cpse	r11, r1
    100a:	05 c0       	rjmp	.+10     	; 0x1016 <xQueueGenericSend+0x9e>
    100c:	ce 01       	movw	r24, r28
    100e:	01 96       	adiw	r24, 0x01	; 1
    1010:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <vTaskSetTimeOutState>
    1014:	b9 2c       	mov	r11, r9
    1016:	0f 90       	pop	r0
    1018:	0f be       	out	0x3f, r0	; 63
    101a:	0e 94 1f 0b 	call	0x163e	; 0x163e <vTaskSuspendAll>
    101e:	0f b6       	in	r0, 0x3f	; 63
    1020:	f8 94       	cli
    1022:	0f 92       	push	r0
    1024:	f8 01       	movw	r30, r16
    1026:	85 8d       	ldd	r24, Z+29	; 0x1d
    1028:	8f 3f       	cpi	r24, 0xFF	; 255
    102a:	09 f4       	brne	.+2      	; 0x102e <xQueueGenericSend+0xb6>
    102c:	15 8e       	std	Z+29, r1	; 0x1d
    102e:	f8 01       	movw	r30, r16
    1030:	86 8d       	ldd	r24, Z+30	; 0x1e
    1032:	8f 3f       	cpi	r24, 0xFF	; 255
    1034:	09 f4       	brne	.+2      	; 0x1038 <xQueueGenericSend+0xc0>
    1036:	16 8e       	std	Z+30, r1	; 0x1e
    1038:	0f 90       	pop	r0
    103a:	0f be       	out	0x3f, r0	; 63
    103c:	be 01       	movw	r22, r28
    103e:	6c 5f       	subi	r22, 0xFC	; 252
    1040:	7f 4f       	sbci	r23, 0xFF	; 255
    1042:	ce 01       	movw	r24, r28
    1044:	01 96       	adiw	r24, 0x01	; 1
    1046:	0e 94 9a 0d 	call	0x1b34	; 0x1b34 <xTaskCheckForTimeOut>
    104a:	81 11       	cpse	r24, r1
    104c:	1f c0       	rjmp	.+62     	; 0x108c <xQueueGenericSend+0x114>
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	f8 94       	cli
    1052:	0f 92       	push	r0
    1054:	f8 01       	movw	r30, r16
    1056:	92 8d       	ldd	r25, Z+26	; 0x1a
    1058:	0f 90       	pop	r0
    105a:	0f be       	out	0x3f, r0	; 63
    105c:	83 8d       	ldd	r24, Z+27	; 0x1b
    105e:	98 13       	cpse	r25, r24
    1060:	0f c0       	rjmp	.+30     	; 0x1080 <xQueueGenericSend+0x108>
    1062:	6c 81       	ldd	r22, Y+4	; 0x04
    1064:	7d 81       	ldd	r23, Y+5	; 0x05
    1066:	c7 01       	movw	r24, r14
    1068:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <vTaskPlaceOnEventList>
    106c:	c8 01       	movw	r24, r16
    106e:	0e 94 01 07 	call	0xe02	; 0xe02 <prvUnlockQueue>
    1072:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <xTaskResumeAll>
    1076:	81 11       	cpse	r24, r1
    1078:	9b cf       	rjmp	.-202    	; 0xfb0 <xQueueGenericSend+0x38>
    107a:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vPortYield>
    107e:	98 cf       	rjmp	.-208    	; 0xfb0 <xQueueGenericSend+0x38>
    1080:	c8 01       	movw	r24, r16
    1082:	0e 94 01 07 	call	0xe02	; 0xe02 <prvUnlockQueue>
    1086:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <xTaskResumeAll>
    108a:	92 cf       	rjmp	.-220    	; 0xfb0 <xQueueGenericSend+0x38>
    108c:	c8 01       	movw	r24, r16
    108e:	0e 94 01 07 	call	0xe02	; 0xe02 <prvUnlockQueue>
    1092:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <xTaskResumeAll>
    1096:	80 e0       	ldi	r24, 0x00	; 0
    1098:	0f 90       	pop	r0
    109a:	0f 90       	pop	r0
    109c:	0f 90       	pop	r0
    109e:	0f 90       	pop	r0
    10a0:	0f 90       	pop	r0
    10a2:	df 91       	pop	r29
    10a4:	cf 91       	pop	r28
    10a6:	1f 91       	pop	r17
    10a8:	0f 91       	pop	r16
    10aa:	ff 90       	pop	r15
    10ac:	ef 90       	pop	r14
    10ae:	df 90       	pop	r13
    10b0:	cf 90       	pop	r12
    10b2:	bf 90       	pop	r11
    10b4:	af 90       	pop	r10
    10b6:	9f 90       	pop	r9
    10b8:	08 95       	ret

000010ba <xQueueCreateMutex>:
    10ba:	cf 93       	push	r28
    10bc:	df 93       	push	r29
    10be:	48 2f       	mov	r20, r24
    10c0:	60 e0       	ldi	r22, 0x00	; 0
    10c2:	81 e0       	ldi	r24, 0x01	; 1
    10c4:	0e 94 8b 07 	call	0xf16	; 0xf16 <xQueueGenericCreate>
    10c8:	ec 01       	movw	r28, r24
    10ca:	00 97       	sbiw	r24, 0x00	; 0
    10cc:	61 f0       	breq	.+24     	; 0x10e6 <xQueueCreateMutex+0x2c>
    10ce:	1b 82       	std	Y+3, r1	; 0x03
    10d0:	1a 82       	std	Y+2, r1	; 0x02
    10d2:	19 82       	std	Y+1, r1	; 0x01
    10d4:	18 82       	st	Y, r1
    10d6:	1e 82       	std	Y+6, r1	; 0x06
    10d8:	20 e0       	ldi	r18, 0x00	; 0
    10da:	40 e0       	ldi	r20, 0x00	; 0
    10dc:	50 e0       	ldi	r21, 0x00	; 0
    10de:	60 e0       	ldi	r22, 0x00	; 0
    10e0:	70 e0       	ldi	r23, 0x00	; 0
    10e2:	0e 94 bc 07 	call	0xf78	; 0xf78 <xQueueGenericSend>
    10e6:	ce 01       	movw	r24, r28
    10e8:	df 91       	pop	r29
    10ea:	cf 91       	pop	r28
    10ec:	08 95       	ret

000010ee <xQueueGenericSendFromISR>:
    10ee:	ef 92       	push	r14
    10f0:	ff 92       	push	r15
    10f2:	0f 93       	push	r16
    10f4:	1f 93       	push	r17
    10f6:	cf 93       	push	r28
    10f8:	df 93       	push	r29
    10fa:	8a 01       	movw	r16, r20
    10fc:	fc 01       	movw	r30, r24
    10fe:	52 8d       	ldd	r21, Z+26	; 0x1a
    1100:	33 8d       	ldd	r19, Z+27	; 0x1b
    1102:	53 17       	cp	r21, r19
    1104:	10 f0       	brcs	.+4      	; 0x110a <xQueueGenericSendFromISR+0x1c>
    1106:	22 30       	cpi	r18, 0x02	; 2
    1108:	f1 f4       	brne	.+60     	; 0x1146 <xQueueGenericSendFromISR+0x58>
    110a:	42 2f       	mov	r20, r18
    110c:	78 01       	movw	r14, r16
    110e:	ec 01       	movw	r28, r24
    1110:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1112:	0e 94 88 06 	call	0xd10	; 0xd10 <prvCopyDataToQueue>
    1116:	1f 3f       	cpi	r17, 0xFF	; 255
    1118:	81 f4       	brne	.+32     	; 0x113a <xQueueGenericSendFromISR+0x4c>
    111a:	89 89       	ldd	r24, Y+17	; 0x11
    111c:	88 23       	and	r24, r24
    111e:	a9 f0       	breq	.+42     	; 0x114a <xQueueGenericSendFromISR+0x5c>
    1120:	ce 01       	movw	r24, r28
    1122:	41 96       	adiw	r24, 0x11	; 17
    1124:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <xTaskRemoveFromEventList>
    1128:	88 23       	and	r24, r24
    112a:	89 f0       	breq	.+34     	; 0x114e <xQueueGenericSendFromISR+0x60>
    112c:	e1 14       	cp	r14, r1
    112e:	f1 04       	cpc	r15, r1
    1130:	81 f0       	breq	.+32     	; 0x1152 <xQueueGenericSendFromISR+0x64>
    1132:	81 e0       	ldi	r24, 0x01	; 1
    1134:	f7 01       	movw	r30, r14
    1136:	80 83       	st	Z, r24
    1138:	0d c0       	rjmp	.+26     	; 0x1154 <xQueueGenericSendFromISR+0x66>
    113a:	ff 24       	eor	r15, r15
    113c:	f3 94       	inc	r15
    113e:	f1 0e       	add	r15, r17
    1140:	fe 8e       	std	Y+30, r15	; 0x1e
    1142:	81 e0       	ldi	r24, 0x01	; 1
    1144:	07 c0       	rjmp	.+14     	; 0x1154 <xQueueGenericSendFromISR+0x66>
    1146:	80 e0       	ldi	r24, 0x00	; 0
    1148:	05 c0       	rjmp	.+10     	; 0x1154 <xQueueGenericSendFromISR+0x66>
    114a:	81 e0       	ldi	r24, 0x01	; 1
    114c:	03 c0       	rjmp	.+6      	; 0x1154 <xQueueGenericSendFromISR+0x66>
    114e:	81 e0       	ldi	r24, 0x01	; 1
    1150:	01 c0       	rjmp	.+2      	; 0x1154 <xQueueGenericSendFromISR+0x66>
    1152:	81 e0       	ldi	r24, 0x01	; 1
    1154:	df 91       	pop	r29
    1156:	cf 91       	pop	r28
    1158:	1f 91       	pop	r17
    115a:	0f 91       	pop	r16
    115c:	ff 90       	pop	r15
    115e:	ef 90       	pop	r14
    1160:	08 95       	ret

00001162 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1162:	8f 92       	push	r8
    1164:	9f 92       	push	r9
    1166:	af 92       	push	r10
    1168:	bf 92       	push	r11
    116a:	cf 92       	push	r12
    116c:	df 92       	push	r13
    116e:	ef 92       	push	r14
    1170:	ff 92       	push	r15
    1172:	0f 93       	push	r16
    1174:	1f 93       	push	r17
    1176:	cf 93       	push	r28
    1178:	df 93       	push	r29
    117a:	00 d0       	rcall	.+0      	; 0x117c <xQueueGenericReceive+0x1a>
    117c:	00 d0       	rcall	.+0      	; 0x117e <xQueueGenericReceive+0x1c>
    117e:	1f 92       	push	r1
    1180:	cd b7       	in	r28, 0x3d	; 61
    1182:	de b7       	in	r29, 0x3e	; 62
    1184:	8c 01       	movw	r16, r24
    1186:	5b 01       	movw	r10, r22
    1188:	5d 83       	std	Y+5, r21	; 0x05
    118a:	4c 83       	std	Y+4, r20	; 0x04
    118c:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    118e:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1190:	99 24       	eor	r9, r9
    1192:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1194:	6c 01       	movw	r12, r24
    1196:	81 e1       	ldi	r24, 0x11	; 17
    1198:	c8 0e       	add	r12, r24
    119a:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    119c:	0f b6       	in	r0, 0x3f	; 63
    119e:	f8 94       	cli
    11a0:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    11a2:	f8 01       	movw	r30, r16
    11a4:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    11a6:	ff 20       	and	r15, r15
    11a8:	91 f1       	breq	.+100    	; 0x120e <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    11aa:	c6 80       	ldd	r12, Z+6	; 0x06
    11ac:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    11ae:	b5 01       	movw	r22, r10
    11b0:	c8 01       	movw	r24, r16
    11b2:	0e 94 e7 06 	call	0xdce	; 0xdce <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    11b6:	81 10       	cpse	r8, r1
    11b8:	19 c0       	rjmp	.+50     	; 0x11ec <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    11ba:	fa 94       	dec	r15
    11bc:	f8 01       	movw	r30, r16
    11be:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    11c0:	80 81       	ld	r24, Z
    11c2:	91 81       	ldd	r25, Z+1	; 0x01
    11c4:	89 2b       	or	r24, r25
    11c6:	29 f4       	brne	.+10     	; 0x11d2 <xQueueGenericReceive+0x70>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    11c8:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <pvTaskIncrementMutexHeldCount>
    11cc:	f8 01       	movw	r30, r16
    11ce:	93 83       	std	Z+3, r25	; 0x03
    11d0:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    11d2:	f8 01       	movw	r30, r16
    11d4:	80 85       	ldd	r24, Z+8	; 0x08
    11d6:	88 23       	and	r24, r24
    11d8:	b1 f0       	breq	.+44     	; 0x1206 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    11da:	c8 01       	movw	r24, r16
    11dc:	08 96       	adiw	r24, 0x08	; 8
    11de:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <xTaskRemoveFromEventList>
    11e2:	88 23       	and	r24, r24
    11e4:	81 f0       	breq	.+32     	; 0x1206 <xQueueGenericReceive+0xa4>
						{
							queueYIELD_IF_USING_PREEMPTION();
    11e6:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vPortYield>
    11ea:	0d c0       	rjmp	.+26     	; 0x1206 <xQueueGenericReceive+0xa4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    11ec:	f8 01       	movw	r30, r16
    11ee:	d7 82       	std	Z+7, r13	; 0x07
    11f0:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11f2:	81 89       	ldd	r24, Z+17	; 0x11
    11f4:	88 23       	and	r24, r24
    11f6:	39 f0       	breq	.+14     	; 0x1206 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    11f8:	c8 01       	movw	r24, r16
    11fa:	41 96       	adiw	r24, 0x11	; 17
    11fc:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <xTaskRemoveFromEventList>
    1200:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1202:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1206:	0f 90       	pop	r0
    1208:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    120a:	81 e0       	ldi	r24, 0x01	; 1
    120c:	64 c0       	rjmp	.+200    	; 0x12d6 <xQueueGenericReceive+0x174>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    120e:	8c 81       	ldd	r24, Y+4	; 0x04
    1210:	9d 81       	ldd	r25, Y+5	; 0x05
    1212:	89 2b       	or	r24, r25
    1214:	21 f4       	brne	.+8      	; 0x121e <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1216:	0f 90       	pop	r0
    1218:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    121a:	80 e0       	ldi	r24, 0x00	; 0
    121c:	5c c0       	rjmp	.+184    	; 0x12d6 <xQueueGenericReceive+0x174>
				}
				else if( xEntryTimeSet == pdFALSE )
    121e:	e1 10       	cpse	r14, r1
    1220:	05 c0       	rjmp	.+10     	; 0x122c <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1222:	ce 01       	movw	r24, r28
    1224:	01 96       	adiw	r24, 0x01	; 1
    1226:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    122a:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    122c:	0f 90       	pop	r0
    122e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1230:	0e 94 1f 0b 	call	0x163e	; 0x163e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1234:	0f b6       	in	r0, 0x3f	; 63
    1236:	f8 94       	cli
    1238:	0f 92       	push	r0
    123a:	f8 01       	movw	r30, r16
    123c:	85 8d       	ldd	r24, Z+29	; 0x1d
    123e:	8f 3f       	cpi	r24, 0xFF	; 255
    1240:	09 f4       	brne	.+2      	; 0x1244 <xQueueGenericReceive+0xe2>
    1242:	15 8e       	std	Z+29, r1	; 0x1d
    1244:	f8 01       	movw	r30, r16
    1246:	86 8d       	ldd	r24, Z+30	; 0x1e
    1248:	8f 3f       	cpi	r24, 0xFF	; 255
    124a:	09 f4       	brne	.+2      	; 0x124e <xQueueGenericReceive+0xec>
    124c:	16 8e       	std	Z+30, r1	; 0x1e
    124e:	0f 90       	pop	r0
    1250:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1252:	be 01       	movw	r22, r28
    1254:	6c 5f       	subi	r22, 0xFC	; 252
    1256:	7f 4f       	sbci	r23, 0xFF	; 255
    1258:	ce 01       	movw	r24, r28
    125a:	01 96       	adiw	r24, 0x01	; 1
    125c:	0e 94 9a 0d 	call	0x1b34	; 0x1b34 <xTaskCheckForTimeOut>
    1260:	81 11       	cpse	r24, r1
    1262:	2b c0       	rjmp	.+86     	; 0x12ba <xQueueGenericReceive+0x158>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1264:	0f b6       	in	r0, 0x3f	; 63
    1266:	f8 94       	cli
    1268:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    126a:	f8 01       	movw	r30, r16
    126c:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    126e:	0f 90       	pop	r0
    1270:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1272:	81 11       	cpse	r24, r1
    1274:	1c c0       	rjmp	.+56     	; 0x12ae <xQueueGenericReceive+0x14c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1276:	80 81       	ld	r24, Z
    1278:	91 81       	ldd	r25, Z+1	; 0x01
    127a:	89 2b       	or	r24, r25
    127c:	49 f4       	brne	.+18     	; 0x1290 <xQueueGenericReceive+0x12e>
					{
						taskENTER_CRITICAL();
    127e:	0f b6       	in	r0, 0x3f	; 63
    1280:	f8 94       	cli
    1282:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1284:	82 81       	ldd	r24, Z+2	; 0x02
    1286:	93 81       	ldd	r25, Z+3	; 0x03
    1288:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    128c:	0f 90       	pop	r0
    128e:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1290:	6c 81       	ldd	r22, Y+4	; 0x04
    1292:	7d 81       	ldd	r23, Y+5	; 0x05
    1294:	c6 01       	movw	r24, r12
    1296:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    129a:	c8 01       	movw	r24, r16
    129c:	0e 94 01 07 	call	0xe02	; 0xe02 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    12a0:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <xTaskResumeAll>
    12a4:	81 11       	cpse	r24, r1
    12a6:	7a cf       	rjmp	.-268    	; 0x119c <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
    12a8:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vPortYield>
    12ac:	77 cf       	rjmp	.-274    	; 0x119c <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    12ae:	c8 01       	movw	r24, r16
    12b0:	0e 94 01 07 	call	0xe02	; 0xe02 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    12b4:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <xTaskResumeAll>
    12b8:	71 cf       	rjmp	.-286    	; 0x119c <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    12ba:	c8 01       	movw	r24, r16
    12bc:	0e 94 01 07 	call	0xe02	; 0xe02 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    12c0:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    12c4:	0f b6       	in	r0, 0x3f	; 63
    12c6:	f8 94       	cli
    12c8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    12ca:	f8 01       	movw	r30, r16
    12cc:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    12ce:	0f 90       	pop	r0
    12d0:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    12d2:	81 11       	cpse	r24, r1
    12d4:	63 cf       	rjmp	.-314    	; 0x119c <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    12d6:	0f 90       	pop	r0
    12d8:	0f 90       	pop	r0
    12da:	0f 90       	pop	r0
    12dc:	0f 90       	pop	r0
    12de:	0f 90       	pop	r0
    12e0:	df 91       	pop	r29
    12e2:	cf 91       	pop	r28
    12e4:	1f 91       	pop	r17
    12e6:	0f 91       	pop	r16
    12e8:	ff 90       	pop	r15
    12ea:	ef 90       	pop	r14
    12ec:	df 90       	pop	r13
    12ee:	cf 90       	pop	r12
    12f0:	bf 90       	pop	r11
    12f2:	af 90       	pop	r10
    12f4:	9f 90       	pop	r9
    12f6:	8f 90       	pop	r8
    12f8:	08 95       	ret

000012fa <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    12fa:	e0 91 1e 06 	lds	r30, 0x061E	; 0x80061e <pxDelayedTaskList>
    12fe:	f0 91 1f 06 	lds	r31, 0x061F	; 0x80061f <pxDelayedTaskList+0x1>
    1302:	80 81       	ld	r24, Z
    1304:	81 11       	cpse	r24, r1
    1306:	07 c0       	rjmp	.+14     	; 0x1316 <prvResetNextTaskUnblockTime+0x1c>
    1308:	8f ef       	ldi	r24, 0xFF	; 255
    130a:	9f ef       	ldi	r25, 0xFF	; 255
    130c:	90 93 ff 05 	sts	0x05FF, r25	; 0x8005ff <xNextTaskUnblockTime+0x1>
    1310:	80 93 fe 05 	sts	0x05FE, r24	; 0x8005fe <xNextTaskUnblockTime>
    1314:	08 95       	ret
    1316:	e0 91 1e 06 	lds	r30, 0x061E	; 0x80061e <pxDelayedTaskList>
    131a:	f0 91 1f 06 	lds	r31, 0x061F	; 0x80061f <pxDelayedTaskList+0x1>
    131e:	05 80       	ldd	r0, Z+5	; 0x05
    1320:	f6 81       	ldd	r31, Z+6	; 0x06
    1322:	e0 2d       	mov	r30, r0
    1324:	06 80       	ldd	r0, Z+6	; 0x06
    1326:	f7 81       	ldd	r31, Z+7	; 0x07
    1328:	e0 2d       	mov	r30, r0
    132a:	82 81       	ldd	r24, Z+2	; 0x02
    132c:	93 81       	ldd	r25, Z+3	; 0x03
    132e:	90 93 ff 05 	sts	0x05FF, r25	; 0x8005ff <xNextTaskUnblockTime+0x1>
    1332:	80 93 fe 05 	sts	0x05FE, r24	; 0x8005fe <xNextTaskUnblockTime>
    1336:	08 95       	ret

00001338 <prvAddCurrentTaskToDelayedList>:
    1338:	0f 93       	push	r16
    133a:	1f 93       	push	r17
    133c:	cf 93       	push	r28
    133e:	df 93       	push	r29
    1340:	ec 01       	movw	r28, r24
    1342:	00 91 06 06 	lds	r16, 0x0606	; 0x800606 <xTickCount>
    1346:	10 91 07 06 	lds	r17, 0x0607	; 0x800607 <xTickCount+0x1>
    134a:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <pxCurrentTCB>
    134e:	90 91 57 06 	lds	r25, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1352:	02 96       	adiw	r24, 0x02	; 2
    1354:	0e 94 05 03 	call	0x60a	; 0x60a <uxListRemove>
    1358:	c0 0f       	add	r28, r16
    135a:	d1 1f       	adc	r29, r17
    135c:	e0 91 56 06 	lds	r30, 0x0656	; 0x800656 <pxCurrentTCB>
    1360:	f0 91 57 06 	lds	r31, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1364:	d3 83       	std	Z+3, r29	; 0x03
    1366:	c2 83       	std	Z+2, r28	; 0x02
    1368:	c0 17       	cp	r28, r16
    136a:	d1 07       	cpc	r29, r17
    136c:	68 f4       	brcc	.+26     	; 0x1388 <prvAddCurrentTaskToDelayedList+0x50>
    136e:	60 91 56 06 	lds	r22, 0x0656	; 0x800656 <pxCurrentTCB>
    1372:	70 91 57 06 	lds	r23, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1376:	80 91 1c 06 	lds	r24, 0x061C	; 0x80061c <pxOverflowDelayedTaskList>
    137a:	90 91 1d 06 	lds	r25, 0x061D	; 0x80061d <pxOverflowDelayedTaskList+0x1>
    137e:	6e 5f       	subi	r22, 0xFE	; 254
    1380:	7f 4f       	sbci	r23, 0xFF	; 255
    1382:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInsert>
    1386:	17 c0       	rjmp	.+46     	; 0x13b6 <prvAddCurrentTaskToDelayedList+0x7e>
    1388:	60 91 56 06 	lds	r22, 0x0656	; 0x800656 <pxCurrentTCB>
    138c:	70 91 57 06 	lds	r23, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1390:	80 91 1e 06 	lds	r24, 0x061E	; 0x80061e <pxDelayedTaskList>
    1394:	90 91 1f 06 	lds	r25, 0x061F	; 0x80061f <pxDelayedTaskList+0x1>
    1398:	6e 5f       	subi	r22, 0xFE	; 254
    139a:	7f 4f       	sbci	r23, 0xFF	; 255
    139c:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInsert>
    13a0:	80 91 fe 05 	lds	r24, 0x05FE	; 0x8005fe <xNextTaskUnblockTime>
    13a4:	90 91 ff 05 	lds	r25, 0x05FF	; 0x8005ff <xNextTaskUnblockTime+0x1>
    13a8:	c8 17       	cp	r28, r24
    13aa:	d9 07       	cpc	r29, r25
    13ac:	20 f4       	brcc	.+8      	; 0x13b6 <prvAddCurrentTaskToDelayedList+0x7e>
    13ae:	d0 93 ff 05 	sts	0x05FF, r29	; 0x8005ff <xNextTaskUnblockTime+0x1>
    13b2:	c0 93 fe 05 	sts	0x05FE, r28	; 0x8005fe <xNextTaskUnblockTime>
    13b6:	df 91       	pop	r29
    13b8:	cf 91       	pop	r28
    13ba:	1f 91       	pop	r17
    13bc:	0f 91       	pop	r16
    13be:	08 95       	ret

000013c0 <xTaskCreate>:
    13c0:	4f 92       	push	r4
    13c2:	5f 92       	push	r5
    13c4:	6f 92       	push	r6
    13c6:	7f 92       	push	r7
    13c8:	8f 92       	push	r8
    13ca:	9f 92       	push	r9
    13cc:	af 92       	push	r10
    13ce:	bf 92       	push	r11
    13d0:	cf 92       	push	r12
    13d2:	df 92       	push	r13
    13d4:	ef 92       	push	r14
    13d6:	ff 92       	push	r15
    13d8:	0f 93       	push	r16
    13da:	cf 93       	push	r28
    13dc:	df 93       	push	r29
    13de:	4c 01       	movw	r8, r24
    13e0:	6b 01       	movw	r12, r22
    13e2:	5a 01       	movw	r10, r20
    13e4:	29 01       	movw	r4, r18
    13e6:	ca 01       	movw	r24, r20
    13e8:	0e 94 89 04 	call	0x912	; 0x912 <pvPortMalloc>
    13ec:	3c 01       	movw	r6, r24
    13ee:	89 2b       	or	r24, r25
    13f0:	09 f4       	brne	.+2      	; 0x13f4 <xTaskCreate+0x34>
    13f2:	ea c0       	rjmp	.+468    	; 0x15c8 <xTaskCreate+0x208>
    13f4:	8c e2       	ldi	r24, 0x2C	; 44
    13f6:	90 e0       	ldi	r25, 0x00	; 0
    13f8:	0e 94 89 04 	call	0x912	; 0x912 <pvPortMalloc>
    13fc:	ec 01       	movw	r28, r24
    13fe:	89 2b       	or	r24, r25
    1400:	b1 f0       	breq	.+44     	; 0x142e <xTaskCreate+0x6e>
    1402:	78 8e       	std	Y+24, r7	; 0x18
    1404:	6f 8a       	std	Y+23, r6	; 0x17
    1406:	a5 01       	movw	r20, r10
    1408:	65 ea       	ldi	r22, 0xA5	; 165
    140a:	70 e0       	ldi	r23, 0x00	; 0
    140c:	c3 01       	movw	r24, r6
    140e:	0e 94 d6 0f 	call	0x1fac	; 0x1fac <memset>
    1412:	81 e0       	ldi	r24, 0x01	; 1
    1414:	a8 1a       	sub	r10, r24
    1416:	b1 08       	sbc	r11, r1
    1418:	8f 89       	ldd	r24, Y+23	; 0x17
    141a:	98 8d       	ldd	r25, Y+24	; 0x18
    141c:	a8 0e       	add	r10, r24
    141e:	b9 1e       	adc	r11, r25
    1420:	d6 01       	movw	r26, r12
    1422:	8c 91       	ld	r24, X
    1424:	89 8f       	std	Y+25, r24	; 0x19
    1426:	8c 91       	ld	r24, X
    1428:	81 11       	cpse	r24, r1
    142a:	05 c0       	rjmp	.+10     	; 0x1436 <xTaskCreate+0x76>
    142c:	18 c0       	rjmp	.+48     	; 0x145e <xTaskCreate+0x9e>
    142e:	c3 01       	movw	r24, r6
    1430:	0e 94 be 04 	call	0x97c	; 0x97c <vPortFree>
    1434:	c9 c0       	rjmp	.+402    	; 0x15c8 <xTaskCreate+0x208>
    1436:	ae 01       	movw	r20, r28
    1438:	46 5e       	subi	r20, 0xE6	; 230
    143a:	5f 4f       	sbci	r21, 0xFF	; 255
    143c:	f6 01       	movw	r30, r12
    143e:	31 96       	adiw	r30, 0x01	; 1
    1440:	b8 e0       	ldi	r27, 0x08	; 8
    1442:	cb 0e       	add	r12, r27
    1444:	d1 1c       	adc	r13, r1
    1446:	cf 01       	movw	r24, r30
    1448:	21 91       	ld	r18, Z+
    144a:	da 01       	movw	r26, r20
    144c:	2d 93       	st	X+, r18
    144e:	ad 01       	movw	r20, r26
    1450:	dc 01       	movw	r26, r24
    1452:	8c 91       	ld	r24, X
    1454:	88 23       	and	r24, r24
    1456:	19 f0       	breq	.+6      	; 0x145e <xTaskCreate+0x9e>
    1458:	ec 15       	cp	r30, r12
    145a:	fd 05       	cpc	r31, r13
    145c:	a1 f7       	brne	.-24     	; 0x1446 <xTaskCreate+0x86>
    145e:	18 a2       	std	Y+32, r1	; 0x20
    1460:	04 30       	cpi	r16, 0x04	; 4
    1462:	08 f0       	brcs	.+2      	; 0x1466 <xTaskCreate+0xa6>
    1464:	03 e0       	ldi	r16, 0x03	; 3
    1466:	0e 8b       	std	Y+22, r16	; 0x16
    1468:	0b a3       	std	Y+35, r16	; 0x23
    146a:	1c a2       	std	Y+36, r1	; 0x24
    146c:	6e 01       	movw	r12, r28
    146e:	b2 e0       	ldi	r27, 0x02	; 2
    1470:	cb 0e       	add	r12, r27
    1472:	d1 1c       	adc	r13, r1
    1474:	c6 01       	movw	r24, r12
    1476:	0e 94 af 02 	call	0x55e	; 0x55e <vListInitialiseItem>
    147a:	ce 01       	movw	r24, r28
    147c:	0c 96       	adiw	r24, 0x0c	; 12
    147e:	0e 94 af 02 	call	0x55e	; 0x55e <vListInitialiseItem>
    1482:	d9 87       	std	Y+9, r29	; 0x09
    1484:	c8 87       	std	Y+8, r28	; 0x08
    1486:	84 e0       	ldi	r24, 0x04	; 4
    1488:	90 e0       	ldi	r25, 0x00	; 0
    148a:	80 1b       	sub	r24, r16
    148c:	91 09       	sbc	r25, r1
    148e:	9d 87       	std	Y+13, r25	; 0x0d
    1490:	8c 87       	std	Y+12, r24	; 0x0c
    1492:	db 8b       	std	Y+19, r29	; 0x13
    1494:	ca 8b       	std	Y+18, r28	; 0x12
    1496:	1e a2       	std	Y+38, r1	; 0x26
    1498:	1d a2       	std	Y+37, r1	; 0x25
    149a:	1f a2       	std	Y+39, r1	; 0x27
    149c:	18 a6       	std	Y+40, r1	; 0x28
    149e:	19 a6       	std	Y+41, r1	; 0x29
    14a0:	1a a6       	std	Y+42, r1	; 0x2a
    14a2:	1b a6       	std	Y+43, r1	; 0x2b
    14a4:	a2 01       	movw	r20, r4
    14a6:	b4 01       	movw	r22, r8
    14a8:	c5 01       	movw	r24, r10
    14aa:	0e 94 2b 03 	call	0x656	; 0x656 <pxPortInitialiseStack>
    14ae:	99 83       	std	Y+1, r25	; 0x01
    14b0:	88 83       	st	Y, r24
    14b2:	e1 14       	cp	r14, r1
    14b4:	f1 04       	cpc	r15, r1
    14b6:	19 f0       	breq	.+6      	; 0x14be <xTaskCreate+0xfe>
    14b8:	f7 01       	movw	r30, r14
    14ba:	d1 83       	std	Z+1, r29	; 0x01
    14bc:	c0 83       	st	Z, r28
    14be:	0f b6       	in	r0, 0x3f	; 63
    14c0:	f8 94       	cli
    14c2:	0f 92       	push	r0
    14c4:	80 91 08 06 	lds	r24, 0x0608	; 0x800608 <uxCurrentNumberOfTasks>
    14c8:	8f 5f       	subi	r24, 0xFF	; 255
    14ca:	80 93 08 06 	sts	0x0608, r24	; 0x800608 <uxCurrentNumberOfTasks>
    14ce:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <pxCurrentTCB>
    14d2:	90 91 57 06 	lds	r25, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    14d6:	89 2b       	or	r24, r25
    14d8:	a9 f5       	brne	.+106    	; 0x1544 <xTaskCreate+0x184>
    14da:	d0 93 57 06 	sts	0x0657, r29	; 0x800657 <pxCurrentTCB+0x1>
    14de:	c0 93 56 06 	sts	0x0656, r28	; 0x800656 <pxCurrentTCB>
    14e2:	80 91 08 06 	lds	r24, 0x0608	; 0x800608 <uxCurrentNumberOfTasks>
    14e6:	81 30       	cpi	r24, 0x01	; 1
    14e8:	e9 f5       	brne	.+122    	; 0x1564 <xTaskCreate+0x1a4>
    14ea:	82 e3       	ldi	r24, 0x32	; 50
    14ec:	96 e0       	ldi	r25, 0x06	; 6
    14ee:	0e 94 a1 02 	call	0x542	; 0x542 <vListInitialise>
    14f2:	8b e3       	ldi	r24, 0x3B	; 59
    14f4:	96 e0       	ldi	r25, 0x06	; 6
    14f6:	0e 94 a1 02 	call	0x542	; 0x542 <vListInitialise>
    14fa:	84 e4       	ldi	r24, 0x44	; 68
    14fc:	96 e0       	ldi	r25, 0x06	; 6
    14fe:	0e 94 a1 02 	call	0x542	; 0x542 <vListInitialise>
    1502:	8d e4       	ldi	r24, 0x4D	; 77
    1504:	96 e0       	ldi	r25, 0x06	; 6
    1506:	0e 94 a1 02 	call	0x542	; 0x542 <vListInitialise>
    150a:	89 e2       	ldi	r24, 0x29	; 41
    150c:	96 e0       	ldi	r25, 0x06	; 6
    150e:	0e 94 a1 02 	call	0x542	; 0x542 <vListInitialise>
    1512:	80 e2       	ldi	r24, 0x20	; 32
    1514:	96 e0       	ldi	r25, 0x06	; 6
    1516:	0e 94 a1 02 	call	0x542	; 0x542 <vListInitialise>
    151a:	83 e1       	ldi	r24, 0x13	; 19
    151c:	96 e0       	ldi	r25, 0x06	; 6
    151e:	0e 94 a1 02 	call	0x542	; 0x542 <vListInitialise>
    1522:	8a e0       	ldi	r24, 0x0A	; 10
    1524:	96 e0       	ldi	r25, 0x06	; 6
    1526:	0e 94 a1 02 	call	0x542	; 0x542 <vListInitialise>
    152a:	89 e2       	ldi	r24, 0x29	; 41
    152c:	96 e0       	ldi	r25, 0x06	; 6
    152e:	90 93 1f 06 	sts	0x061F, r25	; 0x80061f <pxDelayedTaskList+0x1>
    1532:	80 93 1e 06 	sts	0x061E, r24	; 0x80061e <pxDelayedTaskList>
    1536:	80 e2       	ldi	r24, 0x20	; 32
    1538:	96 e0       	ldi	r25, 0x06	; 6
    153a:	90 93 1d 06 	sts	0x061D, r25	; 0x80061d <pxOverflowDelayedTaskList+0x1>
    153e:	80 93 1c 06 	sts	0x061C, r24	; 0x80061c <pxOverflowDelayedTaskList>
    1542:	10 c0       	rjmp	.+32     	; 0x1564 <xTaskCreate+0x1a4>
    1544:	80 91 04 06 	lds	r24, 0x0604	; 0x800604 <xSchedulerRunning>
    1548:	81 11       	cpse	r24, r1
    154a:	0c c0       	rjmp	.+24     	; 0x1564 <xTaskCreate+0x1a4>
    154c:	e0 91 56 06 	lds	r30, 0x0656	; 0x800656 <pxCurrentTCB>
    1550:	f0 91 57 06 	lds	r31, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1554:	96 89       	ldd	r25, Z+22	; 0x16
    1556:	8e 89       	ldd	r24, Y+22	; 0x16
    1558:	89 17       	cp	r24, r25
    155a:	20 f0       	brcs	.+8      	; 0x1564 <xTaskCreate+0x1a4>
    155c:	d0 93 57 06 	sts	0x0657, r29	; 0x800657 <pxCurrentTCB+0x1>
    1560:	c0 93 56 06 	sts	0x0656, r28	; 0x800656 <pxCurrentTCB>
    1564:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <uxTaskNumber>
    1568:	8f 5f       	subi	r24, 0xFF	; 255
    156a:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <uxTaskNumber>
    156e:	89 a3       	std	Y+33, r24	; 0x21
    1570:	8e 89       	ldd	r24, Y+22	; 0x16
    1572:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <uxTopReadyPriority>
    1576:	98 17       	cp	r25, r24
    1578:	10 f4       	brcc	.+4      	; 0x157e <xTaskCreate+0x1be>
    157a:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <uxTopReadyPriority>
    157e:	90 e0       	ldi	r25, 0x00	; 0
    1580:	9c 01       	movw	r18, r24
    1582:	22 0f       	add	r18, r18
    1584:	33 1f       	adc	r19, r19
    1586:	22 0f       	add	r18, r18
    1588:	33 1f       	adc	r19, r19
    158a:	22 0f       	add	r18, r18
    158c:	33 1f       	adc	r19, r19
    158e:	82 0f       	add	r24, r18
    1590:	93 1f       	adc	r25, r19
    1592:	b6 01       	movw	r22, r12
    1594:	8e 5c       	subi	r24, 0xCE	; 206
    1596:	99 4f       	sbci	r25, 0xF9	; 249
    1598:	0e 94 b3 02 	call	0x566	; 0x566 <vListInsertEnd>
    159c:	0f 90       	pop	r0
    159e:	0f be       	out	0x3f, r0	; 63
    15a0:	80 91 04 06 	lds	r24, 0x0604	; 0x800604 <xSchedulerRunning>
    15a4:	88 23       	and	r24, r24
    15a6:	61 f0       	breq	.+24     	; 0x15c0 <xTaskCreate+0x200>
    15a8:	e0 91 56 06 	lds	r30, 0x0656	; 0x800656 <pxCurrentTCB>
    15ac:	f0 91 57 06 	lds	r31, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    15b0:	96 89       	ldd	r25, Z+22	; 0x16
    15b2:	8e 89       	ldd	r24, Y+22	; 0x16
    15b4:	98 17       	cp	r25, r24
    15b6:	30 f4       	brcc	.+12     	; 0x15c4 <xTaskCreate+0x204>
    15b8:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vPortYield>
    15bc:	81 e0       	ldi	r24, 0x01	; 1
    15be:	05 c0       	rjmp	.+10     	; 0x15ca <xTaskCreate+0x20a>
    15c0:	81 e0       	ldi	r24, 0x01	; 1
    15c2:	03 c0       	rjmp	.+6      	; 0x15ca <xTaskCreate+0x20a>
    15c4:	81 e0       	ldi	r24, 0x01	; 1
    15c6:	01 c0       	rjmp	.+2      	; 0x15ca <xTaskCreate+0x20a>
    15c8:	8f ef       	ldi	r24, 0xFF	; 255
    15ca:	df 91       	pop	r29
    15cc:	cf 91       	pop	r28
    15ce:	0f 91       	pop	r16
    15d0:	ff 90       	pop	r15
    15d2:	ef 90       	pop	r14
    15d4:	df 90       	pop	r13
    15d6:	cf 90       	pop	r12
    15d8:	bf 90       	pop	r11
    15da:	af 90       	pop	r10
    15dc:	9f 90       	pop	r9
    15de:	8f 90       	pop	r8
    15e0:	7f 90       	pop	r7
    15e2:	6f 90       	pop	r6
    15e4:	5f 90       	pop	r5
    15e6:	4f 90       	pop	r4
    15e8:	08 95       	ret

000015ea <vTaskStartScheduler>:
    15ea:	ef 92       	push	r14
    15ec:	ff 92       	push	r15
    15ee:	0f 93       	push	r16
    15f0:	0f 2e       	mov	r0, r31
    15f2:	fc ef       	ldi	r31, 0xFC	; 252
    15f4:	ef 2e       	mov	r14, r31
    15f6:	f5 e0       	ldi	r31, 0x05	; 5
    15f8:	ff 2e       	mov	r15, r31
    15fa:	f0 2d       	mov	r31, r0
    15fc:	00 e0       	ldi	r16, 0x00	; 0
    15fe:	20 e0       	ldi	r18, 0x00	; 0
    1600:	30 e0       	ldi	r19, 0x00	; 0
    1602:	45 e5       	ldi	r20, 0x55	; 85
    1604:	50 e0       	ldi	r21, 0x00	; 0
    1606:	65 eb       	ldi	r22, 0xB5	; 181
    1608:	71 e0       	ldi	r23, 0x01	; 1
    160a:	83 e7       	ldi	r24, 0x73	; 115
    160c:	9c e0       	ldi	r25, 0x0C	; 12
    160e:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <xTaskCreate>
    1612:	81 30       	cpi	r24, 0x01	; 1
    1614:	81 f4       	brne	.+32     	; 0x1636 <vTaskStartScheduler+0x4c>
    1616:	f8 94       	cli
    1618:	8f ef       	ldi	r24, 0xFF	; 255
    161a:	9f ef       	ldi	r25, 0xFF	; 255
    161c:	90 93 ff 05 	sts	0x05FF, r25	; 0x8005ff <xNextTaskUnblockTime+0x1>
    1620:	80 93 fe 05 	sts	0x05FE, r24	; 0x8005fe <xNextTaskUnblockTime>
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	80 93 04 06 	sts	0x0604, r24	; 0x800604 <xSchedulerRunning>
    162a:	10 92 07 06 	sts	0x0607, r1	; 0x800607 <xTickCount+0x1>
    162e:	10 92 06 06 	sts	0x0606, r1	; 0x800606 <xTickCount>
    1632:	0e 94 97 03 	call	0x72e	; 0x72e <xPortStartScheduler>
    1636:	0f 91       	pop	r16
    1638:	ff 90       	pop	r15
    163a:	ef 90       	pop	r14
    163c:	08 95       	ret

0000163e <vTaskSuspendAll>:
    163e:	80 91 fb 05 	lds	r24, 0x05FB	; 0x8005fb <uxSchedulerSuspended>
    1642:	8f 5f       	subi	r24, 0xFF	; 255
    1644:	80 93 fb 05 	sts	0x05FB, r24	; 0x8005fb <uxSchedulerSuspended>
    1648:	08 95       	ret

0000164a <xTaskIncrementTick>:
    164a:	cf 92       	push	r12
    164c:	df 92       	push	r13
    164e:	ef 92       	push	r14
    1650:	ff 92       	push	r15
    1652:	0f 93       	push	r16
    1654:	1f 93       	push	r17
    1656:	cf 93       	push	r28
    1658:	df 93       	push	r29
    165a:	80 91 fb 05 	lds	r24, 0x05FB	; 0x8005fb <uxSchedulerSuspended>
    165e:	81 11       	cpse	r24, r1
    1660:	99 c0       	rjmp	.+306    	; 0x1794 <xTaskIncrementTick+0x14a>
    1662:	e0 90 06 06 	lds	r14, 0x0606	; 0x800606 <xTickCount>
    1666:	f0 90 07 06 	lds	r15, 0x0607	; 0x800607 <xTickCount+0x1>
    166a:	8f ef       	ldi	r24, 0xFF	; 255
    166c:	e8 1a       	sub	r14, r24
    166e:	f8 0a       	sbc	r15, r24
    1670:	f0 92 07 06 	sts	0x0607, r15	; 0x800607 <xTickCount+0x1>
    1674:	e0 92 06 06 	sts	0x0606, r14	; 0x800606 <xTickCount>
    1678:	e1 14       	cp	r14, r1
    167a:	f1 04       	cpc	r15, r1
    167c:	b9 f4       	brne	.+46     	; 0x16ac <xTaskIncrementTick+0x62>
    167e:	80 91 1e 06 	lds	r24, 0x061E	; 0x80061e <pxDelayedTaskList>
    1682:	90 91 1f 06 	lds	r25, 0x061F	; 0x80061f <pxDelayedTaskList+0x1>
    1686:	20 91 1c 06 	lds	r18, 0x061C	; 0x80061c <pxOverflowDelayedTaskList>
    168a:	30 91 1d 06 	lds	r19, 0x061D	; 0x80061d <pxOverflowDelayedTaskList+0x1>
    168e:	30 93 1f 06 	sts	0x061F, r19	; 0x80061f <pxDelayedTaskList+0x1>
    1692:	20 93 1e 06 	sts	0x061E, r18	; 0x80061e <pxDelayedTaskList>
    1696:	90 93 1d 06 	sts	0x061D, r25	; 0x80061d <pxOverflowDelayedTaskList+0x1>
    169a:	80 93 1c 06 	sts	0x061C, r24	; 0x80061c <pxOverflowDelayedTaskList>
    169e:	80 91 01 06 	lds	r24, 0x0601	; 0x800601 <xNumOfOverflows>
    16a2:	8f 5f       	subi	r24, 0xFF	; 255
    16a4:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <xNumOfOverflows>
    16a8:	0e 94 7d 09 	call	0x12fa	; 0x12fa <prvResetNextTaskUnblockTime>
    16ac:	80 91 fe 05 	lds	r24, 0x05FE	; 0x8005fe <xNextTaskUnblockTime>
    16b0:	90 91 ff 05 	lds	r25, 0x05FF	; 0x8005ff <xNextTaskUnblockTime+0x1>
    16b4:	e8 16       	cp	r14, r24
    16b6:	f9 06       	cpc	r15, r25
    16b8:	10 f4       	brcc	.+4      	; 0x16be <xTaskIncrementTick+0x74>
    16ba:	d1 2c       	mov	r13, r1
    16bc:	53 c0       	rjmp	.+166    	; 0x1764 <xTaskIncrementTick+0x11a>
    16be:	d1 2c       	mov	r13, r1
    16c0:	cc 24       	eor	r12, r12
    16c2:	c3 94       	inc	r12
    16c4:	e0 91 1e 06 	lds	r30, 0x061E	; 0x80061e <pxDelayedTaskList>
    16c8:	f0 91 1f 06 	lds	r31, 0x061F	; 0x80061f <pxDelayedTaskList+0x1>
    16cc:	80 81       	ld	r24, Z
    16ce:	81 11       	cpse	r24, r1
    16d0:	07 c0       	rjmp	.+14     	; 0x16e0 <xTaskIncrementTick+0x96>
    16d2:	8f ef       	ldi	r24, 0xFF	; 255
    16d4:	9f ef       	ldi	r25, 0xFF	; 255
    16d6:	90 93 ff 05 	sts	0x05FF, r25	; 0x8005ff <xNextTaskUnblockTime+0x1>
    16da:	80 93 fe 05 	sts	0x05FE, r24	; 0x8005fe <xNextTaskUnblockTime>
    16de:	42 c0       	rjmp	.+132    	; 0x1764 <xTaskIncrementTick+0x11a>
    16e0:	e0 91 1e 06 	lds	r30, 0x061E	; 0x80061e <pxDelayedTaskList>
    16e4:	f0 91 1f 06 	lds	r31, 0x061F	; 0x80061f <pxDelayedTaskList+0x1>
    16e8:	05 80       	ldd	r0, Z+5	; 0x05
    16ea:	f6 81       	ldd	r31, Z+6	; 0x06
    16ec:	e0 2d       	mov	r30, r0
    16ee:	c6 81       	ldd	r28, Z+6	; 0x06
    16f0:	d7 81       	ldd	r29, Z+7	; 0x07
    16f2:	8a 81       	ldd	r24, Y+2	; 0x02
    16f4:	9b 81       	ldd	r25, Y+3	; 0x03
    16f6:	e8 16       	cp	r14, r24
    16f8:	f9 06       	cpc	r15, r25
    16fa:	28 f4       	brcc	.+10     	; 0x1706 <xTaskIncrementTick+0xbc>
    16fc:	90 93 ff 05 	sts	0x05FF, r25	; 0x8005ff <xNextTaskUnblockTime+0x1>
    1700:	80 93 fe 05 	sts	0x05FE, r24	; 0x8005fe <xNextTaskUnblockTime>
    1704:	2f c0       	rjmp	.+94     	; 0x1764 <xTaskIncrementTick+0x11a>
    1706:	8e 01       	movw	r16, r28
    1708:	0e 5f       	subi	r16, 0xFE	; 254
    170a:	1f 4f       	sbci	r17, 0xFF	; 255
    170c:	c8 01       	movw	r24, r16
    170e:	0e 94 05 03 	call	0x60a	; 0x60a <uxListRemove>
    1712:	8c 89       	ldd	r24, Y+20	; 0x14
    1714:	9d 89       	ldd	r25, Y+21	; 0x15
    1716:	89 2b       	or	r24, r25
    1718:	21 f0       	breq	.+8      	; 0x1722 <xTaskIncrementTick+0xd8>
    171a:	ce 01       	movw	r24, r28
    171c:	0c 96       	adiw	r24, 0x0c	; 12
    171e:	0e 94 05 03 	call	0x60a	; 0x60a <uxListRemove>
    1722:	8e 89       	ldd	r24, Y+22	; 0x16
    1724:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <uxTopReadyPriority>
    1728:	98 17       	cp	r25, r24
    172a:	10 f4       	brcc	.+4      	; 0x1730 <xTaskIncrementTick+0xe6>
    172c:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <uxTopReadyPriority>
    1730:	90 e0       	ldi	r25, 0x00	; 0
    1732:	9c 01       	movw	r18, r24
    1734:	22 0f       	add	r18, r18
    1736:	33 1f       	adc	r19, r19
    1738:	22 0f       	add	r18, r18
    173a:	33 1f       	adc	r19, r19
    173c:	22 0f       	add	r18, r18
    173e:	33 1f       	adc	r19, r19
    1740:	82 0f       	add	r24, r18
    1742:	93 1f       	adc	r25, r19
    1744:	b8 01       	movw	r22, r16
    1746:	8e 5c       	subi	r24, 0xCE	; 206
    1748:	99 4f       	sbci	r25, 0xF9	; 249
    174a:	0e 94 b3 02 	call	0x566	; 0x566 <vListInsertEnd>
    174e:	e0 91 56 06 	lds	r30, 0x0656	; 0x800656 <pxCurrentTCB>
    1752:	f0 91 57 06 	lds	r31, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1756:	9e 89       	ldd	r25, Y+22	; 0x16
    1758:	86 89       	ldd	r24, Z+22	; 0x16
    175a:	98 17       	cp	r25, r24
    175c:	08 f4       	brcc	.+2      	; 0x1760 <xTaskIncrementTick+0x116>
    175e:	b2 cf       	rjmp	.-156    	; 0x16c4 <xTaskIncrementTick+0x7a>
    1760:	dc 2c       	mov	r13, r12
    1762:	b0 cf       	rjmp	.-160    	; 0x16c4 <xTaskIncrementTick+0x7a>
    1764:	e0 91 56 06 	lds	r30, 0x0656	; 0x800656 <pxCurrentTCB>
    1768:	f0 91 57 06 	lds	r31, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    176c:	86 89       	ldd	r24, Z+22	; 0x16
    176e:	90 e0       	ldi	r25, 0x00	; 0
    1770:	fc 01       	movw	r30, r24
    1772:	ee 0f       	add	r30, r30
    1774:	ff 1f       	adc	r31, r31
    1776:	ee 0f       	add	r30, r30
    1778:	ff 1f       	adc	r31, r31
    177a:	ee 0f       	add	r30, r30
    177c:	ff 1f       	adc	r31, r31
    177e:	8e 0f       	add	r24, r30
    1780:	9f 1f       	adc	r25, r31
    1782:	fc 01       	movw	r30, r24
    1784:	ee 5c       	subi	r30, 0xCE	; 206
    1786:	f9 4f       	sbci	r31, 0xF9	; 249
    1788:	80 81       	ld	r24, Z
    178a:	82 30       	cpi	r24, 0x02	; 2
    178c:	48 f0       	brcs	.+18     	; 0x17a0 <xTaskIncrementTick+0x156>
    178e:	dd 24       	eor	r13, r13
    1790:	d3 94       	inc	r13
    1792:	06 c0       	rjmp	.+12     	; 0x17a0 <xTaskIncrementTick+0x156>
    1794:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <uxPendedTicks>
    1798:	8f 5f       	subi	r24, 0xFF	; 255
    179a:	80 93 03 06 	sts	0x0603, r24	; 0x800603 <uxPendedTicks>
    179e:	d1 2c       	mov	r13, r1
    17a0:	80 91 02 06 	lds	r24, 0x0602	; 0x800602 <xYieldPending>
    17a4:	88 23       	and	r24, r24
    17a6:	11 f0       	breq	.+4      	; 0x17ac <xTaskIncrementTick+0x162>
    17a8:	dd 24       	eor	r13, r13
    17aa:	d3 94       	inc	r13
    17ac:	8d 2d       	mov	r24, r13
    17ae:	df 91       	pop	r29
    17b0:	cf 91       	pop	r28
    17b2:	1f 91       	pop	r17
    17b4:	0f 91       	pop	r16
    17b6:	ff 90       	pop	r15
    17b8:	ef 90       	pop	r14
    17ba:	df 90       	pop	r13
    17bc:	cf 90       	pop	r12
    17be:	08 95       	ret

000017c0 <xTaskResumeAll>:
    17c0:	df 92       	push	r13
    17c2:	ef 92       	push	r14
    17c4:	ff 92       	push	r15
    17c6:	0f 93       	push	r16
    17c8:	1f 93       	push	r17
    17ca:	cf 93       	push	r28
    17cc:	df 93       	push	r29
    17ce:	0f b6       	in	r0, 0x3f	; 63
    17d0:	f8 94       	cli
    17d2:	0f 92       	push	r0
    17d4:	80 91 fb 05 	lds	r24, 0x05FB	; 0x8005fb <uxSchedulerSuspended>
    17d8:	81 50       	subi	r24, 0x01	; 1
    17da:	80 93 fb 05 	sts	0x05FB, r24	; 0x8005fb <uxSchedulerSuspended>
    17de:	80 91 fb 05 	lds	r24, 0x05FB	; 0x8005fb <uxSchedulerSuspended>
    17e2:	81 11       	cpse	r24, r1
    17e4:	5f c0       	rjmp	.+190    	; 0x18a4 <xTaskResumeAll+0xe4>
    17e6:	80 91 08 06 	lds	r24, 0x0608	; 0x800608 <uxCurrentNumberOfTasks>
    17ea:	81 11       	cpse	r24, r1
    17ec:	33 c0       	rjmp	.+102    	; 0x1854 <xTaskResumeAll+0x94>
    17ee:	5d c0       	rjmp	.+186    	; 0x18aa <xTaskResumeAll+0xea>
    17f0:	d7 01       	movw	r26, r14
    17f2:	15 96       	adiw	r26, 0x05	; 5
    17f4:	ed 91       	ld	r30, X+
    17f6:	fc 91       	ld	r31, X
    17f8:	16 97       	sbiw	r26, 0x06	; 6
    17fa:	c6 81       	ldd	r28, Z+6	; 0x06
    17fc:	d7 81       	ldd	r29, Z+7	; 0x07
    17fe:	ce 01       	movw	r24, r28
    1800:	0c 96       	adiw	r24, 0x0c	; 12
    1802:	0e 94 05 03 	call	0x60a	; 0x60a <uxListRemove>
    1806:	8e 01       	movw	r16, r28
    1808:	0e 5f       	subi	r16, 0xFE	; 254
    180a:	1f 4f       	sbci	r17, 0xFF	; 255
    180c:	c8 01       	movw	r24, r16
    180e:	0e 94 05 03 	call	0x60a	; 0x60a <uxListRemove>
    1812:	8e 89       	ldd	r24, Y+22	; 0x16
    1814:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <uxTopReadyPriority>
    1818:	98 17       	cp	r25, r24
    181a:	10 f4       	brcc	.+4      	; 0x1820 <xTaskResumeAll+0x60>
    181c:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <uxTopReadyPriority>
    1820:	90 e0       	ldi	r25, 0x00	; 0
    1822:	9c 01       	movw	r18, r24
    1824:	22 0f       	add	r18, r18
    1826:	33 1f       	adc	r19, r19
    1828:	22 0f       	add	r18, r18
    182a:	33 1f       	adc	r19, r19
    182c:	22 0f       	add	r18, r18
    182e:	33 1f       	adc	r19, r19
    1830:	82 0f       	add	r24, r18
    1832:	93 1f       	adc	r25, r19
    1834:	b8 01       	movw	r22, r16
    1836:	8e 5c       	subi	r24, 0xCE	; 206
    1838:	99 4f       	sbci	r25, 0xF9	; 249
    183a:	0e 94 b3 02 	call	0x566	; 0x566 <vListInsertEnd>
    183e:	e0 91 56 06 	lds	r30, 0x0656	; 0x800656 <pxCurrentTCB>
    1842:	f0 91 57 06 	lds	r31, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1846:	9e 89       	ldd	r25, Y+22	; 0x16
    1848:	86 89       	ldd	r24, Z+22	; 0x16
    184a:	98 17       	cp	r25, r24
    184c:	68 f0       	brcs	.+26     	; 0x1868 <xTaskResumeAll+0xa8>
    184e:	d0 92 02 06 	sts	0x0602, r13	; 0x800602 <xYieldPending>
    1852:	0a c0       	rjmp	.+20     	; 0x1868 <xTaskResumeAll+0xa8>
    1854:	c0 e0       	ldi	r28, 0x00	; 0
    1856:	d0 e0       	ldi	r29, 0x00	; 0
    1858:	0f 2e       	mov	r0, r31
    185a:	f3 e1       	ldi	r31, 0x13	; 19
    185c:	ef 2e       	mov	r14, r31
    185e:	f6 e0       	ldi	r31, 0x06	; 6
    1860:	ff 2e       	mov	r15, r31
    1862:	f0 2d       	mov	r31, r0
    1864:	dd 24       	eor	r13, r13
    1866:	d3 94       	inc	r13
    1868:	f7 01       	movw	r30, r14
    186a:	80 81       	ld	r24, Z
    186c:	81 11       	cpse	r24, r1
    186e:	c0 cf       	rjmp	.-128    	; 0x17f0 <xTaskResumeAll+0x30>
    1870:	cd 2b       	or	r28, r29
    1872:	11 f0       	breq	.+4      	; 0x1878 <xTaskResumeAll+0xb8>
    1874:	0e 94 7d 09 	call	0x12fa	; 0x12fa <prvResetNextTaskUnblockTime>
    1878:	c0 91 03 06 	lds	r28, 0x0603	; 0x800603 <uxPendedTicks>
    187c:	cc 23       	and	r28, r28
    187e:	51 f0       	breq	.+20     	; 0x1894 <xTaskResumeAll+0xd4>
    1880:	d1 e0       	ldi	r29, 0x01	; 1
    1882:	0e 94 25 0b 	call	0x164a	; 0x164a <xTaskIncrementTick>
    1886:	81 11       	cpse	r24, r1
    1888:	d0 93 02 06 	sts	0x0602, r29	; 0x800602 <xYieldPending>
    188c:	c1 50       	subi	r28, 0x01	; 1
    188e:	c9 f7       	brne	.-14     	; 0x1882 <xTaskResumeAll+0xc2>
    1890:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <uxPendedTicks>
    1894:	80 91 02 06 	lds	r24, 0x0602	; 0x800602 <xYieldPending>
    1898:	88 23       	and	r24, r24
    189a:	31 f0       	breq	.+12     	; 0x18a8 <xTaskResumeAll+0xe8>
    189c:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vPortYield>
    18a0:	81 e0       	ldi	r24, 0x01	; 1
    18a2:	03 c0       	rjmp	.+6      	; 0x18aa <xTaskResumeAll+0xea>
    18a4:	80 e0       	ldi	r24, 0x00	; 0
    18a6:	01 c0       	rjmp	.+2      	; 0x18aa <xTaskResumeAll+0xea>
    18a8:	80 e0       	ldi	r24, 0x00	; 0
    18aa:	0f 90       	pop	r0
    18ac:	0f be       	out	0x3f, r0	; 63
    18ae:	df 91       	pop	r29
    18b0:	cf 91       	pop	r28
    18b2:	1f 91       	pop	r17
    18b4:	0f 91       	pop	r16
    18b6:	ff 90       	pop	r15
    18b8:	ef 90       	pop	r14
    18ba:	df 90       	pop	r13
    18bc:	08 95       	ret

000018be <vTaskDelay>:
    18be:	cf 93       	push	r28
    18c0:	df 93       	push	r29
    18c2:	ec 01       	movw	r28, r24
    18c4:	89 2b       	or	r24, r25
    18c6:	51 f0       	breq	.+20     	; 0x18dc <vTaskDelay+0x1e>
    18c8:	0e 94 1f 0b 	call	0x163e	; 0x163e <vTaskSuspendAll>
    18cc:	60 e0       	ldi	r22, 0x00	; 0
    18ce:	ce 01       	movw	r24, r28
    18d0:	0e 94 9c 09 	call	0x1338	; 0x1338 <prvAddCurrentTaskToDelayedList>
    18d4:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <xTaskResumeAll>
    18d8:	81 11       	cpse	r24, r1
    18da:	02 c0       	rjmp	.+4      	; 0x18e0 <vTaskDelay+0x22>
    18dc:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vPortYield>
    18e0:	df 91       	pop	r29
    18e2:	cf 91       	pop	r28
    18e4:	08 95       	ret

000018e6 <prvIdleTask>:
    18e6:	0a e0       	ldi	r16, 0x0A	; 10
    18e8:	16 e0       	ldi	r17, 0x06	; 6
    18ea:	0f 2e       	mov	r0, r31
    18ec:	f2 e3       	ldi	r31, 0x32	; 50
    18ee:	ef 2e       	mov	r14, r31
    18f0:	f6 e0       	ldi	r31, 0x06	; 6
    18f2:	ff 2e       	mov	r15, r31
    18f4:	f0 2d       	mov	r31, r0
    18f6:	29 c0       	rjmp	.+82     	; 0x194a <prvIdleTask+0x64>
    18f8:	0e 94 1f 0b 	call	0x163e	; 0x163e <vTaskSuspendAll>
    18fc:	d8 01       	movw	r26, r16
    18fe:	cc 91       	ld	r28, X
    1900:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <xTaskResumeAll>
    1904:	cc 23       	and	r28, r28
    1906:	09 f1       	breq	.+66     	; 0x194a <prvIdleTask+0x64>
    1908:	0f b6       	in	r0, 0x3f	; 63
    190a:	f8 94       	cli
    190c:	0f 92       	push	r0
    190e:	d8 01       	movw	r26, r16
    1910:	15 96       	adiw	r26, 0x05	; 5
    1912:	ed 91       	ld	r30, X+
    1914:	fc 91       	ld	r31, X
    1916:	16 97       	sbiw	r26, 0x06	; 6
    1918:	c6 81       	ldd	r28, Z+6	; 0x06
    191a:	d7 81       	ldd	r29, Z+7	; 0x07
    191c:	ce 01       	movw	r24, r28
    191e:	02 96       	adiw	r24, 0x02	; 2
    1920:	0e 94 05 03 	call	0x60a	; 0x60a <uxListRemove>
    1924:	80 91 08 06 	lds	r24, 0x0608	; 0x800608 <uxCurrentNumberOfTasks>
    1928:	81 50       	subi	r24, 0x01	; 1
    192a:	80 93 08 06 	sts	0x0608, r24	; 0x800608 <uxCurrentNumberOfTasks>
    192e:	80 91 09 06 	lds	r24, 0x0609	; 0x800609 <uxDeletedTasksWaitingCleanUp>
    1932:	81 50       	subi	r24, 0x01	; 1
    1934:	80 93 09 06 	sts	0x0609, r24	; 0x800609 <uxDeletedTasksWaitingCleanUp>
    1938:	0f 90       	pop	r0
    193a:	0f be       	out	0x3f, r0	; 63
    193c:	8f 89       	ldd	r24, Y+23	; 0x17
    193e:	98 8d       	ldd	r25, Y+24	; 0x18
    1940:	0e 94 be 04 	call	0x97c	; 0x97c <vPortFree>
    1944:	ce 01       	movw	r24, r28
    1946:	0e 94 be 04 	call	0x97c	; 0x97c <vPortFree>
    194a:	80 91 09 06 	lds	r24, 0x0609	; 0x800609 <uxDeletedTasksWaitingCleanUp>
    194e:	81 11       	cpse	r24, r1
    1950:	d3 cf       	rjmp	.-90     	; 0x18f8 <prvIdleTask+0x12>
    1952:	f7 01       	movw	r30, r14
    1954:	80 81       	ld	r24, Z
    1956:	82 30       	cpi	r24, 0x02	; 2
    1958:	10 f0       	brcs	.+4      	; 0x195e <prvIdleTask+0x78>
    195a:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vPortYield>
    195e:	0e 94 84 01 	call	0x308	; 0x308 <vApplicationIdleHook>
    1962:	f3 cf       	rjmp	.-26     	; 0x194a <prvIdleTask+0x64>

00001964 <vTaskSetApplicationTaskTag>:
    1964:	00 97       	sbiw	r24, 0x00	; 0
    1966:	21 f4       	brne	.+8      	; 0x1970 <vTaskSetApplicationTaskTag+0xc>
    1968:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <pxCurrentTCB>
    196c:	90 91 57 06 	lds	r25, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1970:	0f b6       	in	r0, 0x3f	; 63
    1972:	f8 94       	cli
    1974:	0f 92       	push	r0
    1976:	fc 01       	movw	r30, r24
    1978:	76 a3       	std	Z+38, r23	; 0x26
    197a:	65 a3       	std	Z+37, r22	; 0x25
    197c:	0f 90       	pop	r0
    197e:	0f be       	out	0x3f, r0	; 63
    1980:	08 95       	ret

00001982 <vTaskSwitchContext>:
    1982:	80 91 fb 05 	lds	r24, 0x05FB	; 0x8005fb <uxSchedulerSuspended>
    1986:	88 23       	and	r24, r24
    1988:	21 f0       	breq	.+8      	; 0x1992 <vTaskSwitchContext+0x10>
    198a:	81 e0       	ldi	r24, 0x01	; 1
    198c:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <xYieldPending>
    1990:	08 95       	ret
    1992:	10 92 02 06 	sts	0x0602, r1	; 0x800602 <xYieldPending>
    1996:	e0 91 56 06 	lds	r30, 0x0656	; 0x800656 <pxCurrentTCB>
    199a:	f0 91 57 06 	lds	r31, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    199e:	85 a1       	ldd	r24, Z+37	; 0x25
    19a0:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <switch_out>
    19a4:	20 91 05 06 	lds	r18, 0x0605	; 0x800605 <uxTopReadyPriority>
    19a8:	82 2f       	mov	r24, r18
    19aa:	90 e0       	ldi	r25, 0x00	; 0
    19ac:	fc 01       	movw	r30, r24
    19ae:	ee 0f       	add	r30, r30
    19b0:	ff 1f       	adc	r31, r31
    19b2:	ee 0f       	add	r30, r30
    19b4:	ff 1f       	adc	r31, r31
    19b6:	ee 0f       	add	r30, r30
    19b8:	ff 1f       	adc	r31, r31
    19ba:	e8 0f       	add	r30, r24
    19bc:	f9 1f       	adc	r31, r25
    19be:	ee 5c       	subi	r30, 0xCE	; 206
    19c0:	f9 4f       	sbci	r31, 0xF9	; 249
    19c2:	30 81       	ld	r19, Z
    19c4:	31 11       	cpse	r19, r1
    19c6:	11 c0       	rjmp	.+34     	; 0x19ea <vTaskSwitchContext+0x68>
    19c8:	21 50       	subi	r18, 0x01	; 1
    19ca:	82 2f       	mov	r24, r18
    19cc:	90 e0       	ldi	r25, 0x00	; 0
    19ce:	fc 01       	movw	r30, r24
    19d0:	ee 0f       	add	r30, r30
    19d2:	ff 1f       	adc	r31, r31
    19d4:	ee 0f       	add	r30, r30
    19d6:	ff 1f       	adc	r31, r31
    19d8:	ee 0f       	add	r30, r30
    19da:	ff 1f       	adc	r31, r31
    19dc:	e8 0f       	add	r30, r24
    19de:	f9 1f       	adc	r31, r25
    19e0:	ee 5c       	subi	r30, 0xCE	; 206
    19e2:	f9 4f       	sbci	r31, 0xF9	; 249
    19e4:	30 81       	ld	r19, Z
    19e6:	33 23       	and	r19, r19
    19e8:	79 f3       	breq	.-34     	; 0x19c8 <vTaskSwitchContext+0x46>
    19ea:	ac 01       	movw	r20, r24
    19ec:	44 0f       	add	r20, r20
    19ee:	55 1f       	adc	r21, r21
    19f0:	44 0f       	add	r20, r20
    19f2:	55 1f       	adc	r21, r21
    19f4:	44 0f       	add	r20, r20
    19f6:	55 1f       	adc	r21, r21
    19f8:	48 0f       	add	r20, r24
    19fa:	59 1f       	adc	r21, r25
    19fc:	da 01       	movw	r26, r20
    19fe:	ae 5c       	subi	r26, 0xCE	; 206
    1a00:	b9 4f       	sbci	r27, 0xF9	; 249
    1a02:	11 96       	adiw	r26, 0x01	; 1
    1a04:	ed 91       	ld	r30, X+
    1a06:	fc 91       	ld	r31, X
    1a08:	12 97       	sbiw	r26, 0x02	; 2
    1a0a:	02 80       	ldd	r0, Z+2	; 0x02
    1a0c:	f3 81       	ldd	r31, Z+3	; 0x03
    1a0e:	e0 2d       	mov	r30, r0
    1a10:	12 96       	adiw	r26, 0x02	; 2
    1a12:	fc 93       	st	X, r31
    1a14:	ee 93       	st	-X, r30
    1a16:	11 97       	sbiw	r26, 0x01	; 1
    1a18:	4b 5c       	subi	r20, 0xCB	; 203
    1a1a:	59 4f       	sbci	r21, 0xF9	; 249
    1a1c:	e4 17       	cp	r30, r20
    1a1e:	f5 07       	cpc	r31, r21
    1a20:	29 f4       	brne	.+10     	; 0x1a2c <vTaskSwitchContext+0xaa>
    1a22:	42 81       	ldd	r20, Z+2	; 0x02
    1a24:	53 81       	ldd	r21, Z+3	; 0x03
    1a26:	fd 01       	movw	r30, r26
    1a28:	52 83       	std	Z+2, r21	; 0x02
    1a2a:	41 83       	std	Z+1, r20	; 0x01
    1a2c:	fc 01       	movw	r30, r24
    1a2e:	ee 0f       	add	r30, r30
    1a30:	ff 1f       	adc	r31, r31
    1a32:	ee 0f       	add	r30, r30
    1a34:	ff 1f       	adc	r31, r31
    1a36:	ee 0f       	add	r30, r30
    1a38:	ff 1f       	adc	r31, r31
    1a3a:	8e 0f       	add	r24, r30
    1a3c:	9f 1f       	adc	r25, r31
    1a3e:	fc 01       	movw	r30, r24
    1a40:	ee 5c       	subi	r30, 0xCE	; 206
    1a42:	f9 4f       	sbci	r31, 0xF9	; 249
    1a44:	01 80       	ldd	r0, Z+1	; 0x01
    1a46:	f2 81       	ldd	r31, Z+2	; 0x02
    1a48:	e0 2d       	mov	r30, r0
    1a4a:	86 81       	ldd	r24, Z+6	; 0x06
    1a4c:	97 81       	ldd	r25, Z+7	; 0x07
    1a4e:	90 93 57 06 	sts	0x0657, r25	; 0x800657 <pxCurrentTCB+0x1>
    1a52:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <pxCurrentTCB>
    1a56:	20 93 05 06 	sts	0x0605, r18	; 0x800605 <uxTopReadyPriority>
    1a5a:	e0 91 56 06 	lds	r30, 0x0656	; 0x800656 <pxCurrentTCB>
    1a5e:	f0 91 57 06 	lds	r31, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1a62:	85 a1       	ldd	r24, Z+37	; 0x25
    1a64:	0e 94 4f 02 	call	0x49e	; 0x49e <switch_in>
    1a68:	08 95       	ret

00001a6a <vTaskPlaceOnEventList>:
    1a6a:	cf 93       	push	r28
    1a6c:	df 93       	push	r29
    1a6e:	eb 01       	movw	r28, r22
    1a70:	60 91 56 06 	lds	r22, 0x0656	; 0x800656 <pxCurrentTCB>
    1a74:	70 91 57 06 	lds	r23, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1a78:	64 5f       	subi	r22, 0xF4	; 244
    1a7a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a7c:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInsert>
    1a80:	61 e0       	ldi	r22, 0x01	; 1
    1a82:	ce 01       	movw	r24, r28
    1a84:	0e 94 9c 09 	call	0x1338	; 0x1338 <prvAddCurrentTaskToDelayedList>
    1a88:	df 91       	pop	r29
    1a8a:	cf 91       	pop	r28
    1a8c:	08 95       	ret

00001a8e <xTaskRemoveFromEventList>:
    1a8e:	0f 93       	push	r16
    1a90:	1f 93       	push	r17
    1a92:	cf 93       	push	r28
    1a94:	df 93       	push	r29
    1a96:	dc 01       	movw	r26, r24
    1a98:	15 96       	adiw	r26, 0x05	; 5
    1a9a:	ed 91       	ld	r30, X+
    1a9c:	fc 91       	ld	r31, X
    1a9e:	16 97       	sbiw	r26, 0x06	; 6
    1aa0:	c6 81       	ldd	r28, Z+6	; 0x06
    1aa2:	d7 81       	ldd	r29, Z+7	; 0x07
    1aa4:	8e 01       	movw	r16, r28
    1aa6:	04 5f       	subi	r16, 0xF4	; 244
    1aa8:	1f 4f       	sbci	r17, 0xFF	; 255
    1aaa:	c8 01       	movw	r24, r16
    1aac:	0e 94 05 03 	call	0x60a	; 0x60a <uxListRemove>
    1ab0:	80 91 fb 05 	lds	r24, 0x05FB	; 0x8005fb <uxSchedulerSuspended>
    1ab4:	81 11       	cpse	r24, r1
    1ab6:	1c c0       	rjmp	.+56     	; 0x1af0 <xTaskRemoveFromEventList+0x62>
    1ab8:	0a 50       	subi	r16, 0x0A	; 10
    1aba:	11 09       	sbc	r17, r1
    1abc:	c8 01       	movw	r24, r16
    1abe:	0e 94 05 03 	call	0x60a	; 0x60a <uxListRemove>
    1ac2:	8e 89       	ldd	r24, Y+22	; 0x16
    1ac4:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <uxTopReadyPriority>
    1ac8:	98 17       	cp	r25, r24
    1aca:	10 f4       	brcc	.+4      	; 0x1ad0 <xTaskRemoveFromEventList+0x42>
    1acc:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <uxTopReadyPriority>
    1ad0:	90 e0       	ldi	r25, 0x00	; 0
    1ad2:	9c 01       	movw	r18, r24
    1ad4:	22 0f       	add	r18, r18
    1ad6:	33 1f       	adc	r19, r19
    1ad8:	22 0f       	add	r18, r18
    1ada:	33 1f       	adc	r19, r19
    1adc:	22 0f       	add	r18, r18
    1ade:	33 1f       	adc	r19, r19
    1ae0:	82 0f       	add	r24, r18
    1ae2:	93 1f       	adc	r25, r19
    1ae4:	b8 01       	movw	r22, r16
    1ae6:	8e 5c       	subi	r24, 0xCE	; 206
    1ae8:	99 4f       	sbci	r25, 0xF9	; 249
    1aea:	0e 94 b3 02 	call	0x566	; 0x566 <vListInsertEnd>
    1aee:	05 c0       	rjmp	.+10     	; 0x1afa <xTaskRemoveFromEventList+0x6c>
    1af0:	b8 01       	movw	r22, r16
    1af2:	83 e1       	ldi	r24, 0x13	; 19
    1af4:	96 e0       	ldi	r25, 0x06	; 6
    1af6:	0e 94 b3 02 	call	0x566	; 0x566 <vListInsertEnd>
    1afa:	e0 91 56 06 	lds	r30, 0x0656	; 0x800656 <pxCurrentTCB>
    1afe:	f0 91 57 06 	lds	r31, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1b02:	9e 89       	ldd	r25, Y+22	; 0x16
    1b04:	86 89       	ldd	r24, Z+22	; 0x16
    1b06:	89 17       	cp	r24, r25
    1b08:	20 f4       	brcc	.+8      	; 0x1b12 <xTaskRemoveFromEventList+0x84>
    1b0a:	81 e0       	ldi	r24, 0x01	; 1
    1b0c:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <xYieldPending>
    1b10:	01 c0       	rjmp	.+2      	; 0x1b14 <xTaskRemoveFromEventList+0x86>
    1b12:	80 e0       	ldi	r24, 0x00	; 0
    1b14:	df 91       	pop	r29
    1b16:	cf 91       	pop	r28
    1b18:	1f 91       	pop	r17
    1b1a:	0f 91       	pop	r16
    1b1c:	08 95       	ret

00001b1e <vTaskSetTimeOutState>:
    1b1e:	20 91 01 06 	lds	r18, 0x0601	; 0x800601 <xNumOfOverflows>
    1b22:	fc 01       	movw	r30, r24
    1b24:	20 83       	st	Z, r18
    1b26:	20 91 06 06 	lds	r18, 0x0606	; 0x800606 <xTickCount>
    1b2a:	30 91 07 06 	lds	r19, 0x0607	; 0x800607 <xTickCount+0x1>
    1b2e:	32 83       	std	Z+2, r19	; 0x02
    1b30:	21 83       	std	Z+1, r18	; 0x01
    1b32:	08 95       	ret

00001b34 <xTaskCheckForTimeOut>:
    1b34:	cf 93       	push	r28
    1b36:	df 93       	push	r29
    1b38:	fc 01       	movw	r30, r24
    1b3a:	0f b6       	in	r0, 0x3f	; 63
    1b3c:	f8 94       	cli
    1b3e:	0f 92       	push	r0
    1b40:	20 91 06 06 	lds	r18, 0x0606	; 0x800606 <xTickCount>
    1b44:	30 91 07 06 	lds	r19, 0x0607	; 0x800607 <xTickCount+0x1>
    1b48:	80 91 01 06 	lds	r24, 0x0601	; 0x800601 <xNumOfOverflows>
    1b4c:	90 81       	ld	r25, Z
    1b4e:	98 17       	cp	r25, r24
    1b50:	29 f0       	breq	.+10     	; 0x1b5c <xTaskCheckForTimeOut+0x28>
    1b52:	81 81       	ldd	r24, Z+1	; 0x01
    1b54:	92 81       	ldd	r25, Z+2	; 0x02
    1b56:	28 17       	cp	r18, r24
    1b58:	39 07       	cpc	r19, r25
    1b5a:	b0 f4       	brcc	.+44     	; 0x1b88 <xTaskCheckForTimeOut+0x54>
    1b5c:	a1 81       	ldd	r26, Z+1	; 0x01
    1b5e:	b2 81       	ldd	r27, Z+2	; 0x02
    1b60:	eb 01       	movw	r28, r22
    1b62:	48 81       	ld	r20, Y
    1b64:	59 81       	ldd	r21, Y+1	; 0x01
    1b66:	c9 01       	movw	r24, r18
    1b68:	8a 1b       	sub	r24, r26
    1b6a:	9b 0b       	sbc	r25, r27
    1b6c:	84 17       	cp	r24, r20
    1b6e:	95 07       	cpc	r25, r21
    1b70:	68 f4       	brcc	.+26     	; 0x1b8c <xTaskCheckForTimeOut+0x58>
    1b72:	cf 01       	movw	r24, r30
    1b74:	a2 1b       	sub	r26, r18
    1b76:	b3 0b       	sbc	r27, r19
    1b78:	4a 0f       	add	r20, r26
    1b7a:	5b 1f       	adc	r21, r27
    1b7c:	59 83       	std	Y+1, r21	; 0x01
    1b7e:	48 83       	st	Y, r20
    1b80:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <vTaskSetTimeOutState>
    1b84:	80 e0       	ldi	r24, 0x00	; 0
    1b86:	03 c0       	rjmp	.+6      	; 0x1b8e <xTaskCheckForTimeOut+0x5a>
    1b88:	81 e0       	ldi	r24, 0x01	; 1
    1b8a:	01 c0       	rjmp	.+2      	; 0x1b8e <xTaskCheckForTimeOut+0x5a>
    1b8c:	81 e0       	ldi	r24, 0x01	; 1
    1b8e:	0f 90       	pop	r0
    1b90:	0f be       	out	0x3f, r0	; 63
    1b92:	df 91       	pop	r29
    1b94:	cf 91       	pop	r28
    1b96:	08 95       	ret

00001b98 <vTaskMissedYield>:
    1b98:	81 e0       	ldi	r24, 0x01	; 1
    1b9a:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <xYieldPending>
    1b9e:	08 95       	ret

00001ba0 <vTaskPriorityInherit>:
    1ba0:	0f 93       	push	r16
    1ba2:	1f 93       	push	r17
    1ba4:	cf 93       	push	r28
    1ba6:	df 93       	push	r29
    1ba8:	fc 01       	movw	r30, r24
    1baa:	89 2b       	or	r24, r25
    1bac:	09 f4       	brne	.+2      	; 0x1bb0 <vTaskPriorityInherit+0x10>
    1bae:	55 c0       	rjmp	.+170    	; 0x1c5a <vTaskPriorityInherit+0xba>
    1bb0:	26 89       	ldd	r18, Z+22	; 0x16
    1bb2:	a0 91 56 06 	lds	r26, 0x0656	; 0x800656 <pxCurrentTCB>
    1bb6:	b0 91 57 06 	lds	r27, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1bba:	56 96       	adiw	r26, 0x16	; 22
    1bbc:	8c 91       	ld	r24, X
    1bbe:	28 17       	cp	r18, r24
    1bc0:	08 f0       	brcs	.+2      	; 0x1bc4 <vTaskPriorityInherit+0x24>
    1bc2:	4b c0       	rjmp	.+150    	; 0x1c5a <vTaskPriorityInherit+0xba>
    1bc4:	84 85       	ldd	r24, Z+12	; 0x0c
    1bc6:	95 85       	ldd	r25, Z+13	; 0x0d
    1bc8:	99 23       	and	r25, r25
    1bca:	64 f0       	brlt	.+24     	; 0x1be4 <vTaskPriorityInherit+0x44>
    1bcc:	a0 91 56 06 	lds	r26, 0x0656	; 0x800656 <pxCurrentTCB>
    1bd0:	b0 91 57 06 	lds	r27, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1bd4:	56 96       	adiw	r26, 0x16	; 22
    1bd6:	3c 91       	ld	r19, X
    1bd8:	84 e0       	ldi	r24, 0x04	; 4
    1bda:	90 e0       	ldi	r25, 0x00	; 0
    1bdc:	83 1b       	sub	r24, r19
    1bde:	91 09       	sbc	r25, r1
    1be0:	95 87       	std	Z+13, r25	; 0x0d
    1be2:	84 87       	std	Z+12, r24	; 0x0c
    1be4:	30 e0       	ldi	r19, 0x00	; 0
    1be6:	c9 01       	movw	r24, r18
    1be8:	88 0f       	add	r24, r24
    1bea:	99 1f       	adc	r25, r25
    1bec:	88 0f       	add	r24, r24
    1bee:	99 1f       	adc	r25, r25
    1bf0:	88 0f       	add	r24, r24
    1bf2:	99 1f       	adc	r25, r25
    1bf4:	28 0f       	add	r18, r24
    1bf6:	39 1f       	adc	r19, r25
    1bf8:	2e 5c       	subi	r18, 0xCE	; 206
    1bfa:	39 4f       	sbci	r19, 0xF9	; 249
    1bfc:	82 85       	ldd	r24, Z+10	; 0x0a
    1bfe:	93 85       	ldd	r25, Z+11	; 0x0b
    1c00:	82 17       	cp	r24, r18
    1c02:	93 07       	cpc	r25, r19
    1c04:	19 f5       	brne	.+70     	; 0x1c4c <vTaskPriorityInherit+0xac>
    1c06:	8f 01       	movw	r16, r30
    1c08:	ef 01       	movw	r28, r30
    1c0a:	22 96       	adiw	r28, 0x02	; 2
    1c0c:	ce 01       	movw	r24, r28
    1c0e:	0e 94 05 03 	call	0x60a	; 0x60a <uxListRemove>
    1c12:	e0 91 56 06 	lds	r30, 0x0656	; 0x800656 <pxCurrentTCB>
    1c16:	f0 91 57 06 	lds	r31, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1c1a:	86 89       	ldd	r24, Z+22	; 0x16
    1c1c:	f8 01       	movw	r30, r16
    1c1e:	86 8b       	std	Z+22, r24	; 0x16
    1c20:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <uxTopReadyPriority>
    1c24:	98 17       	cp	r25, r24
    1c26:	10 f4       	brcc	.+4      	; 0x1c2c <vTaskPriorityInherit+0x8c>
    1c28:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <uxTopReadyPriority>
    1c2c:	90 e0       	ldi	r25, 0x00	; 0
    1c2e:	9c 01       	movw	r18, r24
    1c30:	22 0f       	add	r18, r18
    1c32:	33 1f       	adc	r19, r19
    1c34:	22 0f       	add	r18, r18
    1c36:	33 1f       	adc	r19, r19
    1c38:	22 0f       	add	r18, r18
    1c3a:	33 1f       	adc	r19, r19
    1c3c:	82 0f       	add	r24, r18
    1c3e:	93 1f       	adc	r25, r19
    1c40:	be 01       	movw	r22, r28
    1c42:	8e 5c       	subi	r24, 0xCE	; 206
    1c44:	99 4f       	sbci	r25, 0xF9	; 249
    1c46:	0e 94 b3 02 	call	0x566	; 0x566 <vListInsertEnd>
    1c4a:	07 c0       	rjmp	.+14     	; 0x1c5a <vTaskPriorityInherit+0xba>
    1c4c:	a0 91 56 06 	lds	r26, 0x0656	; 0x800656 <pxCurrentTCB>
    1c50:	b0 91 57 06 	lds	r27, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1c54:	56 96       	adiw	r26, 0x16	; 22
    1c56:	8c 91       	ld	r24, X
    1c58:	86 8b       	std	Z+22, r24	; 0x16
    1c5a:	df 91       	pop	r29
    1c5c:	cf 91       	pop	r28
    1c5e:	1f 91       	pop	r17
    1c60:	0f 91       	pop	r16
    1c62:	08 95       	ret

00001c64 <xTaskPriorityDisinherit>:
    1c64:	0f 93       	push	r16
    1c66:	1f 93       	push	r17
    1c68:	cf 93       	push	r28
    1c6a:	df 93       	push	r29
    1c6c:	fc 01       	movw	r30, r24
    1c6e:	89 2b       	or	r24, r25
    1c70:	79 f1       	breq	.+94     	; 0x1cd0 <xTaskPriorityDisinherit+0x6c>
    1c72:	84 a1       	ldd	r24, Z+36	; 0x24
    1c74:	81 50       	subi	r24, 0x01	; 1
    1c76:	84 a3       	std	Z+36, r24	; 0x24
    1c78:	26 89       	ldd	r18, Z+22	; 0x16
    1c7a:	93 a1       	ldd	r25, Z+35	; 0x23
    1c7c:	29 17       	cp	r18, r25
    1c7e:	51 f1       	breq	.+84     	; 0x1cd4 <xTaskPriorityDisinherit+0x70>
    1c80:	81 11       	cpse	r24, r1
    1c82:	2a c0       	rjmp	.+84     	; 0x1cd8 <xTaskPriorityDisinherit+0x74>
    1c84:	ef 01       	movw	r28, r30
    1c86:	8f 01       	movw	r16, r30
    1c88:	0e 5f       	subi	r16, 0xFE	; 254
    1c8a:	1f 4f       	sbci	r17, 0xFF	; 255
    1c8c:	c8 01       	movw	r24, r16
    1c8e:	0e 94 05 03 	call	0x60a	; 0x60a <uxListRemove>
    1c92:	8b a1       	ldd	r24, Y+35	; 0x23
    1c94:	8e 8b       	std	Y+22, r24	; 0x16
    1c96:	24 e0       	ldi	r18, 0x04	; 4
    1c98:	30 e0       	ldi	r19, 0x00	; 0
    1c9a:	28 1b       	sub	r18, r24
    1c9c:	31 09       	sbc	r19, r1
    1c9e:	3d 87       	std	Y+13, r19	; 0x0d
    1ca0:	2c 87       	std	Y+12, r18	; 0x0c
    1ca2:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <uxTopReadyPriority>
    1ca6:	98 17       	cp	r25, r24
    1ca8:	10 f4       	brcc	.+4      	; 0x1cae <xTaskPriorityDisinherit+0x4a>
    1caa:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <uxTopReadyPriority>
    1cae:	90 e0       	ldi	r25, 0x00	; 0
    1cb0:	9c 01       	movw	r18, r24
    1cb2:	22 0f       	add	r18, r18
    1cb4:	33 1f       	adc	r19, r19
    1cb6:	22 0f       	add	r18, r18
    1cb8:	33 1f       	adc	r19, r19
    1cba:	22 0f       	add	r18, r18
    1cbc:	33 1f       	adc	r19, r19
    1cbe:	82 0f       	add	r24, r18
    1cc0:	93 1f       	adc	r25, r19
    1cc2:	b8 01       	movw	r22, r16
    1cc4:	8e 5c       	subi	r24, 0xCE	; 206
    1cc6:	99 4f       	sbci	r25, 0xF9	; 249
    1cc8:	0e 94 b3 02 	call	0x566	; 0x566 <vListInsertEnd>
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	05 c0       	rjmp	.+10     	; 0x1cda <xTaskPriorityDisinherit+0x76>
    1cd0:	80 e0       	ldi	r24, 0x00	; 0
    1cd2:	03 c0       	rjmp	.+6      	; 0x1cda <xTaskPriorityDisinherit+0x76>
    1cd4:	80 e0       	ldi	r24, 0x00	; 0
    1cd6:	01 c0       	rjmp	.+2      	; 0x1cda <xTaskPriorityDisinherit+0x76>
    1cd8:	80 e0       	ldi	r24, 0x00	; 0
    1cda:	df 91       	pop	r29
    1cdc:	cf 91       	pop	r28
    1cde:	1f 91       	pop	r17
    1ce0:	0f 91       	pop	r16
    1ce2:	08 95       	ret

00001ce4 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1ce4:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <pxCurrentTCB>
    1ce8:	90 91 57 06 	lds	r25, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1cec:	89 2b       	or	r24, r25
    1cee:	39 f0       	breq	.+14     	; 0x1cfe <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1cf0:	e0 91 56 06 	lds	r30, 0x0656	; 0x800656 <pxCurrentTCB>
    1cf4:	f0 91 57 06 	lds	r31, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
    1cf8:	84 a1       	ldd	r24, Z+36	; 0x24
    1cfa:	8f 5f       	subi	r24, 0xFF	; 255
    1cfc:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    1cfe:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <pxCurrentTCB>
    1d02:	90 91 57 06 	lds	r25, 0x0657	; 0x800657 <pxCurrentTCB+0x1>
	}
    1d06:	08 95       	ret

00001d08 <__udivmodsi4>:
    1d08:	a1 e2       	ldi	r26, 0x21	; 33
    1d0a:	1a 2e       	mov	r1, r26
    1d0c:	aa 1b       	sub	r26, r26
    1d0e:	bb 1b       	sub	r27, r27
    1d10:	fd 01       	movw	r30, r26
    1d12:	0d c0       	rjmp	.+26     	; 0x1d2e <__udivmodsi4_ep>

00001d14 <__udivmodsi4_loop>:
    1d14:	aa 1f       	adc	r26, r26
    1d16:	bb 1f       	adc	r27, r27
    1d18:	ee 1f       	adc	r30, r30
    1d1a:	ff 1f       	adc	r31, r31
    1d1c:	a2 17       	cp	r26, r18
    1d1e:	b3 07       	cpc	r27, r19
    1d20:	e4 07       	cpc	r30, r20
    1d22:	f5 07       	cpc	r31, r21
    1d24:	20 f0       	brcs	.+8      	; 0x1d2e <__udivmodsi4_ep>
    1d26:	a2 1b       	sub	r26, r18
    1d28:	b3 0b       	sbc	r27, r19
    1d2a:	e4 0b       	sbc	r30, r20
    1d2c:	f5 0b       	sbc	r31, r21

00001d2e <__udivmodsi4_ep>:
    1d2e:	66 1f       	adc	r22, r22
    1d30:	77 1f       	adc	r23, r23
    1d32:	88 1f       	adc	r24, r24
    1d34:	99 1f       	adc	r25, r25
    1d36:	1a 94       	dec	r1
    1d38:	69 f7       	brne	.-38     	; 0x1d14 <__udivmodsi4_loop>
    1d3a:	60 95       	com	r22
    1d3c:	70 95       	com	r23
    1d3e:	80 95       	com	r24
    1d40:	90 95       	com	r25
    1d42:	9b 01       	movw	r18, r22
    1d44:	ac 01       	movw	r20, r24
    1d46:	bd 01       	movw	r22, r26
    1d48:	cf 01       	movw	r24, r30
    1d4a:	08 95       	ret

00001d4c <__tablejump2__>:
    1d4c:	ee 0f       	add	r30, r30
    1d4e:	ff 1f       	adc	r31, r31
    1d50:	05 90       	lpm	r0, Z+
    1d52:	f4 91       	lpm	r31, Z
    1d54:	e0 2d       	mov	r30, r0
    1d56:	09 94       	ijmp

00001d58 <malloc>:
    1d58:	0f 93       	push	r16
    1d5a:	1f 93       	push	r17
    1d5c:	cf 93       	push	r28
    1d5e:	df 93       	push	r29
    1d60:	82 30       	cpi	r24, 0x02	; 2
    1d62:	91 05       	cpc	r25, r1
    1d64:	10 f4       	brcc	.+4      	; 0x1d6a <malloc+0x12>
    1d66:	82 e0       	ldi	r24, 0x02	; 2
    1d68:	90 e0       	ldi	r25, 0x00	; 0
    1d6a:	e0 91 5a 06 	lds	r30, 0x065A	; 0x80065a <__flp>
    1d6e:	f0 91 5b 06 	lds	r31, 0x065B	; 0x80065b <__flp+0x1>
    1d72:	20 e0       	ldi	r18, 0x00	; 0
    1d74:	30 e0       	ldi	r19, 0x00	; 0
    1d76:	a0 e0       	ldi	r26, 0x00	; 0
    1d78:	b0 e0       	ldi	r27, 0x00	; 0
    1d7a:	30 97       	sbiw	r30, 0x00	; 0
    1d7c:	19 f1       	breq	.+70     	; 0x1dc4 <malloc+0x6c>
    1d7e:	40 81       	ld	r20, Z
    1d80:	51 81       	ldd	r21, Z+1	; 0x01
    1d82:	02 81       	ldd	r16, Z+2	; 0x02
    1d84:	13 81       	ldd	r17, Z+3	; 0x03
    1d86:	48 17       	cp	r20, r24
    1d88:	59 07       	cpc	r21, r25
    1d8a:	c8 f0       	brcs	.+50     	; 0x1dbe <malloc+0x66>
    1d8c:	84 17       	cp	r24, r20
    1d8e:	95 07       	cpc	r25, r21
    1d90:	69 f4       	brne	.+26     	; 0x1dac <malloc+0x54>
    1d92:	10 97       	sbiw	r26, 0x00	; 0
    1d94:	31 f0       	breq	.+12     	; 0x1da2 <malloc+0x4a>
    1d96:	12 96       	adiw	r26, 0x02	; 2
    1d98:	0c 93       	st	X, r16
    1d9a:	12 97       	sbiw	r26, 0x02	; 2
    1d9c:	13 96       	adiw	r26, 0x03	; 3
    1d9e:	1c 93       	st	X, r17
    1da0:	27 c0       	rjmp	.+78     	; 0x1df0 <malloc+0x98>
    1da2:	00 93 5a 06 	sts	0x065A, r16	; 0x80065a <__flp>
    1da6:	10 93 5b 06 	sts	0x065B, r17	; 0x80065b <__flp+0x1>
    1daa:	22 c0       	rjmp	.+68     	; 0x1df0 <malloc+0x98>
    1dac:	21 15       	cp	r18, r1
    1dae:	31 05       	cpc	r19, r1
    1db0:	19 f0       	breq	.+6      	; 0x1db8 <malloc+0x60>
    1db2:	42 17       	cp	r20, r18
    1db4:	53 07       	cpc	r21, r19
    1db6:	18 f4       	brcc	.+6      	; 0x1dbe <malloc+0x66>
    1db8:	9a 01       	movw	r18, r20
    1dba:	bd 01       	movw	r22, r26
    1dbc:	ef 01       	movw	r28, r30
    1dbe:	df 01       	movw	r26, r30
    1dc0:	f8 01       	movw	r30, r16
    1dc2:	db cf       	rjmp	.-74     	; 0x1d7a <malloc+0x22>
    1dc4:	21 15       	cp	r18, r1
    1dc6:	31 05       	cpc	r19, r1
    1dc8:	f9 f0       	breq	.+62     	; 0x1e08 <malloc+0xb0>
    1dca:	28 1b       	sub	r18, r24
    1dcc:	39 0b       	sbc	r19, r25
    1dce:	24 30       	cpi	r18, 0x04	; 4
    1dd0:	31 05       	cpc	r19, r1
    1dd2:	80 f4       	brcc	.+32     	; 0x1df4 <malloc+0x9c>
    1dd4:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd6:	9b 81       	ldd	r25, Y+3	; 0x03
    1dd8:	61 15       	cp	r22, r1
    1dda:	71 05       	cpc	r23, r1
    1ddc:	21 f0       	breq	.+8      	; 0x1de6 <malloc+0x8e>
    1dde:	fb 01       	movw	r30, r22
    1de0:	93 83       	std	Z+3, r25	; 0x03
    1de2:	82 83       	std	Z+2, r24	; 0x02
    1de4:	04 c0       	rjmp	.+8      	; 0x1dee <malloc+0x96>
    1de6:	90 93 5b 06 	sts	0x065B, r25	; 0x80065b <__flp+0x1>
    1dea:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <__flp>
    1dee:	fe 01       	movw	r30, r28
    1df0:	32 96       	adiw	r30, 0x02	; 2
    1df2:	44 c0       	rjmp	.+136    	; 0x1e7c <malloc+0x124>
    1df4:	fe 01       	movw	r30, r28
    1df6:	e2 0f       	add	r30, r18
    1df8:	f3 1f       	adc	r31, r19
    1dfa:	81 93       	st	Z+, r24
    1dfc:	91 93       	st	Z+, r25
    1dfe:	22 50       	subi	r18, 0x02	; 2
    1e00:	31 09       	sbc	r19, r1
    1e02:	39 83       	std	Y+1, r19	; 0x01
    1e04:	28 83       	st	Y, r18
    1e06:	3a c0       	rjmp	.+116    	; 0x1e7c <malloc+0x124>
    1e08:	20 91 58 06 	lds	r18, 0x0658	; 0x800658 <__brkval>
    1e0c:	30 91 59 06 	lds	r19, 0x0659	; 0x800659 <__brkval+0x1>
    1e10:	23 2b       	or	r18, r19
    1e12:	41 f4       	brne	.+16     	; 0x1e24 <malloc+0xcc>
    1e14:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    1e18:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    1e1c:	30 93 59 06 	sts	0x0659, r19	; 0x800659 <__brkval+0x1>
    1e20:	20 93 58 06 	sts	0x0658, r18	; 0x800658 <__brkval>
    1e24:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    1e28:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    1e2c:	21 15       	cp	r18, r1
    1e2e:	31 05       	cpc	r19, r1
    1e30:	41 f4       	brne	.+16     	; 0x1e42 <malloc+0xea>
    1e32:	2d b7       	in	r18, 0x3d	; 61
    1e34:	3e b7       	in	r19, 0x3e	; 62
    1e36:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    1e3a:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    1e3e:	24 1b       	sub	r18, r20
    1e40:	35 0b       	sbc	r19, r21
    1e42:	e0 91 58 06 	lds	r30, 0x0658	; 0x800658 <__brkval>
    1e46:	f0 91 59 06 	lds	r31, 0x0659	; 0x800659 <__brkval+0x1>
    1e4a:	e2 17       	cp	r30, r18
    1e4c:	f3 07       	cpc	r31, r19
    1e4e:	a0 f4       	brcc	.+40     	; 0x1e78 <malloc+0x120>
    1e50:	2e 1b       	sub	r18, r30
    1e52:	3f 0b       	sbc	r19, r31
    1e54:	28 17       	cp	r18, r24
    1e56:	39 07       	cpc	r19, r25
    1e58:	78 f0       	brcs	.+30     	; 0x1e78 <malloc+0x120>
    1e5a:	ac 01       	movw	r20, r24
    1e5c:	4e 5f       	subi	r20, 0xFE	; 254
    1e5e:	5f 4f       	sbci	r21, 0xFF	; 255
    1e60:	24 17       	cp	r18, r20
    1e62:	35 07       	cpc	r19, r21
    1e64:	48 f0       	brcs	.+18     	; 0x1e78 <malloc+0x120>
    1e66:	4e 0f       	add	r20, r30
    1e68:	5f 1f       	adc	r21, r31
    1e6a:	50 93 59 06 	sts	0x0659, r21	; 0x800659 <__brkval+0x1>
    1e6e:	40 93 58 06 	sts	0x0658, r20	; 0x800658 <__brkval>
    1e72:	81 93       	st	Z+, r24
    1e74:	91 93       	st	Z+, r25
    1e76:	02 c0       	rjmp	.+4      	; 0x1e7c <malloc+0x124>
    1e78:	e0 e0       	ldi	r30, 0x00	; 0
    1e7a:	f0 e0       	ldi	r31, 0x00	; 0
    1e7c:	cf 01       	movw	r24, r30
    1e7e:	df 91       	pop	r29
    1e80:	cf 91       	pop	r28
    1e82:	1f 91       	pop	r17
    1e84:	0f 91       	pop	r16
    1e86:	08 95       	ret

00001e88 <free>:
    1e88:	cf 93       	push	r28
    1e8a:	df 93       	push	r29
    1e8c:	00 97       	sbiw	r24, 0x00	; 0
    1e8e:	09 f4       	brne	.+2      	; 0x1e92 <free+0xa>
    1e90:	81 c0       	rjmp	.+258    	; 0x1f94 <free+0x10c>
    1e92:	fc 01       	movw	r30, r24
    1e94:	32 97       	sbiw	r30, 0x02	; 2
    1e96:	13 82       	std	Z+3, r1	; 0x03
    1e98:	12 82       	std	Z+2, r1	; 0x02
    1e9a:	a0 91 5a 06 	lds	r26, 0x065A	; 0x80065a <__flp>
    1e9e:	b0 91 5b 06 	lds	r27, 0x065B	; 0x80065b <__flp+0x1>
    1ea2:	10 97       	sbiw	r26, 0x00	; 0
    1ea4:	81 f4       	brne	.+32     	; 0x1ec6 <free+0x3e>
    1ea6:	20 81       	ld	r18, Z
    1ea8:	31 81       	ldd	r19, Z+1	; 0x01
    1eaa:	82 0f       	add	r24, r18
    1eac:	93 1f       	adc	r25, r19
    1eae:	20 91 58 06 	lds	r18, 0x0658	; 0x800658 <__brkval>
    1eb2:	30 91 59 06 	lds	r19, 0x0659	; 0x800659 <__brkval+0x1>
    1eb6:	28 17       	cp	r18, r24
    1eb8:	39 07       	cpc	r19, r25
    1eba:	51 f5       	brne	.+84     	; 0x1f10 <free+0x88>
    1ebc:	f0 93 59 06 	sts	0x0659, r31	; 0x800659 <__brkval+0x1>
    1ec0:	e0 93 58 06 	sts	0x0658, r30	; 0x800658 <__brkval>
    1ec4:	67 c0       	rjmp	.+206    	; 0x1f94 <free+0x10c>
    1ec6:	ed 01       	movw	r28, r26
    1ec8:	20 e0       	ldi	r18, 0x00	; 0
    1eca:	30 e0       	ldi	r19, 0x00	; 0
    1ecc:	ce 17       	cp	r28, r30
    1ece:	df 07       	cpc	r29, r31
    1ed0:	40 f4       	brcc	.+16     	; 0x1ee2 <free+0x5a>
    1ed2:	4a 81       	ldd	r20, Y+2	; 0x02
    1ed4:	5b 81       	ldd	r21, Y+3	; 0x03
    1ed6:	9e 01       	movw	r18, r28
    1ed8:	41 15       	cp	r20, r1
    1eda:	51 05       	cpc	r21, r1
    1edc:	f1 f0       	breq	.+60     	; 0x1f1a <free+0x92>
    1ede:	ea 01       	movw	r28, r20
    1ee0:	f5 cf       	rjmp	.-22     	; 0x1ecc <free+0x44>
    1ee2:	d3 83       	std	Z+3, r29	; 0x03
    1ee4:	c2 83       	std	Z+2, r28	; 0x02
    1ee6:	40 81       	ld	r20, Z
    1ee8:	51 81       	ldd	r21, Z+1	; 0x01
    1eea:	84 0f       	add	r24, r20
    1eec:	95 1f       	adc	r25, r21
    1eee:	c8 17       	cp	r28, r24
    1ef0:	d9 07       	cpc	r29, r25
    1ef2:	59 f4       	brne	.+22     	; 0x1f0a <free+0x82>
    1ef4:	88 81       	ld	r24, Y
    1ef6:	99 81       	ldd	r25, Y+1	; 0x01
    1ef8:	84 0f       	add	r24, r20
    1efa:	95 1f       	adc	r25, r21
    1efc:	02 96       	adiw	r24, 0x02	; 2
    1efe:	91 83       	std	Z+1, r25	; 0x01
    1f00:	80 83       	st	Z, r24
    1f02:	8a 81       	ldd	r24, Y+2	; 0x02
    1f04:	9b 81       	ldd	r25, Y+3	; 0x03
    1f06:	93 83       	std	Z+3, r25	; 0x03
    1f08:	82 83       	std	Z+2, r24	; 0x02
    1f0a:	21 15       	cp	r18, r1
    1f0c:	31 05       	cpc	r19, r1
    1f0e:	29 f4       	brne	.+10     	; 0x1f1a <free+0x92>
    1f10:	f0 93 5b 06 	sts	0x065B, r31	; 0x80065b <__flp+0x1>
    1f14:	e0 93 5a 06 	sts	0x065A, r30	; 0x80065a <__flp>
    1f18:	3d c0       	rjmp	.+122    	; 0x1f94 <free+0x10c>
    1f1a:	e9 01       	movw	r28, r18
    1f1c:	fb 83       	std	Y+3, r31	; 0x03
    1f1e:	ea 83       	std	Y+2, r30	; 0x02
    1f20:	49 91       	ld	r20, Y+
    1f22:	59 91       	ld	r21, Y+
    1f24:	c4 0f       	add	r28, r20
    1f26:	d5 1f       	adc	r29, r21
    1f28:	ec 17       	cp	r30, r28
    1f2a:	fd 07       	cpc	r31, r29
    1f2c:	61 f4       	brne	.+24     	; 0x1f46 <free+0xbe>
    1f2e:	80 81       	ld	r24, Z
    1f30:	91 81       	ldd	r25, Z+1	; 0x01
    1f32:	84 0f       	add	r24, r20
    1f34:	95 1f       	adc	r25, r21
    1f36:	02 96       	adiw	r24, 0x02	; 2
    1f38:	e9 01       	movw	r28, r18
    1f3a:	99 83       	std	Y+1, r25	; 0x01
    1f3c:	88 83       	st	Y, r24
    1f3e:	82 81       	ldd	r24, Z+2	; 0x02
    1f40:	93 81       	ldd	r25, Z+3	; 0x03
    1f42:	9b 83       	std	Y+3, r25	; 0x03
    1f44:	8a 83       	std	Y+2, r24	; 0x02
    1f46:	e0 e0       	ldi	r30, 0x00	; 0
    1f48:	f0 e0       	ldi	r31, 0x00	; 0
    1f4a:	12 96       	adiw	r26, 0x02	; 2
    1f4c:	8d 91       	ld	r24, X+
    1f4e:	9c 91       	ld	r25, X
    1f50:	13 97       	sbiw	r26, 0x03	; 3
    1f52:	00 97       	sbiw	r24, 0x00	; 0
    1f54:	19 f0       	breq	.+6      	; 0x1f5c <free+0xd4>
    1f56:	fd 01       	movw	r30, r26
    1f58:	dc 01       	movw	r26, r24
    1f5a:	f7 cf       	rjmp	.-18     	; 0x1f4a <free+0xc2>
    1f5c:	8d 91       	ld	r24, X+
    1f5e:	9c 91       	ld	r25, X
    1f60:	11 97       	sbiw	r26, 0x01	; 1
    1f62:	9d 01       	movw	r18, r26
    1f64:	2e 5f       	subi	r18, 0xFE	; 254
    1f66:	3f 4f       	sbci	r19, 0xFF	; 255
    1f68:	82 0f       	add	r24, r18
    1f6a:	93 1f       	adc	r25, r19
    1f6c:	20 91 58 06 	lds	r18, 0x0658	; 0x800658 <__brkval>
    1f70:	30 91 59 06 	lds	r19, 0x0659	; 0x800659 <__brkval+0x1>
    1f74:	28 17       	cp	r18, r24
    1f76:	39 07       	cpc	r19, r25
    1f78:	69 f4       	brne	.+26     	; 0x1f94 <free+0x10c>
    1f7a:	30 97       	sbiw	r30, 0x00	; 0
    1f7c:	29 f4       	brne	.+10     	; 0x1f88 <free+0x100>
    1f7e:	10 92 5b 06 	sts	0x065B, r1	; 0x80065b <__flp+0x1>
    1f82:	10 92 5a 06 	sts	0x065A, r1	; 0x80065a <__flp>
    1f86:	02 c0       	rjmp	.+4      	; 0x1f8c <free+0x104>
    1f88:	13 82       	std	Z+3, r1	; 0x03
    1f8a:	12 82       	std	Z+2, r1	; 0x02
    1f8c:	b0 93 59 06 	sts	0x0659, r27	; 0x800659 <__brkval+0x1>
    1f90:	a0 93 58 06 	sts	0x0658, r26	; 0x800658 <__brkval>
    1f94:	df 91       	pop	r29
    1f96:	cf 91       	pop	r28
    1f98:	08 95       	ret

00001f9a <memcpy>:
    1f9a:	fb 01       	movw	r30, r22
    1f9c:	dc 01       	movw	r26, r24
    1f9e:	02 c0       	rjmp	.+4      	; 0x1fa4 <memcpy+0xa>
    1fa0:	01 90       	ld	r0, Z+
    1fa2:	0d 92       	st	X+, r0
    1fa4:	41 50       	subi	r20, 0x01	; 1
    1fa6:	50 40       	sbci	r21, 0x00	; 0
    1fa8:	d8 f7       	brcc	.-10     	; 0x1fa0 <memcpy+0x6>
    1faa:	08 95       	ret

00001fac <memset>:
    1fac:	dc 01       	movw	r26, r24
    1fae:	01 c0       	rjmp	.+2      	; 0x1fb2 <memset+0x6>
    1fb0:	6d 93       	st	X+, r22
    1fb2:	41 50       	subi	r20, 0x01	; 1
    1fb4:	50 40       	sbci	r21, 0x00	; 0
    1fb6:	e0 f7       	brcc	.-8      	; 0x1fb0 <memset+0x4>
    1fb8:	08 95       	ret

00001fba <_exit>:
    1fba:	f8 94       	cli

00001fbc <__stop_program>:
    1fbc:	ff cf       	rjmp	.-2      	; 0x1fbc <__stop_program>
